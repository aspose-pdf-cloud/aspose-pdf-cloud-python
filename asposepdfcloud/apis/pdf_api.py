# coding: utf-8

"""
    Aspose.PDF Cloud API Reference


Copyright (c) 2024 Aspose.PDF Cloud
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



    OpenAPI spec version: 3.0
    
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class PdfApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient(None, None)
            self.api_client = config.api_client

    def copy_file(self, src_path, dest_path, **kwargs):
        """
        Copy file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.copy_file(src_path, dest_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Source file path e.g. '/folder/file.ext' (required)
        :param str dest_path: Destination file path (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to copy
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.copy_file_with_http_info(src_path, dest_path, **kwargs)
        else:
            (data) = self.copy_file_with_http_info(src_path, dest_path, **kwargs)
            return data

    def copy_file_with_http_info(self, src_path, dest_path, **kwargs):
        """
        Copy file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.copy_file_with_http_info(src_path, dest_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Source file path e.g. '/folder/file.ext' (required)
        :param str dest_path: Destination file path (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to copy
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name', 'version_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `copy_file`")
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params) or (params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `copy_file`")


        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/file/copy/{srcPath}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def copy_folder(self, src_path, dest_path, **kwargs):
        """
        Copy folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.copy_folder(src_path, dest_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Source folder path e.g. '/src' (required)
        :param str dest_path: Destination folder path e.g. '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.copy_folder_with_http_info(src_path, dest_path, **kwargs)
        else:
            (data) = self.copy_folder_with_http_info(src_path, dest_path, **kwargs)
            return data

    def copy_folder_with_http_info(self, src_path, dest_path, **kwargs):
        """
        Copy folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.copy_folder_with_http_info(src_path, dest_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Source folder path e.g. '/src' (required)
        :param str dest_path: Destination folder path e.g. '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `copy_folder`")
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params) or (params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `copy_folder`")


        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/folder/copy/{srcPath}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_folder(self, path, **kwargs):
        """
        Create the folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_folder(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Folder path to create e.g. 'folder_1/folder_2/' (required)
        :param str storage_name: Storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_folder_with_http_info(path, **kwargs)
        else:
            (data) = self.create_folder_with_http_info(path, **kwargs)
            return data

    def create_folder_with_http_info(self, path, **kwargs):
        """
        Create the folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_folder_with_http_info(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Folder path to create e.g. 'folder_1/folder_2/' (required)
        :param str storage_name: Storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `create_folder`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/folder/{path}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_annotation(self, name, annotation_id, **kwargs):
        """
        Delete document annotation by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.delete_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def delete_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Delete document annotation by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `delete_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/{annotationId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_bookmark(self, name, bookmark_path, **kwargs):
        """
        Delete document bookmark by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_bookmark(name, bookmark_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_bookmark_with_http_info(name, bookmark_path, **kwargs)
        else:
            (data) = self.delete_bookmark_with_http_info(name, bookmark_path, **kwargs)
            return data

    def delete_bookmark_with_http_info(self, name, bookmark_path, **kwargs):
        """
        Delete document bookmark by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_bookmark_with_http_info(name, bookmark_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bookmark_path', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_bookmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_bookmark`")
        # verify the required parameter 'bookmark_path' is set
        if ('bookmark_path' not in params) or (params['bookmark_path'] is None):
            raise ValueError("Missing the required parameter `bookmark_path` when calling `delete_bookmark`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'bookmark_path' in params:
            path_params['bookmarkPath'] = params['bookmark_path']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/bookmarks/bookmark/{bookmarkPath}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_document_annotations(self, name, **kwargs):
        """
        Delete all annotations from the document
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_document_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_document_annotations_with_http_info(name, **kwargs)
            return data

    def delete_document_annotations_with_http_info(self, name, **kwargs):
        """
        Delete all annotations from the document
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_document_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_document_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_document_bookmarks(self, name, **kwargs):
        """
        Delete all document bookmarks.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_bookmarks(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_document_bookmarks_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_document_bookmarks_with_http_info(name, **kwargs)
            return data

    def delete_document_bookmarks_with_http_info(self, name, **kwargs):
        """
        Delete all document bookmarks.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_bookmarks_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_document_bookmarks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_document_bookmarks`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/bookmarks/tree', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_document_link_annotations(self, name, **kwargs):
        """
        Delete all link annotations from the document
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_link_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_document_link_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_document_link_annotations_with_http_info(name, **kwargs)
            return data

    def delete_document_link_annotations_with_http_info(self, name, **kwargs):
        """
        Delete all link annotations from the document
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_link_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_document_link_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_document_link_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/links', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_document_stamps(self, name, **kwargs):
        """
        Delete all stamps from the document
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_stamps(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_document_stamps_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_document_stamps_with_http_info(name, **kwargs)
            return data

    def delete_document_stamps_with_http_info(self, name, **kwargs):
        """
        Delete all stamps from the document
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_stamps_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_document_stamps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_document_stamps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/stamps', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_document_tables(self, name, **kwargs):
        """
        Delete all tables from the document
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_tables(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_document_tables_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_document_tables_with_http_info(name, **kwargs)
            return data

    def delete_document_tables_with_http_info(self, name, **kwargs):
        """
        Delete all tables from the document
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_document_tables_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_document_tables" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_document_tables`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/tables', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_field(self, name, field_name, **kwargs):
        """
        Delete document field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name/ (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.delete_field_with_http_info(name, field_name, **kwargs)
            return data

    def delete_field_with_http_info(self, name, field_name, **kwargs):
        """
        Delete document field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name/ (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `delete_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/{fieldName}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_file(self, path, **kwargs):
        """
        Delete file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_file(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to delete
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_file_with_http_info(path, **kwargs)
        else:
            (data) = self.delete_file_with_http_info(path, **kwargs)
            return data

    def delete_file_with_http_info(self, path, **kwargs):
        """
        Delete file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_file_with_http_info(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to delete
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_file`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/file/{path}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_folder(self, path, **kwargs):
        """
        Delete folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_folder(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :param bool recursive: Enable to delete folders, subfolders and files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_folder_with_http_info(path, **kwargs)
        else:
            (data) = self.delete_folder_with_http_info(path, **kwargs)
            return data

    def delete_folder_with_http_info(self, path, **kwargs):
        """
        Delete folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_folder_with_http_info(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :param bool recursive: Enable to delete folders, subfolders and files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_folder`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/folder/{path}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_image(self, name, image_id, **kwargs):
        """
        Delete image from document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_image(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_image_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.delete_image_with_http_info(name, image_id, **kwargs)
            return data

    def delete_image_with_http_info(self, name, image_id, **kwargs):
        """
        Delete image from document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_image_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_image`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `delete_image`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_link_annotation(self, name, link_id, **kwargs):
        """
        Delete document page link annotation by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_link_annotation(name, link_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str link_id: The link ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_link_annotation_with_http_info(name, link_id, **kwargs)
        else:
            (data) = self.delete_link_annotation_with_http_info(name, link_id, **kwargs)
            return data

    def delete_link_annotation_with_http_info(self, name, link_id, **kwargs):
        """
        Delete document page link annotation by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_link_annotation_with_http_info(name, link_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str link_id: The link ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'link_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_link_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_link_annotation`")
        # verify the required parameter 'link_id' is set
        if ('link_id' not in params) or (params['link_id'] is None):
            raise ValueError("Missing the required parameter `link_id` when calling `delete_link_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'link_id' in params:
            path_params['linkId'] = params['link_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/links/{linkId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_page(self, name, page_number, **kwargs):
        """
        Delete document page by its number.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_page_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.delete_page_with_http_info(name, page_number, **kwargs)
            return data

    def delete_page_with_http_info(self, name, page_number, **kwargs):
        """
        Delete document page by its number.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_page`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `delete_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_page_annotations(self, name, page_number, **kwargs):
        """
        Delete all annotations from the page
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_page_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.delete_page_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def delete_page_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Delete all annotations from the page
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_page_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `delete_page_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_page_link_annotations(self, name, page_number, **kwargs):
        """
        Delete all link annotations from the page
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_link_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_page_link_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.delete_page_link_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def delete_page_link_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Delete all link annotations from the page
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_link_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page_link_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_page_link_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `delete_page_link_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/links', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_page_stamps(self, name, page_number, **kwargs):
        """
        Delete all stamps from the page
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_stamps(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_page_stamps_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.delete_page_stamps_with_http_info(name, page_number, **kwargs)
            return data

    def delete_page_stamps_with_http_info(self, name, page_number, **kwargs):
        """
        Delete all stamps from the page
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_stamps_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page_stamps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_page_stamps`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `delete_page_stamps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/stamps', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_page_tables(self, name, page_number, **kwargs):
        """
        Delete all tables from the page
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_tables(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_page_tables_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.delete_page_tables_with_http_info(name, page_number, **kwargs)
            return data

    def delete_page_tables_with_http_info(self, name, page_number, **kwargs):
        """
        Delete all tables from the page
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_tables_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page_tables" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_page_tables`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `delete_page_tables`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/tables', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_properties(self, name, **kwargs):
        """
        Delete custom document properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_properties(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_properties_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_properties_with_http_info(name, **kwargs)
            return data

    def delete_properties_with_http_info(self, name, **kwargs):
        """
        Delete custom document properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_properties_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_properties`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/documentproperties', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_property(self, name, property_name, **kwargs):
        """
        Delete document property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_property(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str property_name: Property name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_property_with_http_info(name, property_name, **kwargs)
        else:
            (data) = self.delete_property_with_http_info(name, property_name, **kwargs)
            return data

    def delete_property_with_http_info(self, name, property_name, **kwargs):
        """
        Delete document property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_property_with_http_info(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str property_name: Property name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'property_name', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_property`")
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params) or (params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `delete_property`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'property_name' in params:
            path_params['propertyName'] = params['property_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/documentproperties/{propertyName}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_stamp(self, name, stamp_id, **kwargs):
        """
        Delete document stamp by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_stamp(name, stamp_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str stamp_id: The stamp ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_stamp_with_http_info(name, stamp_id, **kwargs)
        else:
            (data) = self.delete_stamp_with_http_info(name, stamp_id, **kwargs)
            return data

    def delete_stamp_with_http_info(self, name, stamp_id, **kwargs):
        """
        Delete document stamp by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_stamp_with_http_info(name, stamp_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str stamp_id: The stamp ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'stamp_id', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_stamp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_stamp`")
        # verify the required parameter 'stamp_id' is set
        if ('stamp_id' not in params) or (params['stamp_id'] is None):
            raise ValueError("Missing the required parameter `stamp_id` when calling `delete_stamp`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'stamp_id' in params:
            path_params['stampId'] = params['stamp_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/stamps/{stampId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_table(self, name, table_id, **kwargs):
        """
        Delete document table by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_table(name, table_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str table_id: The table ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_table_with_http_info(name, table_id, **kwargs)
        else:
            (data) = self.delete_table_with_http_info(name, table_id, **kwargs)
            return data

    def delete_table_with_http_info(self, name, table_id, **kwargs):
        """
        Delete document table by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_table_with_http_info(name, table_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str table_id: The table ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'table_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_table`")
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `delete_table`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/tables/{tableId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def download_file(self, path, **kwargs):
        """
        Download file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.download_file(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to download
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.download_file_with_http_info(path, **kwargs)
        else:
            (data) = self.download_file_with_http_info(path, **kwargs)
            return data

    def download_file_with_http_info(self, path, **kwargs):
        """
        Download file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.download_file_with_http_info(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to download
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `download_file`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/file/{path}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_bookmark(self, name, bookmark_path, **kwargs):
        """
        Read document bookmark.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bookmark(name, bookmark_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_bookmark_with_http_info(name, bookmark_path, **kwargs)
        else:
            (data) = self.get_bookmark_with_http_info(name, bookmark_path, **kwargs)
            return data

    def get_bookmark_with_http_info(self, name, bookmark_path, **kwargs):
        """
        Read document bookmark.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bookmark_with_http_info(name, bookmark_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bookmark_path', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bookmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_bookmark`")
        # verify the required parameter 'bookmark_path' is set
        if ('bookmark_path' not in params) or (params['bookmark_path'] is None):
            raise ValueError("Missing the required parameter `bookmark_path` when calling `get_bookmark`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'bookmark_path' in params:
            path_params['bookmarkPath'] = params['bookmark_path']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/bookmarks/bookmark/{bookmarkPath}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BookmarkResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_bookmarks(self, name, bookmark_path, **kwargs):
        """
        Read document bookmarks node list.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bookmarks(name, bookmark_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarksResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_bookmarks_with_http_info(name, bookmark_path, **kwargs)
        else:
            (data) = self.get_bookmarks_with_http_info(name, bookmark_path, **kwargs)
            return data

    def get_bookmarks_with_http_info(self, name, bookmark_path, **kwargs):
        """
        Read document bookmarks node list.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bookmarks_with_http_info(name, bookmark_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarksResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bookmark_path', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bookmarks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_bookmarks`")
        # verify the required parameter 'bookmark_path' is set
        if ('bookmark_path' not in params) or (params['bookmark_path'] is None):
            raise ValueError("Missing the required parameter `bookmark_path` when calling `get_bookmarks`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'bookmark_path' in params:
            path_params['bookmarkPath'] = params['bookmark_path']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/bookmarks/list/{bookmarkPath}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BookmarksResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_caret_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page caret annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_caret_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CaretAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_caret_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_caret_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_caret_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page caret annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_caret_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CaretAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_caret_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_caret_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_caret_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/caret/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CaretAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_check_box_field(self, name, field_name, **kwargs):
        """
        Read document checkbox field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_check_box_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CheckBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_check_box_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.get_check_box_field_with_http_info(name, field_name, **kwargs)
            return data

    def get_check_box_field_with_http_info(self, name, field_name, **kwargs):
        """
        Read document checkbox field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_check_box_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CheckBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_check_box_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_check_box_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `get_check_box_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/checkbox/{fieldName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CheckBoxFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_circle_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page circle annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_circle_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CircleAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_circle_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_circle_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_circle_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page circle annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_circle_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CircleAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_circle_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_circle_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_circle_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/circle/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CircleAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_combo_box_field(self, name, field_name, **kwargs):
        """
        Read document combobox field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_combo_box_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ComboBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_combo_box_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.get_combo_box_field_with_http_info(name, field_name, **kwargs)
            return data

    def get_combo_box_field_with_http_info(self, name, field_name, **kwargs):
        """
        Read document combobox field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_combo_box_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ComboBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_combo_box_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_combo_box_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `get_combo_box_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/combobox/{fieldName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ComboBoxFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disc_usage(self, **kwargs):
        """
        Get disc usage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disc_usage(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str storage_name: Storage name
        :return: DiscUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disc_usage_with_http_info(**kwargs)
        else:
            (data) = self.get_disc_usage_with_http_info(**kwargs)
            return data

    def get_disc_usage_with_http_info(self, **kwargs):
        """
        Get disc usage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disc_usage_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str storage_name: Storage name
        :return: DiscUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['storage_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disc_usage" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/disc', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DiscUsage',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document(self, name, **kwargs):
        """
        Read common document info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_with_http_info(name, **kwargs)
            return data

    def get_document_with_http_info(self, name, **kwargs):
        """
        Read common document info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_annotations(self, name, **kwargs):
        """
        Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AnnotationsInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_annotations_with_http_info(self, name, **kwargs):
        """
        Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AnnotationsInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnnotationsInfoResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_attachment_by_index(self, name, attachment_index, **kwargs):
        """
        Read document attachment info by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_attachment_by_index(name, attachment_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int attachment_index: The attachment index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_attachment_by_index_with_http_info(name, attachment_index, **kwargs)
        else:
            (data) = self.get_document_attachment_by_index_with_http_info(name, attachment_index, **kwargs)
            return data

    def get_document_attachment_by_index_with_http_info(self, name, attachment_index, **kwargs):
        """
        Read document attachment info by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_attachment_by_index_with_http_info(name, attachment_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int attachment_index: The attachment index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'attachment_index', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_attachment_by_index" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_attachment_by_index`")
        # verify the required parameter 'attachment_index' is set
        if ('attachment_index' not in params) or (params['attachment_index'] is None):
            raise ValueError("Missing the required parameter `attachment_index` when calling `get_document_attachment_by_index`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'attachment_index' in params:
            path_params['attachmentIndex'] = params['attachment_index']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/attachments/{attachmentIndex}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AttachmentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_attachments(self, name, **kwargs):
        """
        Read document attachments info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_attachments(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_attachments_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_attachments_with_http_info(name, **kwargs)
            return data

    def get_document_attachments_with_http_info(self, name, **kwargs):
        """
        Read document attachments info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_attachments_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_attachments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_attachments`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/attachments', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AttachmentsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_bookmarks(self, name, **kwargs):
        """
        Read document bookmarks tree.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_bookmarks(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarksResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_bookmarks_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_bookmarks_with_http_info(name, **kwargs)
            return data

    def get_document_bookmarks_with_http_info(self, name, **kwargs):
        """
        Read document bookmarks tree.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_bookmarks_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarksResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_bookmarks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_bookmarks`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/bookmarks/tree', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BookmarksResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_caret_annotations(self, name, **kwargs):
        """
        Read document caret annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_caret_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CaretAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_caret_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_caret_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_caret_annotations_with_http_info(self, name, **kwargs):
        """
        Read document caret annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_caret_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CaretAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_caret_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_caret_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/caret', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CaretAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_check_box_fields(self, name, **kwargs):
        """
        Read document checkbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_check_box_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CheckBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_check_box_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_check_box_fields_with_http_info(name, **kwargs)
            return data

    def get_document_check_box_fields_with_http_info(self, name, **kwargs):
        """
        Read document checkbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_check_box_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CheckBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_check_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_check_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/checkbox', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CheckBoxFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_circle_annotations(self, name, **kwargs):
        """
        Read document circle annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_circle_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CircleAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_circle_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_circle_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_circle_annotations_with_http_info(self, name, **kwargs):
        """
        Read document circle annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_circle_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CircleAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_circle_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_circle_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/circle', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CircleAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_combo_box_fields(self, name, **kwargs):
        """
        Read document combobox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_combo_box_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ComboBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_combo_box_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_combo_box_fields_with_http_info(name, **kwargs)
            return data

    def get_document_combo_box_fields_with_http_info(self, name, **kwargs):
        """
        Read document combobox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_combo_box_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ComboBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_combo_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_combo_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/combobox', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ComboBoxFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_display_properties(self, name, **kwargs):
        """
        Read document display properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_display_properties(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str storage:
        :param str folder:
        :return: DisplayPropertiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_display_properties_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_display_properties_with_http_info(name, **kwargs)
            return data

    def get_document_display_properties_with_http_info(self, name, **kwargs):
        """
        Read document display properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_display_properties_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str storage:
        :param str folder:
        :return: DisplayPropertiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_display_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_display_properties`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/displayproperties', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DisplayPropertiesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_file_attachment_annotations(self, name, **kwargs):
        """
        Read document FileAttachment annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_file_attachment_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FileAttachmentAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_file_attachment_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_file_attachment_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_file_attachment_annotations_with_http_info(self, name, **kwargs):
        """
        Read document FileAttachment annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_file_attachment_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FileAttachmentAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_file_attachment_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_file_attachment_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/fileattachment', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FileAttachmentAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_free_text_annotations(self, name, **kwargs):
        """
        Read document free text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_free_text_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FreeTextAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_free_text_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_free_text_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_free_text_annotations_with_http_info(self, name, **kwargs):
        """
        Read document free text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_free_text_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FreeTextAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_free_text_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_free_text_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/freetext', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FreeTextAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_highlight_annotations(self, name, **kwargs):
        """
        Read document highlight annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_highlight_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: HighlightAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_highlight_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_highlight_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_highlight_annotations_with_http_info(self, name, **kwargs):
        """
        Read document highlight annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_highlight_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: HighlightAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_highlight_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_highlight_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/highlight', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='HighlightAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_ink_annotations(self, name, **kwargs):
        """
        Read document ink annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_ink_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: InkAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_ink_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_ink_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_ink_annotations_with_http_info(self, name, **kwargs):
        """
        Read document ink annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_ink_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: InkAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_ink_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_ink_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/ink', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InkAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_line_annotations(self, name, **kwargs):
        """
        Read document line annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_line_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_line_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_line_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_line_annotations_with_http_info(self, name, **kwargs):
        """
        Read document line annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_line_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_line_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_line_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/line', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LineAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_list_box_fields(self, name, **kwargs):
        """
        Read document listbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_list_box_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ListBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_list_box_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_list_box_fields_with_http_info(name, **kwargs)
            return data

    def get_document_list_box_fields_with_http_info(self, name, **kwargs):
        """
        Read document listbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_list_box_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ListBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_list_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_list_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/listbox', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListBoxFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_movie_annotations(self, name, **kwargs):
        """
        Read document movie annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_movie_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: MovieAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_movie_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_movie_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_movie_annotations_with_http_info(self, name, **kwargs):
        """
        Read document movie annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_movie_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: MovieAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_movie_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_movie_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/movie', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='MovieAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_poly_line_annotations(self, name, **kwargs):
        """
        Read document polyline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_poly_line_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolyLineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_poly_line_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_poly_line_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_poly_line_annotations_with_http_info(self, name, **kwargs):
        """
        Read document polyline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_poly_line_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolyLineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_poly_line_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_poly_line_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/polyline', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PolyLineAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_polygon_annotations(self, name, **kwargs):
        """
        Read document polygon annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_polygon_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolygonAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_polygon_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_polygon_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_polygon_annotations_with_http_info(self, name, **kwargs):
        """
        Read document polygon annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_polygon_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolygonAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_polygon_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_polygon_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/polygon', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PolygonAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_popup_annotations(self, name, **kwargs):
        """
        Read document popup annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_popup_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_popup_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_popup_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_popup_annotations_with_http_info(self, name, **kwargs):
        """
        Read document popup annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_popup_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_popup_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_popup_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/popup', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PopupAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_popup_annotations_by_parent(self, name, annotation_id, **kwargs):
        """
        Read document popup annotations by parent id.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_popup_annotations_by_parent(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The parent annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_popup_annotations_by_parent_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_document_popup_annotations_by_parent_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_document_popup_annotations_by_parent_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document popup annotations by parent id.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_popup_annotations_by_parent_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The parent annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_popup_annotations_by_parent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_popup_annotations_by_parent`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_document_popup_annotations_by_parent`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/{annotationId}/popup', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PopupAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_properties(self, name, **kwargs):
        """
        Read document properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_properties(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: DocumentPropertiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_properties_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_properties_with_http_info(name, **kwargs)
            return data

    def get_document_properties_with_http_info(self, name, **kwargs):
        """
        Read document properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_properties_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: DocumentPropertiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_properties`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/documentproperties', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPropertiesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_property(self, name, property_name, **kwargs):
        """
        Read document property by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_property(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str property_name: Property name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: DocumentPropertyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_property_with_http_info(name, property_name, **kwargs)
        else:
            (data) = self.get_document_property_with_http_info(name, property_name, **kwargs)
            return data

    def get_document_property_with_http_info(self, name, property_name, **kwargs):
        """
        Read document property by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_property_with_http_info(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str property_name: Property name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: DocumentPropertyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'property_name', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_property`")
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params) or (params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `get_document_property`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'property_name' in params:
            path_params['propertyName'] = params['property_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/documentproperties/{propertyName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPropertyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_radio_button_fields(self, name, **kwargs):
        """
        Read document radiobutton fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_radio_button_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RadioButtonFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_radio_button_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_radio_button_fields_with_http_info(name, **kwargs)
            return data

    def get_document_radio_button_fields_with_http_info(self, name, **kwargs):
        """
        Read document radiobutton fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_radio_button_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RadioButtonFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_radio_button_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_radio_button_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/radiobutton', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RadioButtonFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_redaction_annotations(self, name, **kwargs):
        """
        Read document redaction annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_redaction_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RedactionAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_redaction_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_redaction_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_redaction_annotations_with_http_info(self, name, **kwargs):
        """
        Read document redaction annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_redaction_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RedactionAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_redaction_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_redaction_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/redaction', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RedactionAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_screen_annotations(self, name, **kwargs):
        """
        Read document screen annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_screen_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ScreenAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_screen_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_screen_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_screen_annotations_with_http_info(self, name, **kwargs):
        """
        Read document screen annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_screen_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ScreenAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_screen_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_screen_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/screen', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ScreenAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_signature_fields(self, name, **kwargs):
        """
        Read document signature fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_signature_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_signature_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_signature_fields_with_http_info(name, **kwargs)
            return data

    def get_document_signature_fields_with_http_info(self, name, **kwargs):
        """
        Read document signature fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_signature_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_signature_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_signature_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/signature', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SignatureFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_sound_annotations(self, name, **kwargs):
        """
        Read document sound annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_sound_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SoundAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_sound_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_sound_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_sound_annotations_with_http_info(self, name, **kwargs):
        """
        Read document sound annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_sound_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SoundAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_sound_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_sound_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/sound', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SoundAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_square_annotations(self, name, **kwargs):
        """
        Read document square annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_square_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquareAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_square_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_square_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_square_annotations_with_http_info(self, name, **kwargs):
        """
        Read document square annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_square_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquareAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_square_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_square_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/square', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SquareAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_squiggly_annotations(self, name, **kwargs):
        """
        Read document squiggly annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_squiggly_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquigglyAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_squiggly_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_squiggly_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_squiggly_annotations_with_http_info(self, name, **kwargs):
        """
        Read document squiggly annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_squiggly_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquigglyAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_squiggly_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_squiggly_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/squiggly', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SquigglyAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_stamp_annotations(self, name, **kwargs):
        """
        Read document stamp annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_stamp_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_stamp_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_stamp_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_stamp_annotations_with_http_info(self, name, **kwargs):
        """
        Read document stamp annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_stamp_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_stamp_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_stamp_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/stamp', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StampAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_stamps(self, name, **kwargs):
        """
        Read document stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_stamps(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampsInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_stamps_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_stamps_with_http_info(name, **kwargs)
            return data

    def get_document_stamps_with_http_info(self, name, **kwargs):
        """
        Read document stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_stamps_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampsInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_stamps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_stamps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/stamps', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StampsInfoResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_strike_out_annotations(self, name, **kwargs):
        """
        Read document StrikeOut annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_strike_out_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StrikeOutAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_strike_out_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_strike_out_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_strike_out_annotations_with_http_info(self, name, **kwargs):
        """
        Read document StrikeOut annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_strike_out_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StrikeOutAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_strike_out_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_strike_out_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/strikeout', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StrikeOutAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_tables(self, name, **kwargs):
        """
        Read document tables.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_tables(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str storage:
        :param str folder:
        :return: TablesRecognizedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_tables_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_tables_with_http_info(name, **kwargs)
            return data

    def get_document_tables_with_http_info(self, name, **kwargs):
        """
        Read document tables.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_tables_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str storage:
        :param str folder:
        :return: TablesRecognizedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_tables" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_tables`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/tables', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TablesRecognizedResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_text_annotations(self, name, **kwargs):
        """
        Read document text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_text_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_text_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_text_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_text_annotations_with_http_info(self, name, **kwargs):
        """
        Read document text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_text_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_text_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_text_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/text', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_text_box_fields(self, name, **kwargs):
        """
        Read document text box fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_text_box_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_text_box_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_text_box_fields_with_http_info(name, **kwargs)
            return data

    def get_document_text_box_fields_with_http_info(self, name, **kwargs):
        """
        Read document text box fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_text_box_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_text_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_text_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/textbox', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextBoxFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_underline_annotations(self, name, **kwargs):
        """
        Read document underline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_underline_annotations(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: UnderlineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_underline_annotations_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_underline_annotations_with_http_info(name, **kwargs)
            return data

    def get_document_underline_annotations_with_http_info(self, name, **kwargs):
        """
        Read document underline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_underline_annotations_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: UnderlineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_underline_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_underline_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/underline', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UnderlineAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_download_document_attachment_by_index(self, name, attachment_index, **kwargs):
        """
        Download document attachment content by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_download_document_attachment_by_index(name, attachment_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int attachment_index: The attachment index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_download_document_attachment_by_index_with_http_info(name, attachment_index, **kwargs)
        else:
            (data) = self.get_download_document_attachment_by_index_with_http_info(name, attachment_index, **kwargs)
            return data

    def get_download_document_attachment_by_index_with_http_info(self, name, attachment_index, **kwargs):
        """
        Download document attachment content by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_download_document_attachment_by_index_with_http_info(name, attachment_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int attachment_index: The attachment index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'attachment_index', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_download_document_attachment_by_index" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_download_document_attachment_by_index`")
        # verify the required parameter 'attachment_index' is set
        if ('attachment_index' not in params) or (params['attachment_index'] is None):
            raise ValueError("Missing the required parameter `attachment_index` when calling `get_download_document_attachment_by_index`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'attachment_index' in params:
            path_params['attachmentIndex'] = params['attachment_index']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/attachments/{attachmentIndex}/download', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_epub_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert EPUB file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_epub_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.epub) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_epub_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_epub_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_epub_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert EPUB file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_epub_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.epub) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_epub_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_epub_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/epub', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_export_fields_from_pdf_to_fdf_in_storage(self, name, **kwargs):
        """
        Export fields from from PDF in storage to FDF file.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_export_fields_from_pdf_to_fdf_in_storage(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_export_fields_from_pdf_to_fdf_in_storage_with_http_info(name, **kwargs)
        else:
            (data) = self.get_export_fields_from_pdf_to_fdf_in_storage_with_http_info(name, **kwargs)
            return data

    def get_export_fields_from_pdf_to_fdf_in_storage_with_http_info(self, name, **kwargs):
        """
        Export fields from from PDF in storage to FDF file.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_export_fields_from_pdf_to_fdf_in_storage_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_export_fields_from_pdf_to_fdf_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_export_fields_from_pdf_to_fdf_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/export/fdf', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_export_fields_from_pdf_to_xfdf_in_storage(self, name, **kwargs):
        """
        Export fields from from PDF in storage to XFDF file.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_export_fields_from_pdf_to_xfdf_in_storage(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_export_fields_from_pdf_to_xfdf_in_storage_with_http_info(name, **kwargs)
        else:
            (data) = self.get_export_fields_from_pdf_to_xfdf_in_storage_with_http_info(name, **kwargs)
            return data

    def get_export_fields_from_pdf_to_xfdf_in_storage_with_http_info(self, name, **kwargs):
        """
        Export fields from from PDF in storage to XFDF file.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_export_fields_from_pdf_to_xfdf_in_storage_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_export_fields_from_pdf_to_xfdf_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_export_fields_from_pdf_to_xfdf_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/export/xfdf', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_export_fields_from_pdf_to_xml_in_storage(self, name, **kwargs):
        """
        Export fields from from PDF in storage to XML file.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_export_fields_from_pdf_to_xml_in_storage(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_export_fields_from_pdf_to_xml_in_storage_with_http_info(name, **kwargs)
        else:
            (data) = self.get_export_fields_from_pdf_to_xml_in_storage_with_http_info(name, **kwargs)
            return data

    def get_export_fields_from_pdf_to_xml_in_storage_with_http_info(self, name, **kwargs):
        """
        Export fields from from PDF in storage to XML file.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_export_fields_from_pdf_to_xml_in_storage_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_export_fields_from_pdf_to_xml_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_export_fields_from_pdf_to_xml_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/export/xml', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_field(self, name, field_name, **kwargs):
        """
        Get document field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name (name should be encoded). (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.get_field_with_http_info(name, field_name, **kwargs)
            return data

    def get_field_with_http_info(self, name, field_name, **kwargs):
        """
        Get document field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name (name should be encoded). (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `get_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/{fieldName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_fields(self, name, **kwargs):
        """
        Get document fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.get_fields_with_http_info(name, **kwargs)
            return data

    def get_fields_with_http_info(self, name, **kwargs):
        """
        Get document fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_file_attachment_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page FileAttachment annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file_attachment_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FileAttachmentAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_file_attachment_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_file_attachment_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_file_attachment_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page FileAttachment annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file_attachment_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FileAttachmentAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_attachment_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_file_attachment_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_file_attachment_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/fileattachment/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FileAttachmentAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_file_attachment_annotation_data(self, name, annotation_id, **kwargs):
        """
        Read document page FileAttachment annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file_attachment_annotation_data(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_file_attachment_annotation_data_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_file_attachment_annotation_data_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_file_attachment_annotation_data_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page FileAttachment annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file_attachment_annotation_data_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_attachment_annotation_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_file_attachment_annotation_data`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_file_attachment_annotation_data`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/fileattachment/{annotationId}/data', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_file_versions(self, path, **kwargs):
        """
        Get file versions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file_versions(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: File path e.g. '/file.ext' (required)
        :param str storage_name: Storage name
        :return: FileVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_file_versions_with_http_info(path, **kwargs)
        else:
            (data) = self.get_file_versions_with_http_info(path, **kwargs)
            return data

    def get_file_versions_with_http_info(self, path, **kwargs):
        """
        Get file versions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file_versions_with_http_info(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: File path e.g. '/file.ext' (required)
        :param str storage_name: Storage name
        :return: FileVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_file_versions`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/version/{path}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FileVersions',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_files_list(self, path, **kwargs):
        """
        Get all files and folders within a folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_files_list(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :return: FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_files_list_with_http_info(path, **kwargs)
        else:
            (data) = self.get_files_list_with_http_info(path, **kwargs)
            return data

    def get_files_list_with_http_info(self, path, **kwargs):
        """
        Get all files and folders within a folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_files_list_with_http_info(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :return: FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_files_list`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/folder/{path}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FilesList',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_free_text_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page free text annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_free_text_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FreeTextAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_free_text_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_free_text_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_free_text_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page free text annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_free_text_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FreeTextAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_free_text_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_free_text_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_free_text_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/freetext/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FreeTextAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_highlight_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page highlight annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_highlight_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: HighlightAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_highlight_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_highlight_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_highlight_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page highlight annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_highlight_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: HighlightAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_highlight_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_highlight_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_highlight_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/highlight/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='HighlightAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_html_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert HTML file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_html_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.zip) (required)
        :param str html_file_name: Name of HTML file in ZIP.
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_html_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_html_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_html_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert HTML file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_html_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.zip) (required)
        :param str html_file_name: Name of HTML file in ZIP.
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'html_file_name', 'height', 'width', 'is_landscape', 'margin_left', 'margin_bottom', 'margin_right', 'margin_top', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_html_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_html_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'html_file_name' in params:
            query_params.append(('htmlFileName', params['html_file_name']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'is_landscape' in params:
            query_params.append(('isLandscape', params['is_landscape']))
        if 'margin_left' in params:
            query_params.append(('marginLeft', params['margin_left']))
        if 'margin_bottom' in params:
            query_params.append(('marginBottom', params['margin_bottom']))
        if 'margin_right' in params:
            query_params.append(('marginRight', params['margin_right']))
        if 'margin_top' in params:
            query_params.append(('marginTop', params['margin_top']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/html', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_image(self, name, image_id, **kwargs):
        """
        Read document image by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ImageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_image_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.get_image_with_http_info(name, image_id, **kwargs)
            return data

    def get_image_with_http_info(self, name, image_id, **kwargs):
        """
        Read document image by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ImageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_image`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImageResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_image_extract_as_gif(self, name, image_id, **kwargs):
        """
        Extract document image in GIF format
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_extract_as_gif(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_image_extract_as_gif_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.get_image_extract_as_gif_with_http_info(name, image_id, **kwargs)
            return data

    def get_image_extract_as_gif_with_http_info(self, name, image_id, **kwargs):
        """
        Extract document image in GIF format
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_extract_as_gif_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'width', 'height', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_extract_as_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_extract_as_gif`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_image_extract_as_gif`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}/extract/gif', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_image_extract_as_jpeg(self, name, image_id, **kwargs):
        """
        Extract document image in JPEG format
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_extract_as_jpeg(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_image_extract_as_jpeg_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.get_image_extract_as_jpeg_with_http_info(name, image_id, **kwargs)
            return data

    def get_image_extract_as_jpeg_with_http_info(self, name, image_id, **kwargs):
        """
        Extract document image in JPEG format
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_extract_as_jpeg_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'width', 'height', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_extract_as_jpeg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_extract_as_jpeg`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_image_extract_as_jpeg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}/extract/jpeg', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_image_extract_as_png(self, name, image_id, **kwargs):
        """
        Extract document image in PNG format
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_extract_as_png(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_image_extract_as_png_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.get_image_extract_as_png_with_http_info(name, image_id, **kwargs)
            return data

    def get_image_extract_as_png_with_http_info(self, name, image_id, **kwargs):
        """
        Extract document image in PNG format
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_extract_as_png_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'width', 'height', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_extract_as_png" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_extract_as_png`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_image_extract_as_png`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}/extract/png', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_image_extract_as_tiff(self, name, image_id, **kwargs):
        """
        Extract document image in TIFF format
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_extract_as_tiff(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_image_extract_as_tiff_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.get_image_extract_as_tiff_with_http_info(name, image_id, **kwargs)
            return data

    def get_image_extract_as_tiff_with_http_info(self, name, image_id, **kwargs):
        """
        Extract document image in TIFF format
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_extract_as_tiff_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'width', 'height', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_extract_as_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_extract_as_tiff`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_image_extract_as_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}/extract/tiff', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_images(self, name, page_number, **kwargs):
        """
        Read document images.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_images(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ImagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_images_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_images_with_http_info(name, page_number, **kwargs)
            return data

    def get_images_with_http_info(self, name, page_number, **kwargs):
        """
        Read document images.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_images_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ImagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_images`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_images`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImagesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_import_fields_from_fdf_in_storage(self, name, fdf_file_path, **kwargs):
        """
        Update fields from FDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_import_fields_from_fdf_in_storage(name, fdf_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str fdf_file_path: The Fdf file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_import_fields_from_fdf_in_storage_with_http_info(name, fdf_file_path, **kwargs)
        else:
            (data) = self.get_import_fields_from_fdf_in_storage_with_http_info(name, fdf_file_path, **kwargs)
            return data

    def get_import_fields_from_fdf_in_storage_with_http_info(self, name, fdf_file_path, **kwargs):
        """
        Update fields from FDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_import_fields_from_fdf_in_storage_with_http_info(name, fdf_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str fdf_file_path: The Fdf file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fdf_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_fields_from_fdf_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_import_fields_from_fdf_in_storage`")
        # verify the required parameter 'fdf_file_path' is set
        if ('fdf_file_path' not in params) or (params['fdf_file_path'] is None):
            raise ValueError("Missing the required parameter `fdf_file_path` when calling `get_import_fields_from_fdf_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'fdf_file_path' in params:
            query_params.append(('fdfFilePath', params['fdf_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/fdf', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_import_fields_from_xfdf_in_storage(self, name, xfdf_file_path, **kwargs):
        """
        Update fields from XFDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_import_fields_from_xfdf_in_storage(name, xfdf_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xfdf_file_path: The XFDF file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_import_fields_from_xfdf_in_storage_with_http_info(name, xfdf_file_path, **kwargs)
        else:
            (data) = self.get_import_fields_from_xfdf_in_storage_with_http_info(name, xfdf_file_path, **kwargs)
            return data

    def get_import_fields_from_xfdf_in_storage_with_http_info(self, name, xfdf_file_path, **kwargs):
        """
        Update fields from XFDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_import_fields_from_xfdf_in_storage_with_http_info(name, xfdf_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xfdf_file_path: The XFDF file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'xfdf_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_fields_from_xfdf_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_import_fields_from_xfdf_in_storage`")
        # verify the required parameter 'xfdf_file_path' is set
        if ('xfdf_file_path' not in params) or (params['xfdf_file_path'] is None):
            raise ValueError("Missing the required parameter `xfdf_file_path` when calling `get_import_fields_from_xfdf_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'xfdf_file_path' in params:
            query_params.append(('xfdfFilePath', params['xfdf_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/xfdf', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_import_fields_from_xml_in_storage(self, name, xml_file_path, **kwargs):
        """
        Import from XML file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_import_fields_from_xml_in_storage(name, xml_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xml_file_path: Full source filename (ex. /folder1/folder2/template.xml) (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_import_fields_from_xml_in_storage_with_http_info(name, xml_file_path, **kwargs)
        else:
            (data) = self.get_import_fields_from_xml_in_storage_with_http_info(name, xml_file_path, **kwargs)
            return data

    def get_import_fields_from_xml_in_storage_with_http_info(self, name, xml_file_path, **kwargs):
        """
        Import from XML file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_import_fields_from_xml_in_storage_with_http_info(name, xml_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xml_file_path: Full source filename (ex. /folder1/folder2/template.xml) (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'xml_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_fields_from_xml_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_import_fields_from_xml_in_storage`")
        # verify the required parameter 'xml_file_path' is set
        if ('xml_file_path' not in params) or (params['xml_file_path'] is None):
            raise ValueError("Missing the required parameter `xml_file_path` when calling `get_import_fields_from_xml_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'xml_file_path' in params:
            query_params.append(('xmlFilePath', params['xml_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/xml', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_ink_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page ink annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_ink_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: InkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_ink_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_ink_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_ink_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page ink annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_ink_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: InkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ink_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ink_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_ink_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/ink/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InkAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_line_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page line annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_line_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_line_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_line_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_line_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page line annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_line_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_line_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_line_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_line_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/line/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LineAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_link_annotation(self, name, link_id, **kwargs):
        """
        Read document link annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_link_annotation(name, link_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str link_id: The link ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_link_annotation_with_http_info(name, link_id, **kwargs)
        else:
            (data) = self.get_link_annotation_with_http_info(name, link_id, **kwargs)
            return data

    def get_link_annotation_with_http_info(self, name, link_id, **kwargs):
        """
        Read document link annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_link_annotation_with_http_info(name, link_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str link_id: The link ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'link_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_link_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_link_annotation`")
        # verify the required parameter 'link_id' is set
        if ('link_id' not in params) or (params['link_id'] is None):
            raise ValueError("Missing the required parameter `link_id` when calling `get_link_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'link_id' in params:
            path_params['linkId'] = params['link_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/links/{linkId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LinkAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_list_box_field(self, name, field_name, **kwargs):
        """
        Read document listbox field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_list_box_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ListBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_list_box_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.get_list_box_field_with_http_info(name, field_name, **kwargs)
            return data

    def get_list_box_field_with_http_info(self, name, field_name, **kwargs):
        """
        Read document listbox field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_list_box_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ListBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_box_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_list_box_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `get_list_box_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/listbox/{fieldName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListBoxFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_markdown_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert MD file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_markdown_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.md) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_markdown_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_markdown_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_markdown_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert MD file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_markdown_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.md) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_markdown_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_markdown_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/markdown', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_mht_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert MHT file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_mht_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.mht) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_mht_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_mht_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_mht_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert MHT file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_mht_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.mht) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mht_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_mht_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/mht', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_movie_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page movie annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_movie_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: MovieAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_movie_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_movie_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_movie_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page movie annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_movie_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: MovieAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_movie_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_movie_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_movie_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/movie/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='MovieAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page(self, name, page_number, **kwargs):
        """
        Read document page info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPageResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_annotations(self, name, page_number, **kwargs):
        """
        Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AnnotationsInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AnnotationsInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnnotationsInfoResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_caret_annotations(self, name, page_number, **kwargs):
        """
        Read document page caret annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_caret_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CaretAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_caret_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_caret_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_caret_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page caret annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_caret_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CaretAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_caret_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_caret_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_caret_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/caret', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CaretAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_check_box_fields(self, name, page_number, **kwargs):
        """
        Read document page checkbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_check_box_fields(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CheckBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_check_box_fields_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_check_box_fields_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_check_box_fields_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page checkbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_check_box_fields_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CheckBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_check_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_check_box_fields`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_check_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/page/{pageNumber}/fields/checkbox', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CheckBoxFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_circle_annotations(self, name, page_number, **kwargs):
        """
        Read document page circle annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_circle_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CircleAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_circle_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_circle_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_circle_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page circle annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_circle_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CircleAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_circle_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_circle_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_circle_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/circle', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CircleAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_combo_box_fields(self, name, page_number, **kwargs):
        """
        Read document page combobox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_combo_box_fields(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ComboBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_combo_box_fields_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_combo_box_fields_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_combo_box_fields_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page combobox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_combo_box_fields_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ComboBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_combo_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_combo_box_fields`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_combo_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/page/{pageNumber}/fields/combobox', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ComboBoxFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_convert_to_bmp(self, name, page_number, **kwargs):
        """
        Convert document page to Bmp image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_bmp(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_convert_to_bmp_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_convert_to_bmp_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_convert_to_bmp_with_http_info(self, name, page_number, **kwargs):
        """
        Convert document page to Bmp image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_bmp_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_convert_to_bmp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_convert_to_bmp`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_convert_to_bmp`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/bmp', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_convert_to_emf(self, name, page_number, **kwargs):
        """
        Convert document page to Emf image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_emf(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_convert_to_emf_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_convert_to_emf_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_convert_to_emf_with_http_info(self, name, page_number, **kwargs):
        """
        Convert document page to Emf image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_emf_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_convert_to_emf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_convert_to_emf`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_convert_to_emf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/emf', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_convert_to_gif(self, name, page_number, **kwargs):
        """
        Convert document page to Gif image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_gif(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_convert_to_gif_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_convert_to_gif_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_convert_to_gif_with_http_info(self, name, page_number, **kwargs):
        """
        Convert document page to Gif image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_gif_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_convert_to_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_convert_to_gif`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_convert_to_gif`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/gif', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_convert_to_jpeg(self, name, page_number, **kwargs):
        """
        Convert document page to Jpeg image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_jpeg(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_convert_to_jpeg_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_convert_to_jpeg_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_convert_to_jpeg_with_http_info(self, name, page_number, **kwargs):
        """
        Convert document page to Jpeg image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_jpeg_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_convert_to_jpeg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_convert_to_jpeg`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_convert_to_jpeg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/jpeg', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_convert_to_png(self, name, page_number, **kwargs):
        """
        Convert document page to Png image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_png(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_convert_to_png_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_convert_to_png_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_convert_to_png_with_http_info(self, name, page_number, **kwargs):
        """
        Convert document page to Png image and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_png_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_convert_to_png" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_convert_to_png`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_convert_to_png`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/png', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_convert_to_tiff(self, name, page_number, **kwargs):
        """
        Convert document page to Tiff image  and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_tiff(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_convert_to_tiff_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_convert_to_tiff_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_convert_to_tiff_with_http_info(self, name, page_number, **kwargs):
        """
        Convert document page to Tiff image  and return resulting file in response.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_convert_to_tiff_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_convert_to_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_convert_to_tiff`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_convert_to_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/tiff', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_file_attachment_annotations(self, name, page_number, **kwargs):
        """
        Read document page FileAttachment annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_file_attachment_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FileAttachmentAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_file_attachment_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_file_attachment_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_file_attachment_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page FileAttachment annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_file_attachment_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FileAttachmentAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_file_attachment_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_file_attachment_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_file_attachment_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/fileattachment', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FileAttachmentAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_free_text_annotations(self, name, page_number, **kwargs):
        """
        Read document page free text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_free_text_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FreeTextAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_free_text_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_free_text_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_free_text_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page free text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_free_text_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FreeTextAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_free_text_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_free_text_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_free_text_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/freetext', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FreeTextAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_highlight_annotations(self, name, page_number, **kwargs):
        """
        Read document page highlight annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_highlight_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: HighlightAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_highlight_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_highlight_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_highlight_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page highlight annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_highlight_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: HighlightAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_highlight_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_highlight_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_highlight_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/highlight', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='HighlightAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_ink_annotations(self, name, page_number, **kwargs):
        """
        Read document page ink annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_ink_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: InkAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_ink_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_ink_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_ink_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page ink annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_ink_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: InkAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_ink_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_ink_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_ink_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/ink', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InkAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_line_annotations(self, name, page_number, **kwargs):
        """
        Read document page line annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_line_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_line_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_line_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_line_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page line annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_line_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_line_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_line_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_line_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/line', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LineAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_link_annotation(self, name, page_number, link_id, **kwargs):
        """
        Read document page link annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_link_annotation(name, page_number, link_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str link_id: The link ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_link_annotation_with_http_info(name, page_number, link_id, **kwargs)
        else:
            (data) = self.get_page_link_annotation_with_http_info(name, page_number, link_id, **kwargs)
            return data

    def get_page_link_annotation_with_http_info(self, name, page_number, link_id, **kwargs):
        """
        Read document page link annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_link_annotation_with_http_info(name, page_number, link_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str link_id: The link ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'link_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_link_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_link_annotation`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_link_annotation`")
        # verify the required parameter 'link_id' is set
        if ('link_id' not in params) or (params['link_id'] is None):
            raise ValueError("Missing the required parameter `link_id` when calling `get_page_link_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'link_id' in params:
            path_params['linkId'] = params['link_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/links/{linkId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LinkAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_link_annotations(self, name, page_number, **kwargs):
        """
        Read document page link annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_link_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_link_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_link_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_link_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page link annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_link_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_link_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_link_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_link_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/links', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LinkAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_list_box_fields(self, name, page_number, **kwargs):
        """
        Read document page listbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_list_box_fields(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ListBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_list_box_fields_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_list_box_fields_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_list_box_fields_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page listbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_list_box_fields_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ListBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_list_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_list_box_fields`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_list_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/page/{pageNumber}/fields/listbox', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListBoxFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_movie_annotations(self, name, page_number, **kwargs):
        """
        Read document page movie annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_movie_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: MovieAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_movie_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_movie_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_movie_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page movie annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_movie_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: MovieAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_movie_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_movie_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_movie_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/movie', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='MovieAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_poly_line_annotations(self, name, page_number, **kwargs):
        """
        Read document page polyline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_poly_line_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolyLineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_poly_line_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_poly_line_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_poly_line_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page polyline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_poly_line_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolyLineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_poly_line_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_poly_line_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_poly_line_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/polyline', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PolyLineAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_polygon_annotations(self, name, page_number, **kwargs):
        """
        Read document page polygon annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_polygon_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolygonAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_polygon_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_polygon_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_polygon_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page polygon annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_polygon_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolygonAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_polygon_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_polygon_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_polygon_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/polygon', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PolygonAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_popup_annotations(self, name, page_number, **kwargs):
        """
        Read document page popup annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_popup_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_popup_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_popup_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_popup_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page popup annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_popup_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_popup_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_popup_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_popup_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/popup', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PopupAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_radio_button_fields(self, name, page_number, **kwargs):
        """
        Read document page radiobutton fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_radio_button_fields(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RadioButtonFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_radio_button_fields_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_radio_button_fields_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_radio_button_fields_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page radiobutton fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_radio_button_fields_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RadioButtonFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_radio_button_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_radio_button_fields`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_radio_button_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/page/{pageNumber}/fields/radiobutton', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RadioButtonFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_redaction_annotations(self, name, page_number, **kwargs):
        """
        Read document page redaction annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_redaction_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RedactionAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_redaction_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_redaction_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_redaction_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page redaction annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_redaction_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RedactionAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_redaction_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_redaction_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_redaction_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/redaction', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RedactionAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_screen_annotations(self, name, page_number, **kwargs):
        """
        Read document page screen annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_screen_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ScreenAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_screen_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_screen_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_screen_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page screen annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_screen_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ScreenAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_screen_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_screen_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_screen_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/screen', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ScreenAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_signature_fields(self, name, page_number, **kwargs):
        """
        Read document page signature fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_signature_fields(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_signature_fields_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_signature_fields_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_signature_fields_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page signature fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_signature_fields_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_signature_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_signature_fields`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_signature_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/page/{pageNumber}/fields/signature', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SignatureFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_sound_annotations(self, name, page_number, **kwargs):
        """
        Read document page sound annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_sound_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SoundAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_sound_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_sound_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_sound_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page sound annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_sound_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SoundAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_sound_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_sound_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_sound_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/sound', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SoundAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_square_annotations(self, name, page_number, **kwargs):
        """
        Read document page square annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_square_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquareAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_square_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_square_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_square_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page square annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_square_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquareAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_square_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_square_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_square_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/square', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SquareAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_squiggly_annotations(self, name, page_number, **kwargs):
        """
        Read document page squiggly annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_squiggly_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquigglyAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_squiggly_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_squiggly_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_squiggly_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page squiggly annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_squiggly_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquigglyAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_squiggly_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_squiggly_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_squiggly_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/squiggly', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SquigglyAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_stamp_annotations(self, name, page_number, **kwargs):
        """
        Read document page stamp annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_stamp_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_stamp_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_stamp_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_stamp_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page stamp annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_stamp_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_stamp_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_stamp_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_stamp_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/stamp', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StampAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_stamps(self, name, page_number, **kwargs):
        """
        Read page document stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_stamps(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: StampsInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_stamps_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_stamps_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_stamps_with_http_info(self, name, page_number, **kwargs):
        """
        Read page document stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_stamps_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: StampsInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_stamps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_stamps`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_stamps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/stamps', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StampsInfoResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_strike_out_annotations(self, name, page_number, **kwargs):
        """
        Read document page StrikeOut annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_strike_out_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StrikeOutAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_strike_out_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_strike_out_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_strike_out_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page StrikeOut annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_strike_out_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StrikeOutAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_strike_out_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_strike_out_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_strike_out_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/strikeout', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StrikeOutAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_tables(self, name, page_number, **kwargs):
        """
        Read document page tables.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_tables(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param str storage:
        :param str folder:
        :return: TablesRecognizedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_tables_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_tables_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_tables_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page tables.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_tables_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param str storage:
        :param str folder:
        :return: TablesRecognizedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_tables" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_tables`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_tables`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/tables', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TablesRecognizedResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_text(self, name, page_number, llx, lly, urx, ury, **kwargs):
        """
        Read page text items.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text(name, page_number, llx, lly, urx, ury, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: Number of page (starting from 1). (required)
        :param float llx: X-coordinate of lower - left corner. (required)
        :param float lly: Y - coordinate of lower-left corner. (required)
        :param float urx: X - coordinate of upper-right corner. (required)
        :param float ury: Y - coordinate of upper-right corner. (required)
        :param list[str] format: List of formats for search.
        :param str regex: Formats are specified as a regular expression.
        :param bool split_rects: Split result fragments (default is true).
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: TextRectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_text_with_http_info(name, page_number, llx, lly, urx, ury, **kwargs)
        else:
            (data) = self.get_page_text_with_http_info(name, page_number, llx, lly, urx, ury, **kwargs)
            return data

    def get_page_text_with_http_info(self, name, page_number, llx, lly, urx, ury, **kwargs):
        """
        Read page text items.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text_with_http_info(name, page_number, llx, lly, urx, ury, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: Number of page (starting from 1). (required)
        :param float llx: X-coordinate of lower - left corner. (required)
        :param float lly: Y - coordinate of lower-left corner. (required)
        :param float urx: X - coordinate of upper-right corner. (required)
        :param float ury: Y - coordinate of upper-right corner. (required)
        :param list[str] format: List of formats for search.
        :param str regex: Formats are specified as a regular expression.
        :param bool split_rects: Split result fragments (default is true).
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: TextRectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'llx', 'lly', 'urx', 'ury', 'format', 'regex', 'split_rects', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_text`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_text`")
        # verify the required parameter 'llx' is set
        if ('llx' not in params) or (params['llx'] is None):
            raise ValueError("Missing the required parameter `llx` when calling `get_page_text`")
        # verify the required parameter 'lly' is set
        if ('lly' not in params) or (params['lly'] is None):
            raise ValueError("Missing the required parameter `lly` when calling `get_page_text`")
        # verify the required parameter 'urx' is set
        if ('urx' not in params) or (params['urx'] is None):
            raise ValueError("Missing the required parameter `urx` when calling `get_page_text`")
        # verify the required parameter 'ury' is set
        if ('ury' not in params) or (params['ury'] is None):
            raise ValueError("Missing the required parameter `ury` when calling `get_page_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
            collection_formats['format'] = 'csv'
        if 'regex' in params:
            query_params.append(('regex', params['regex']))
        if 'split_rects' in params:
            query_params.append(('splitRects', params['split_rects']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'llx' in params:
            query_params.append(('LLX', params['llx']))
        if 'lly' in params:
            query_params.append(('LLY', params['lly']))
        if 'urx' in params:
            query_params.append(('URX', params['urx']))
        if 'ury' in params:
            query_params.append(('URY', params['ury']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/text', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextRectsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_text_annotations(self, name, page_number, **kwargs):
        """
        Read document page text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_text_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_text_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_text_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_text_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_text_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_text_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/text', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_text_box_fields(self, name, page_number, **kwargs):
        """
        Read document page text box fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text_box_fields(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_text_box_fields_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_text_box_fields_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_text_box_fields_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page text box fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text_box_fields_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextBoxFieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_text_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_text_box_fields`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_text_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/page/{pageNumber}/fields/textbox', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextBoxFieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_underline_annotations(self, name, page_number, **kwargs):
        """
        Read document page underline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_underline_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: UnderlineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_underline_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_underline_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_underline_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page underline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_underline_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: UnderlineAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_underline_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_underline_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_underline_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/underline', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UnderlineAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pages(self, name, **kwargs):
        """
        Read document pages info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pages(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pages_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pages_with_http_info(name, **kwargs)
            return data

    def get_pages_with_http_info(self, name, **kwargs):
        """
        Read document pages info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pages_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pages`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPagesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pcl_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert PCL file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pcl_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.pcl) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pcl_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_pcl_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_pcl_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert PCL file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pcl_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.pcl) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pcl_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_pcl_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/pcl', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_a_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert PDFA file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_a_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.pdf) (required)
        :param bool dont_optimize: If set, document resources will not be optimized.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_a_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_pdf_a_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_pdf_a_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert PDFA file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_a_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.pdf) (required)
        :param bool dont_optimize: If set, document resources will not be optimized.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dont_optimize', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_a_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_pdf_a_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'dont_optimize' in params:
            query_params.append(('dontOptimize', params['dont_optimize']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/pdfa', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_doc(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to DOC format and returns resulting file in response content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_doc(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param float max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_doc_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_doc_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_doc_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to DOC format and returns resulting file in response content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_doc_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param float max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'add_return_to_line_end', 'format', 'image_resolution_x', 'image_resolution_y', 'max_distance_between_text_lines', 'mode', 'recognize_bullets', 'relative_horizontal_proximity', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_doc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_doc`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'add_return_to_line_end' in params:
            query_params.append(('addReturnToLineEnd', params['add_return_to_line_end']))
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'image_resolution_x' in params:
            query_params.append(('imageResolutionX', params['image_resolution_x']))
        if 'image_resolution_y' in params:
            query_params.append(('imageResolutionY', params['image_resolution_y']))
        if 'max_distance_between_text_lines' in params:
            query_params.append(('maxDistanceBetweenTextLines', params['max_distance_between_text_lines']))
        if 'mode' in params:
            query_params.append(('mode', params['mode']))
        if 'recognize_bullets' in params:
            query_params.append(('recognizeBullets', params['recognize_bullets']))
        if 'relative_horizontal_proximity' in params:
            query_params.append(('relativeHorizontalProximity', params['relative_horizontal_proximity']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/doc', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_epub(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_epub(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str content_recognition_mode: Property tunes conversion for this or that desirable method of recognition of content.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_epub_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_epub_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_epub_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_epub_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str content_recognition_mode: Property tunes conversion for this or that desirable method of recognition of content.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'content_recognition_mode', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_epub" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_epub`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'content_recognition_mode' in params:
            query_params.append(('contentRecognitionMode', params['content_recognition_mode']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/epub', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_html(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to Html format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_html(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param str document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param bool flow_layout_paragraph_full_width: This attribute specifies full width paragraph text for Flow mode, FixedLayout = false.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_html_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_html_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_html_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to Html format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_html_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param str document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param bool flow_layout_paragraph_full_width: This attribute specifies full width paragraph text for Flow mode, FixedLayout = false.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'additional_margin_width_in_points', 'compress_svg_graphics_if_any', 'convert_marked_content_to_layers', 'default_font_name', 'document_type', 'fixed_layout', 'image_resolution', 'minimal_line_width', 'prevent_glyphs_grouping', 'split_css_into_pages', 'split_into_pages', 'use_z_order', 'antialiasing_processing', 'css_class_names_prefix', 'explicit_list_of_saved_pages', 'font_encoding_strategy', 'font_saving_mode', 'html_markup_generation_mode', 'letters_positioning_method', 'pages_flow_type_depends_on_viewers_screen_size', 'parts_embedding_mode', 'raster_images_saving_mode', 'remove_empty_areas_on_top_and_bottom', 'save_shadowed_texts_as_transparent_texts', 'save_transparent_texts', 'special_folder_for_all_images', 'special_folder_for_svg_images', 'try_save_text_underlining_and_strikeouting_in_css', 'folder', 'storage', 'flow_layout_paragraph_full_width']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_html" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_html`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'additional_margin_width_in_points' in params:
            query_params.append(('additionalMarginWidthInPoints', params['additional_margin_width_in_points']))
        if 'compress_svg_graphics_if_any' in params:
            query_params.append(('compressSvgGraphicsIfAny', params['compress_svg_graphics_if_any']))
        if 'convert_marked_content_to_layers' in params:
            query_params.append(('convertMarkedContentToLayers', params['convert_marked_content_to_layers']))
        if 'default_font_name' in params:
            query_params.append(('defaultFontName', params['default_font_name']))
        if 'document_type' in params:
            query_params.append(('documentType', params['document_type']))
        if 'fixed_layout' in params:
            query_params.append(('fixedLayout', params['fixed_layout']))
        if 'image_resolution' in params:
            query_params.append(('imageResolution', params['image_resolution']))
        if 'minimal_line_width' in params:
            query_params.append(('minimalLineWidth', params['minimal_line_width']))
        if 'prevent_glyphs_grouping' in params:
            query_params.append(('preventGlyphsGrouping', params['prevent_glyphs_grouping']))
        if 'split_css_into_pages' in params:
            query_params.append(('splitCssIntoPages', params['split_css_into_pages']))
        if 'split_into_pages' in params:
            query_params.append(('splitIntoPages', params['split_into_pages']))
        if 'use_z_order' in params:
            query_params.append(('useZOrder', params['use_z_order']))
        if 'antialiasing_processing' in params:
            query_params.append(('antialiasingProcessing', params['antialiasing_processing']))
        if 'css_class_names_prefix' in params:
            query_params.append(('cssClassNamesPrefix', params['css_class_names_prefix']))
        if 'explicit_list_of_saved_pages' in params:
            query_params.append(('explicitListOfSavedPages', params['explicit_list_of_saved_pages']))
            collection_formats['explicitListOfSavedPages'] = 'csv'
        if 'font_encoding_strategy' in params:
            query_params.append(('fontEncodingStrategy', params['font_encoding_strategy']))
        if 'font_saving_mode' in params:
            query_params.append(('fontSavingMode', params['font_saving_mode']))
        if 'html_markup_generation_mode' in params:
            query_params.append(('htmlMarkupGenerationMode', params['html_markup_generation_mode']))
        if 'letters_positioning_method' in params:
            query_params.append(('lettersPositioningMethod', params['letters_positioning_method']))
        if 'pages_flow_type_depends_on_viewers_screen_size' in params:
            query_params.append(('pagesFlowTypeDependsOnViewersScreenSize', params['pages_flow_type_depends_on_viewers_screen_size']))
        if 'parts_embedding_mode' in params:
            query_params.append(('partsEmbeddingMode', params['parts_embedding_mode']))
        if 'raster_images_saving_mode' in params:
            query_params.append(('rasterImagesSavingMode', params['raster_images_saving_mode']))
        if 'remove_empty_areas_on_top_and_bottom' in params:
            query_params.append(('removeEmptyAreasOnTopAndBottom', params['remove_empty_areas_on_top_and_bottom']))
        if 'save_shadowed_texts_as_transparent_texts' in params:
            query_params.append(('saveShadowedTextsAsTransparentTexts', params['save_shadowed_texts_as_transparent_texts']))
        if 'save_transparent_texts' in params:
            query_params.append(('saveTransparentTexts', params['save_transparent_texts']))
        if 'special_folder_for_all_images' in params:
            query_params.append(('specialFolderForAllImages', params['special_folder_for_all_images']))
        if 'special_folder_for_svg_images' in params:
            query_params.append(('specialFolderForSvgImages', params['special_folder_for_svg_images']))
        if 'try_save_text_underlining_and_strikeouting_in_css' in params:
            query_params.append(('trySaveTextUnderliningAndStrikeoutingInCss', params['try_save_text_underlining_and_strikeouting_in_css']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'flow_layout_paragraph_full_width' in params:
            query_params.append(('flowLayoutParagraphFullWidth', params['flow_layout_paragraph_full_width']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/html', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_mobi_xml(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to MOBIXML format and returns resulting ZIP archive file in response content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_mobi_xml(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_mobi_xml_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_mobi_xml_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_mobi_xml_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to MOBIXML format and returns resulting ZIP archive file in response content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_mobi_xml_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_mobi_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_mobi_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/mobixml', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_pdf_a(self, name, type, **kwargs):
        """
        Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_pdf_a(name, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str type: Type of PdfA format. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_pdf_a_with_http_info(name, type, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_pdf_a_with_http_info(name, type, **kwargs)
            return data

    def get_pdf_in_storage_to_pdf_a_with_http_info(self, name, type, **kwargs):
        """
        Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_pdf_a_with_http_info(name, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str type: Type of PdfA format. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_pdf_a" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_pdf_a`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_pdf_in_storage_to_pdf_a`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/pdfa', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_pptx(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_pptx(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: Base64 encoded password.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_pptx_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_pptx_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_pptx_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_pptx_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: Base64 encoded password.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'separate_images', 'slides_as_images', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_pptx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_pptx`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'separate_images' in params:
            query_params.append(('separateImages', params['separate_images']))
        if 'slides_as_images' in params:
            query_params.append(('slidesAsImages', params['slides_as_images']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/pptx', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_svg(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to SVG format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_svg(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool compress_output_to_zip_archive: Specifies whether output will be created as one zip-archive.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_svg_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_svg_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_svg_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to SVG format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_svg_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool compress_output_to_zip_archive: Specifies whether output will be created as one zip-archive.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'compress_output_to_zip_archive', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_svg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_svg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'compress_output_to_zip_archive' in params:
            query_params.append(('compressOutputToZipArchive', params['compress_output_to_zip_archive']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/svg', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_te_x(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to TeX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_te_x(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_te_x_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_te_x_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_te_x_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to TeX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_te_x_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_te_x" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_te_x`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/tex', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_text(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to Text format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_text(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_text_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_text_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_text_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to Text format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_text_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/text', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_tiff(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_tiff(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_tiff_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_tiff_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_tiff_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_tiff_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'brightness', 'compression', 'color_depth', 'left_margin', 'right_margin', 'top_margin', 'bottom_margin', 'orientation', 'skip_blank_pages', 'width', 'height', 'x_resolution', 'y_resolution', 'page_index', 'page_count', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'brightness' in params:
            query_params.append(('brightness', params['brightness']))
        if 'compression' in params:
            query_params.append(('compression', params['compression']))
        if 'color_depth' in params:
            query_params.append(('colorDepth', params['color_depth']))
        if 'left_margin' in params:
            query_params.append(('leftMargin', params['left_margin']))
        if 'right_margin' in params:
            query_params.append(('rightMargin', params['right_margin']))
        if 'top_margin' in params:
            query_params.append(('topMargin', params['top_margin']))
        if 'bottom_margin' in params:
            query_params.append(('bottomMargin', params['bottom_margin']))
        if 'orientation' in params:
            query_params.append(('orientation', params['orientation']))
        if 'skip_blank_pages' in params:
            query_params.append(('skipBlankPages', params['skip_blank_pages']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'x_resolution' in params:
            query_params.append(('xResolution', params['x_resolution']))
        if 'y_resolution' in params:
            query_params.append(('yResolution', params['y_resolution']))
        if 'page_index' in params:
            query_params.append(('pageIndex', params['page_index']))
        if 'page_count' in params:
            query_params.append(('pageCount', params['page_count']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/tiff', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_xls(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XLS format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xls(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_xls_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_xls_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_xls_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XLS format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xls_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_xls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_xls`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xls', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_xlsx(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XLSX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xlsx(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_xlsx_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_xlsx_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_xlsx_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XLSX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xlsx_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_xlsx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_xlsx`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xlsx', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_xml(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XML format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xml(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_xml_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_xml_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_xml_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XML format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xml_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xml', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_xps(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XPS format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xps(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_xps_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_xps_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_xps_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XPS format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xps_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_xps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_xps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xps', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_poly_line_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page polyline annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_poly_line_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolyLineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_poly_line_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_poly_line_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_poly_line_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page polyline annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_poly_line_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolyLineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_poly_line_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_poly_line_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_poly_line_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/polyline/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PolyLineAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_polygon_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page polygon annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_polygon_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolygonAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_polygon_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_polygon_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_polygon_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page polygon annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_polygon_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolygonAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_polygon_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_polygon_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_polygon_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/polygon/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PolygonAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_popup_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page popup annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_popup_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_popup_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_popup_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_popup_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page popup annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_popup_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_popup_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_popup_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_popup_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/popup/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PopupAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_ps_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert PS file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_ps_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.ps) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_ps_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_ps_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_ps_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert PS file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_ps_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.ps) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ps_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_ps_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/ps', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_radio_button_field(self, name, field_name, **kwargs):
        """
        Read document RadioButton field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_radio_button_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RadioButtonFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_radio_button_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.get_radio_button_field_with_http_info(name, field_name, **kwargs)
            return data

    def get_radio_button_field_with_http_info(self, name, field_name, **kwargs):
        """
        Read document RadioButton field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_radio_button_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RadioButtonFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_radio_button_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_radio_button_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `get_radio_button_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/radiobutton/{fieldName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RadioButtonFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_redaction_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page redaction annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_redaction_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RedactionAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_redaction_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_redaction_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_redaction_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page redaction annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_redaction_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RedactionAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_redaction_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_redaction_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_redaction_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/redaction/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RedactionAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_screen_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page screen annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_screen_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ScreenAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_screen_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_screen_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_screen_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page screen annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_screen_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ScreenAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_screen_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_screen_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_screen_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/screen/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ScreenAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_screen_annotation_data(self, name, annotation_id, **kwargs):
        """
        Read document page screen annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_screen_annotation_data(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_screen_annotation_data_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_screen_annotation_data_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_screen_annotation_data_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page screen annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_screen_annotation_data_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_screen_annotation_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_screen_annotation_data`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_screen_annotation_data`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/screen/{annotationId}/data', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_signature_field(self, name, field_name, **kwargs):
        """
        Read document signature field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_signature_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_signature_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.get_signature_field_with_http_info(name, field_name, **kwargs)
            return data

    def get_signature_field_with_http_info(self, name, field_name, **kwargs):
        """
        Read document signature field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_signature_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_signature_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_signature_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `get_signature_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/signature/{fieldName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SignatureFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_sound_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page sound annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_sound_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SoundAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_sound_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_sound_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_sound_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page sound annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_sound_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SoundAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sound_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_sound_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_sound_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/sound/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SoundAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_sound_annotation_data(self, name, annotation_id, **kwargs):
        """
        Read document page sound annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_sound_annotation_data(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_sound_annotation_data_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_sound_annotation_data_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_sound_annotation_data_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page sound annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_sound_annotation_data_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sound_annotation_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_sound_annotation_data`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_sound_annotation_data`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/sound/{annotationId}/data', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_square_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page square annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_square_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquareAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_square_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_square_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_square_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page square annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_square_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquareAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_square_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_square_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_square_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/square/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SquareAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_squiggly_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page squiggly annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_squiggly_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquigglyAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_squiggly_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_squiggly_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_squiggly_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page squiggly annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_squiggly_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquigglyAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_squiggly_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_squiggly_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_squiggly_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/squiggly/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SquigglyAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_stamp_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page stamp annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_stamp_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_stamp_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_stamp_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_stamp_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page stamp annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_stamp_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stamp_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_stamp_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_stamp_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/stamp/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StampAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_stamp_annotation_data(self, name, annotation_id, **kwargs):
        """
        Read document page stamp annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_stamp_annotation_data(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_stamp_annotation_data_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_stamp_annotation_data_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_stamp_annotation_data_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page stamp annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_stamp_annotation_data_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stamp_annotation_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_stamp_annotation_data`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_stamp_annotation_data`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/stamp/{annotationId}/data', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_strike_out_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page StrikeOut annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_strike_out_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StrikeOutAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_strike_out_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_strike_out_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_strike_out_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page StrikeOut annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_strike_out_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StrikeOutAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_strike_out_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_strike_out_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_strike_out_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/strikeout/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StrikeOutAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_svg_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert SVG file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_svg_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.svg) (required)
        :param bool adjust_page_size: Adjust page size
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_svg_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_svg_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_svg_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert SVG file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_svg_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.svg) (required)
        :param bool adjust_page_size: Adjust page size
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'adjust_page_size', 'height', 'width', 'is_landscape', 'margin_left', 'margin_bottom', 'margin_right', 'margin_top', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_svg_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_svg_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'adjust_page_size' in params:
            query_params.append(('adjustPageSize', params['adjust_page_size']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'is_landscape' in params:
            query_params.append(('isLandscape', params['is_landscape']))
        if 'margin_left' in params:
            query_params.append(('marginLeft', params['margin_left']))
        if 'margin_bottom' in params:
            query_params.append(('marginBottom', params['margin_bottom']))
        if 'margin_right' in params:
            query_params.append(('marginRight', params['margin_right']))
        if 'margin_top' in params:
            query_params.append(('marginTop', params['margin_top']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/svg', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_table(self, name, table_id, **kwargs):
        """
        Read document page table by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_table(name, table_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str table_id: The table ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TableRecognizedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_table_with_http_info(name, table_id, **kwargs)
        else:
            (data) = self.get_table_with_http_info(name, table_id, **kwargs)
            return data

    def get_table_with_http_info(self, name, table_id, **kwargs):
        """
        Read document page table by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_table_with_http_info(name, table_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str table_id: The table ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TableRecognizedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'table_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_table`")
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `get_table`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/tables/{tableId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TableRecognizedResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_te_x_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert TeX file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_te_x_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.tex) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_te_x_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_te_x_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_te_x_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert TeX file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_te_x_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.tex) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_te_x_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_te_x_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/tex', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_text(self, name, llx, lly, urx, ury, **kwargs):
        """
        Read document text.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text(name, llx, lly, urx, ury, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param float llx: X-coordinate of lower - left corner. (required)
        :param float lly: Y - coordinate of lower-left corner. (required)
        :param float urx: X - coordinate of upper-right corner. (required)
        :param float ury: Y - coordinate of upper-right corner. (required)
        :param list[str] format: List of formats for search.
        :param str regex: Formats are specified as a regular expression.
        :param bool split_rects: Split result fragments (default is true).
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: TextRectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_text_with_http_info(name, llx, lly, urx, ury, **kwargs)
        else:
            (data) = self.get_text_with_http_info(name, llx, lly, urx, ury, **kwargs)
            return data

    def get_text_with_http_info(self, name, llx, lly, urx, ury, **kwargs):
        """
        Read document text.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text_with_http_info(name, llx, lly, urx, ury, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param float llx: X-coordinate of lower - left corner. (required)
        :param float lly: Y - coordinate of lower-left corner. (required)
        :param float urx: X - coordinate of upper-right corner. (required)
        :param float ury: Y - coordinate of upper-right corner. (required)
        :param list[str] format: List of formats for search.
        :param str regex: Formats are specified as a regular expression.
        :param bool split_rects: Split result fragments (default is true).
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: TextRectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'llx', 'lly', 'urx', 'ury', 'format', 'regex', 'split_rects', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_text`")
        # verify the required parameter 'llx' is set
        if ('llx' not in params) or (params['llx'] is None):
            raise ValueError("Missing the required parameter `llx` when calling `get_text`")
        # verify the required parameter 'lly' is set
        if ('lly' not in params) or (params['lly'] is None):
            raise ValueError("Missing the required parameter `lly` when calling `get_text`")
        # verify the required parameter 'urx' is set
        if ('urx' not in params) or (params['urx'] is None):
            raise ValueError("Missing the required parameter `urx` when calling `get_text`")
        # verify the required parameter 'ury' is set
        if ('ury' not in params) or (params['ury'] is None):
            raise ValueError("Missing the required parameter `ury` when calling `get_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
            collection_formats['format'] = 'csv'
        if 'regex' in params:
            query_params.append(('regex', params['regex']))
        if 'split_rects' in params:
            query_params.append(('splitRects', params['split_rects']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'llx' in params:
            query_params.append(('LLX', params['llx']))
        if 'lly' in params:
            query_params.append(('LLY', params['lly']))
        if 'urx' in params:
            query_params.append(('URX', params['urx']))
        if 'ury' in params:
            query_params.append(('URY', params['ury']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/text', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextRectsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_text_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page text annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_text_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_text_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_text_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page text annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_text_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_text_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_text_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/text/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_text_box_field(self, name, field_name, **kwargs):
        """
        Read document text box field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text_box_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_text_box_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.get_text_box_field_with_http_info(name, field_name, **kwargs)
            return data

    def get_text_box_field_with_http_info(self, name, field_name, **kwargs):
        """
        Read document text box field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text_box_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_text_box_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_text_box_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `get_text_box_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/textbox/{fieldName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextBoxFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_underline_annotation(self, name, annotation_id, **kwargs):
        """
        Read document page underline annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_underline_annotation(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: UnderlineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_underline_annotation_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.get_underline_annotation_with_http_info(name, annotation_id, **kwargs)
            return data

    def get_underline_annotation_with_http_info(self, name, annotation_id, **kwargs):
        """
        Read document page underline annotation by ID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_underline_annotation_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: UnderlineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_underline_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_underline_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_underline_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/underline/{annotationId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UnderlineAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_verify_signature(self, name, sign_name, **kwargs):
        """
        Verify signature document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_verify_signature(name, sign_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str sign_name: Sign name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureVerifyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_verify_signature_with_http_info(name, sign_name, **kwargs)
        else:
            (data) = self.get_verify_signature_with_http_info(name, sign_name, **kwargs)
            return data

    def get_verify_signature_with_http_info(self, name, sign_name, **kwargs):
        """
        Verify signature document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_verify_signature_with_http_info(name, sign_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str sign_name: Sign name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureVerifyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'sign_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_verify_signature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_verify_signature`")
        # verify the required parameter 'sign_name' is set
        if ('sign_name' not in params) or (params['sign_name'] is None):
            raise ValueError("Missing the required parameter `sign_name` when calling `get_verify_signature`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'sign_name' in params:
            query_params.append(('signName', params['sign_name']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/verifySignature', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SignatureVerifyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_web_in_storage_to_pdf(self, url, **kwargs):
        """
        Convert web page to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_web_in_storage_to_pdf(url, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str url: Source url (required)
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_web_in_storage_to_pdf_with_http_info(url, **kwargs)
        else:
            (data) = self.get_web_in_storage_to_pdf_with_http_info(url, **kwargs)
            return data

    def get_web_in_storage_to_pdf_with_http_info(self, url, **kwargs):
        """
        Convert web page to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_web_in_storage_to_pdf_with_http_info(url, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str url: Source url (required)
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['url', 'height', 'width', 'is_landscape', 'margin_left', 'margin_bottom', 'margin_right', 'margin_top', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_web_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'url' is set
        if ('url' not in params) or (params['url'] is None):
            raise ValueError("Missing the required parameter `url` when calling `get_web_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'url' in params:
            query_params.append(('url', params['url']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'is_landscape' in params:
            query_params.append(('isLandscape', params['is_landscape']))
        if 'margin_left' in params:
            query_params.append(('marginLeft', params['margin_left']))
        if 'margin_bottom' in params:
            query_params.append(('marginBottom', params['margin_bottom']))
        if 'margin_right' in params:
            query_params.append(('marginRight', params['margin_right']))
        if 'margin_top' in params:
            query_params.append(('marginTop', params['margin_top']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/web', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_words_per_page(self, name, **kwargs):
        """
        Get number of words per document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_words_per_page(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: WordCountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_words_per_page_with_http_info(name, **kwargs)
        else:
            (data) = self.get_words_per_page_with_http_info(name, **kwargs)
            return data

    def get_words_per_page_with_http_info(self, name, **kwargs):
        """
        Get number of words per document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_words_per_page_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: WordCountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_words_per_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_words_per_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/wordCount', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='WordCountResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_xfa_pdf_in_storage_to_acro_form(self, name, **kwargs):
        """
        Converts PDF document which contains XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xfa_pdf_in_storage_to_acro_form(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_xfa_pdf_in_storage_to_acro_form_with_http_info(name, **kwargs)
        else:
            (data) = self.get_xfa_pdf_in_storage_to_acro_form_with_http_info(name, **kwargs)
            return data

    def get_xfa_pdf_in_storage_to_acro_form_with_http_info(self, name, **kwargs):
        """
        Converts PDF document which contains XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xfa_pdf_in_storage_to_acro_form_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_xfa_pdf_in_storage_to_acro_form" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_xfa_pdf_in_storage_to_acro_form`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xfatoacroform', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_xml_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert XML file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xml_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xml) (required)
        :param str xsl_file_path: Full XSL source filename (ex. /folder1/folder2/template.xsl)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_xml_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_xml_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_xml_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert XML file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xml_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xml) (required)
        :param str xsl_file_path: Full XSL source filename (ex. /folder1/folder2/template.xsl)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'xsl_file_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_xml_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_xml_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'xsl_file_path' in params:
            query_params.append(('xslFilePath', params['xsl_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/xml', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_xps_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert XPS file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xps_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xps) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_xps_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_xps_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_xps_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert XPS file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xps_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xps) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_xps_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_xps_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/xps', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_xsl_fo_in_storage_to_pdf(self, src_path, **kwargs):
        """
        Convert XslFo file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xsl_fo_in_storage_to_pdf(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xslfo) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_xsl_fo_in_storage_to_pdf_with_http_info(src_path, **kwargs)
        else:
            (data) = self.get_xsl_fo_in_storage_to_pdf_with_http_info(src_path, **kwargs)
            return data

    def get_xsl_fo_in_storage_to_pdf_with_http_info(self, src_path, **kwargs):
        """
        Convert XslFo file (located on storage) to PDF format and return resulting file in response. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xsl_fo_in_storage_to_pdf_with_http_info(src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xslfo) (required)
        :param str storage: The document storage.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_xsl_fo_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `get_xsl_fo_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/create/xslfo', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def move_file(self, src_path, dest_path, **kwargs):
        """
        Move file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_file(src_path, dest_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Source file path e.g. '/src.ext' (required)
        :param str dest_path: Destination file path e.g. '/dest.ext' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to move
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.move_file_with_http_info(src_path, dest_path, **kwargs)
        else:
            (data) = self.move_file_with_http_info(src_path, dest_path, **kwargs)
            return data

    def move_file_with_http_info(self, src_path, dest_path, **kwargs):
        """
        Move file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_file_with_http_info(src_path, dest_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Source file path e.g. '/src.ext' (required)
        :param str dest_path: Destination file path e.g. '/dest.ext' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to move
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name', 'version_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `move_file`")
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params) or (params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `move_file`")


        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/file/move/{srcPath}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def move_folder(self, src_path, dest_path, **kwargs):
        """
        Move folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_folder(src_path, dest_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Folder path to move e.g. '/folder' (required)
        :param str dest_path: Destination folder path to move to e.g '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.move_folder_with_http_info(src_path, dest_path, **kwargs)
        else:
            (data) = self.move_folder_with_http_info(src_path, dest_path, **kwargs)
            return data

    def move_folder_with_http_info(self, src_path, dest_path, **kwargs):
        """
        Move folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_folder_with_http_info(src_path, dest_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str src_path: Folder path to move e.g. '/folder' (required)
        :param str dest_path: Destination folder path to move to e.g '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `move_folder`")
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params) or (params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `move_folder`")


        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/folder/move/{srcPath}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def object_exists(self, path, **kwargs):
        """
        Check if file or folder exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.object_exists(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: File or folder path e.g. '/file.ext' or '/folder' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID
        :return: ObjectExist
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.object_exists_with_http_info(path, **kwargs)
        else:
            (data) = self.object_exists_with_http_info(path, **kwargs)
            return data

    def object_exists_with_http_info(self, path, **kwargs):
        """
        Check if file or folder exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.object_exists_with_http_info(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: File or folder path e.g. '/file.ext' or '/folder' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID
        :return: ObjectExist
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method object_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `object_exists`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/exist/{path}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ObjectExist',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_add_document_attachment(self, name, attachment_info, **kwargs):
        """
        Adds a file attachment to the PDF document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_add_document_attachment(name, attachment_info, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param AttachmentInfo attachment_info: AttachmentInfoAttachmentInfo instance. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_add_document_attachment_with_http_info(name, attachment_info, **kwargs)
        else:
            (data) = self.post_add_document_attachment_with_http_info(name, attachment_info, **kwargs)
            return data

    def post_add_document_attachment_with_http_info(self, name, attachment_info, **kwargs):
        """
        Adds a file attachment to the PDF document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_add_document_attachment_with_http_info(name, attachment_info, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param AttachmentInfo attachment_info: AttachmentInfoAttachmentInfo instance. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'attachment_info', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_add_document_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_add_document_attachment`")
        # verify the required parameter 'attachment_info' is set
        if ('attachment_info' not in params) or (params['attachment_info'] is None):
            raise ValueError("Missing the required parameter `attachment_info` when calling `post_add_document_attachment`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'attachment_info' in params:
            body_params = params['attachment_info']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/attachments', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AttachmentsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_append_document(self, name, append_file, **kwargs):
        """
        Append document to existing one.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_append_document(name, append_file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The original document name. (required)
        :param str append_file: Append file server path. (required)
        :param int start_page: Appending start page.
        :param int end_page: Appending end page.
        :param str storage: The documents storage.
        :param str folder: The original document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_append_document_with_http_info(name, append_file, **kwargs)
        else:
            (data) = self.post_append_document_with_http_info(name, append_file, **kwargs)
            return data

    def post_append_document_with_http_info(self, name, append_file, **kwargs):
        """
        Append document to existing one.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_append_document_with_http_info(name, append_file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The original document name. (required)
        :param str append_file: Append file server path. (required)
        :param int start_page: Appending start page.
        :param int end_page: Appending end page.
        :param str storage: The documents storage.
        :param str folder: The original document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'append_file', 'start_page', 'end_page', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_append_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_append_document`")
        # verify the required parameter 'append_file' is set
        if ('append_file' not in params) or (params['append_file'] is None):
            raise ValueError("Missing the required parameter `append_file` when calling `post_append_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'append_file' in params:
            query_params.append(('appendFile', params['append_file']))
        if 'start_page' in params:
            query_params.append(('startPage', params['start_page']))
        if 'end_page' in params:
            query_params.append(('endPage', params['end_page']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/appendDocument', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_bookmark(self, name, bookmark_path, bookmarks, **kwargs):
        """
        Add document bookmarks.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_bookmark(name, bookmark_path, bookmarks, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The parent bookmark path. Specify an empty string when adding a bookmark to the root. (required)
        :param list[Bookmark] bookmarks: The array of bookmark. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarksResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_bookmark_with_http_info(name, bookmark_path, bookmarks, **kwargs)
        else:
            (data) = self.post_bookmark_with_http_info(name, bookmark_path, bookmarks, **kwargs)
            return data

    def post_bookmark_with_http_info(self, name, bookmark_path, bookmarks, **kwargs):
        """
        Add document bookmarks.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_bookmark_with_http_info(name, bookmark_path, bookmarks, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The parent bookmark path. Specify an empty string when adding a bookmark to the root. (required)
        :param list[Bookmark] bookmarks: The array of bookmark. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarksResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bookmark_path', 'bookmarks', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_bookmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_bookmark`")
        # verify the required parameter 'bookmark_path' is set
        if ('bookmark_path' not in params) or (params['bookmark_path'] is None):
            raise ValueError("Missing the required parameter `bookmark_path` when calling `post_bookmark`")
        # verify the required parameter 'bookmarks' is set
        if ('bookmarks' not in params) or (params['bookmarks'] is None):
            raise ValueError("Missing the required parameter `bookmarks` when calling `post_bookmark`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'bookmark_path' in params:
            path_params['bookmarkPath'] = params['bookmark_path']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bookmarks' in params:
            body_params = params['bookmarks']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/bookmarks/bookmark/{bookmarkPath}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BookmarksResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_change_password_document_in_storage(self, name, owner_password, new_user_password, new_owner_password, **kwargs):
        """
        Change document password in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_change_password_document_in_storage(name, owner_password, new_user_password, new_owner_password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str owner_password: Owner password (encrypted Base64). (required)
        :param str new_user_password: New user password (encrypted Base64). (required)
        :param str new_owner_password: New owner password (encrypted Base64). (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_change_password_document_in_storage_with_http_info(name, owner_password, new_user_password, new_owner_password, **kwargs)
        else:
            (data) = self.post_change_password_document_in_storage_with_http_info(name, owner_password, new_user_password, new_owner_password, **kwargs)
            return data

    def post_change_password_document_in_storage_with_http_info(self, name, owner_password, new_user_password, new_owner_password, **kwargs):
        """
        Change document password in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_change_password_document_in_storage_with_http_info(name, owner_password, new_user_password, new_owner_password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str owner_password: Owner password (encrypted Base64). (required)
        :param str new_user_password: New user password (encrypted Base64). (required)
        :param str new_owner_password: New owner password (encrypted Base64). (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'owner_password', 'new_user_password', 'new_owner_password', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_change_password_document_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_change_password_document_in_storage`")
        # verify the required parameter 'owner_password' is set
        if ('owner_password' not in params) or (params['owner_password'] is None):
            raise ValueError("Missing the required parameter `owner_password` when calling `post_change_password_document_in_storage`")
        # verify the required parameter 'new_user_password' is set
        if ('new_user_password' not in params) or (params['new_user_password'] is None):
            raise ValueError("Missing the required parameter `new_user_password` when calling `post_change_password_document_in_storage`")
        # verify the required parameter 'new_owner_password' is set
        if ('new_owner_password' not in params) or (params['new_owner_password'] is None):
            raise ValueError("Missing the required parameter `new_owner_password` when calling `post_change_password_document_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'owner_password' in params:
            query_params.append(('ownerPassword', params['owner_password']))
        if 'new_user_password' in params:
            query_params.append(('newUserPassword', params['new_user_password']))
        if 'new_owner_password' in params:
            query_params.append(('newOwnerPassword', params['new_owner_password']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/changepassword', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_check_box_fields(self, name, fields, **kwargs):
        """
        Add document checkbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_check_box_fields(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[CheckBoxField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_check_box_fields_with_http_info(name, fields, **kwargs)
        else:
            (data) = self.post_check_box_fields_with_http_info(name, fields, **kwargs)
            return data

    def post_check_box_fields_with_http_info(self, name, fields, **kwargs):
        """
        Add document checkbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_check_box_fields_with_http_info(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[CheckBoxField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fields', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_check_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_check_box_fields`")
        # verify the required parameter 'fields' is set
        if ('fields' not in params) or (params['fields'] is None):
            raise ValueError("Missing the required parameter `fields` when calling `post_check_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'fields' in params:
            body_params = params['fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/checkbox', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_combo_box_fields(self, name, fields, **kwargs):
        """
        Add document combobox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_combo_box_fields(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[ComboBoxField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_combo_box_fields_with_http_info(name, fields, **kwargs)
        else:
            (data) = self.post_combo_box_fields_with_http_info(name, fields, **kwargs)
            return data

    def post_combo_box_fields_with_http_info(self, name, fields, **kwargs):
        """
        Add document combobox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_combo_box_fields_with_http_info(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[ComboBoxField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fields', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_combo_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_combo_box_fields`")
        # verify the required parameter 'fields' is set
        if ('fields' not in params) or (params['fields'] is None):
            raise ValueError("Missing the required parameter `fields` when calling `post_combo_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'fields' in params:
            body_params = params['fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/combobox', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_create_document(self, name, document_config, **kwargs):
        """
        Create empty document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_create_document(name, document_config, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The new document name. (required)
        :param DocumentConfig document_config: The document config for new document. (required)
        :param str storage: The document storage.
        :param str folder: The new document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_create_document_with_http_info(name, document_config, **kwargs)
        else:
            (data) = self.post_create_document_with_http_info(name, document_config, **kwargs)
            return data

    def post_create_document_with_http_info(self, name, document_config, **kwargs):
        """
        Create empty document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_create_document_with_http_info(name, document_config, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The new document name. (required)
        :param DocumentConfig document_config: The document config for new document. (required)
        :param str storage: The document storage.
        :param str folder: The new document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'document_config', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_create_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_create_document`")
        # verify the required parameter 'document_config' is set
        if ('document_config' not in params) or (params['document_config'] is None):
            raise ValueError("Missing the required parameter `document_config` when calling `post_create_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'document_config' in params:
            body_params = params['document_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_create_field(self, name, page, field, **kwargs):
        """
        Create field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_create_field(name, page, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page: Document page number. (required)
        :param Field field: Field with the field data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_create_field_with_http_info(name, page, field, **kwargs)
        else:
            (data) = self.post_create_field_with_http_info(name, page, field, **kwargs)
            return data

    def post_create_field_with_http_info(self, name, page, field, **kwargs):
        """
        Create field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_create_field_with_http_info(name, page, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page: Document page number. (required)
        :param Field field: Field with the field data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_create_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_create_field`")
        # verify the required parameter 'page' is set
        if ('page' not in params) or (params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `post_create_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `post_create_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_decrypt_document_in_storage(self, name, password, **kwargs):
        """
        Decrypt document in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_decrypt_document_in_storage(name, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str password: The password (encrypted Base64). (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_decrypt_document_in_storage_with_http_info(name, password, **kwargs)
        else:
            (data) = self.post_decrypt_document_in_storage_with_http_info(name, password, **kwargs)
            return data

    def post_decrypt_document_in_storage_with_http_info(self, name, password, **kwargs):
        """
        Decrypt document in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_decrypt_document_in_storage_with_http_info(name, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str password: The password (encrypted Base64). (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'password', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_decrypt_document_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_decrypt_document_in_storage`")
        # verify the required parameter 'password' is set
        if ('password' not in params) or (params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `post_decrypt_document_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'password' in params:
            query_params.append(('password', params['password']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/decrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_image_footer(self, name, image_footer, **kwargs):
        """
        Add document image footer.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_image_footer(name, image_footer, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param ImageFooter image_footer: The image footer. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_image_footer_with_http_info(name, image_footer, **kwargs)
        else:
            (data) = self.post_document_image_footer_with_http_info(name, image_footer, **kwargs)
            return data

    def post_document_image_footer_with_http_info(self, name, image_footer, **kwargs):
        """
        Add document image footer.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_image_footer_with_http_info(name, image_footer, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param ImageFooter image_footer: The image footer. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_footer', 'start_page_number', 'end_page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_image_footer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_image_footer`")
        # verify the required parameter 'image_footer' is set
        if ('image_footer' not in params) or (params['image_footer'] is None):
            raise ValueError("Missing the required parameter `image_footer` when calling `post_document_image_footer`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'start_page_number' in params:
            query_params.append(('startPageNumber', params['start_page_number']))
        if 'end_page_number' in params:
            query_params.append(('endPageNumber', params['end_page_number']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'image_footer' in params:
            body_params = params['image_footer']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/footer/image', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_image_header(self, name, image_header, **kwargs):
        """
        Add document image header.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_image_header(name, image_header, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param ImageHeader image_header: The image header. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_image_header_with_http_info(name, image_header, **kwargs)
        else:
            (data) = self.post_document_image_header_with_http_info(name, image_header, **kwargs)
            return data

    def post_document_image_header_with_http_info(self, name, image_header, **kwargs):
        """
        Add document image header.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_image_header_with_http_info(name, image_header, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param ImageHeader image_header: The image header. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_header', 'start_page_number', 'end_page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_image_header" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_image_header`")
        # verify the required parameter 'image_header' is set
        if ('image_header' not in params) or (params['image_header'] is None):
            raise ValueError("Missing the required parameter `image_header` when calling `post_document_image_header`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'start_page_number' in params:
            query_params.append(('startPageNumber', params['start_page_number']))
        if 'end_page_number' in params:
            query_params.append(('endPageNumber', params['end_page_number']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'image_header' in params:
            body_params = params['image_header']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/header/image', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_page_number_stamps(self, name, stamp, **kwargs):
        """
        Add document page number stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_page_number_stamps(name, stamp, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param PageNumberStamp stamp: The stamp. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_page_number_stamps_with_http_info(name, stamp, **kwargs)
        else:
            (data) = self.post_document_page_number_stamps_with_http_info(name, stamp, **kwargs)
            return data

    def post_document_page_number_stamps_with_http_info(self, name, stamp, **kwargs):
        """
        Add document page number stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_page_number_stamps_with_http_info(name, stamp, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param PageNumberStamp stamp: The stamp. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'stamp', 'start_page_number', 'end_page_number', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_page_number_stamps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_page_number_stamps`")
        # verify the required parameter 'stamp' is set
        if ('stamp' not in params) or (params['stamp'] is None):
            raise ValueError("Missing the required parameter `stamp` when calling `post_document_page_number_stamps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'start_page_number' in params:
            query_params.append(('startPageNumber', params['start_page_number']))
        if 'end_page_number' in params:
            query_params.append(('endPageNumber', params['end_page_number']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stamp' in params:
            body_params = params['stamp']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/stamps/pagenumber', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_text_footer(self, name, text_footer, **kwargs):
        """
        Add document text footer.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_text_footer(name, text_footer, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param TextFooter text_footer: The text footer. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_text_footer_with_http_info(name, text_footer, **kwargs)
        else:
            (data) = self.post_document_text_footer_with_http_info(name, text_footer, **kwargs)
            return data

    def post_document_text_footer_with_http_info(self, name, text_footer, **kwargs):
        """
        Add document text footer.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_text_footer_with_http_info(name, text_footer, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param TextFooter text_footer: The text footer. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'text_footer', 'start_page_number', 'end_page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_text_footer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_text_footer`")
        # verify the required parameter 'text_footer' is set
        if ('text_footer' not in params) or (params['text_footer'] is None):
            raise ValueError("Missing the required parameter `text_footer` when calling `post_document_text_footer`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'start_page_number' in params:
            query_params.append(('startPageNumber', params['start_page_number']))
        if 'end_page_number' in params:
            query_params.append(('endPageNumber', params['end_page_number']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_footer' in params:
            body_params = params['text_footer']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/footer/text', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_text_header(self, name, text_header, **kwargs):
        """
        Add document text header.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_text_header(name, text_header, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param TextHeader text_header: The text header. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_text_header_with_http_info(name, text_header, **kwargs)
        else:
            (data) = self.post_document_text_header_with_http_info(name, text_header, **kwargs)
            return data

    def post_document_text_header_with_http_info(self, name, text_header, **kwargs):
        """
        Add document text header.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_text_header_with_http_info(name, text_header, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param TextHeader text_header: The text header. (required)
        :param int start_page_number: The start page number.
        :param int end_page_number: The end page number.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'text_header', 'start_page_number', 'end_page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_text_header" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_text_header`")
        # verify the required parameter 'text_header' is set
        if ('text_header' not in params) or (params['text_header'] is None):
            raise ValueError("Missing the required parameter `text_header` when calling `post_document_text_header`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'start_page_number' in params:
            query_params.append(('startPageNumber', params['start_page_number']))
        if 'end_page_number' in params:
            query_params.append(('endPageNumber', params['end_page_number']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_header' in params:
            body_params = params['text_header']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/header/text', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_text_replace(self, name, text_replace, **kwargs):
        """
        Document's replace text method.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_text_replace(name, text_replace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param TextReplaceListRequest text_replace: (required)
        :param str storage:
        :param str folder:
        :return: TextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_text_replace_with_http_info(name, text_replace, **kwargs)
        else:
            (data) = self.post_document_text_replace_with_http_info(name, text_replace, **kwargs)
            return data

    def post_document_text_replace_with_http_info(self, name, text_replace, **kwargs):
        """
        Document's replace text method.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_text_replace_with_http_info(name, text_replace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param TextReplaceListRequest text_replace: (required)
        :param str storage:
        :param str folder:
        :return: TextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'text_replace', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_text_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_text_replace`")
        # verify the required parameter 'text_replace' is set
        if ('text_replace' not in params) or (params['text_replace'] is None):
            raise ValueError("Missing the required parameter `text_replace` when calling `post_document_text_replace`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_replace' in params:
            body_params = params['text_replace']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/text/replace', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextReplaceResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_encrypt_document_in_storage(self, name, user_password, owner_password, crypto_algorithm, **kwargs):
        """
        Encrypt document in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_encrypt_document_in_storage(name, user_password, owner_password, crypto_algorithm, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str user_password: User password (encrypted Base64). (required)
        :param str owner_password: Owner password (encrypted Base64). (required)
        :param str crypto_algorithm: Cryptographic algorithm, see CryptoAlgorithm for details. (required)
        :param list[PermissionsFlags] permissions_flags: Array of document permissions, see PermissionsFlags for details.
        :param bool use_pdf20: Support for revision 6 (Extension 8).
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_encrypt_document_in_storage_with_http_info(name, user_password, owner_password, crypto_algorithm, **kwargs)
        else:
            (data) = self.post_encrypt_document_in_storage_with_http_info(name, user_password, owner_password, crypto_algorithm, **kwargs)
            return data

    def post_encrypt_document_in_storage_with_http_info(self, name, user_password, owner_password, crypto_algorithm, **kwargs):
        """
        Encrypt document in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_encrypt_document_in_storage_with_http_info(name, user_password, owner_password, crypto_algorithm, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str user_password: User password (encrypted Base64). (required)
        :param str owner_password: Owner password (encrypted Base64). (required)
        :param str crypto_algorithm: Cryptographic algorithm, see CryptoAlgorithm for details. (required)
        :param list[PermissionsFlags] permissions_flags: Array of document permissions, see PermissionsFlags for details.
        :param bool use_pdf20: Support for revision 6 (Extension 8).
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'user_password', 'owner_password', 'crypto_algorithm', 'permissions_flags', 'use_pdf20', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_encrypt_document_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_encrypt_document_in_storage`")
        # verify the required parameter 'user_password' is set
        if ('user_password' not in params) or (params['user_password'] is None):
            raise ValueError("Missing the required parameter `user_password` when calling `post_encrypt_document_in_storage`")
        # verify the required parameter 'owner_password' is set
        if ('owner_password' not in params) or (params['owner_password'] is None):
            raise ValueError("Missing the required parameter `owner_password` when calling `post_encrypt_document_in_storage`")
        # verify the required parameter 'crypto_algorithm' is set
        if ('crypto_algorithm' not in params) or (params['crypto_algorithm'] is None):
            raise ValueError("Missing the required parameter `crypto_algorithm` when calling `post_encrypt_document_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'user_password' in params:
            query_params.append(('userPassword', params['user_password']))
        if 'owner_password' in params:
            query_params.append(('ownerPassword', params['owner_password']))
        if 'crypto_algorithm' in params:
            query_params.append(('cryptoAlgorithm', params['crypto_algorithm']))
        if 'permissions_flags' in params:
            query_params.append(('permissionsFlags', params['permissions_flags']))
            collection_formats['permissionsFlags'] = 'csv'
        if 'use_pdf20' in params:
            query_params.append(('usePdf20', params['use_pdf20']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/encrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_flatten_document(self, name, **kwargs):
        """
        Flatten the document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_flatten_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool update_appearances: If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance..
        :param bool call_events: If set, formatting and other JavaScript events will be called.
        :param bool hide_buttons: If set, buttons will be removed from flattened document.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_flatten_document_with_http_info(name, **kwargs)
        else:
            (data) = self.post_flatten_document_with_http_info(name, **kwargs)
            return data

    def post_flatten_document_with_http_info(self, name, **kwargs):
        """
        Flatten the document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_flatten_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool update_appearances: If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance..
        :param bool call_events: If set, formatting and other JavaScript events will be called.
        :param bool hide_buttons: If set, buttons will be removed from flattened document.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'update_appearances', 'call_events', 'hide_buttons', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_flatten_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_flatten_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'update_appearances' in params:
            query_params.append(('updateAppearances', params['update_appearances']))
        if 'call_events' in params:
            query_params.append(('callEvents', params['call_events']))
        if 'hide_buttons' in params:
            query_params.append(('hideButtons', params['hide_buttons']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/flatten', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_import_fields_from_fdf(self, name, **kwargs):
        """
        Update fields from FDF file in request.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_import_fields_from_fdf(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file fdf_data: Fdf file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_import_fields_from_fdf_with_http_info(name, **kwargs)
        else:
            (data) = self.post_import_fields_from_fdf_with_http_info(name, **kwargs)
            return data

    def post_import_fields_from_fdf_with_http_info(self, name, **kwargs):
        """
        Update fields from FDF file in request.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_import_fields_from_fdf_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file fdf_data: Fdf file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'fdf_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_import_fields_from_fdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_import_fields_from_fdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'fdf_data' in params:
            local_var_files['fdfData'] = params['fdf_data']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/fdf', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_import_fields_from_xfdf(self, name, **kwargs):
        """
        Update fields from XFDF file in request.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_import_fields_from_xfdf(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file xfdf_data: Xfdf file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_import_fields_from_xfdf_with_http_info(name, **kwargs)
        else:
            (data) = self.post_import_fields_from_xfdf_with_http_info(name, **kwargs)
            return data

    def post_import_fields_from_xfdf_with_http_info(self, name, **kwargs):
        """
        Update fields from XFDF file in request.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_import_fields_from_xfdf_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file xfdf_data: Xfdf file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'xfdf_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_import_fields_from_xfdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_import_fields_from_xfdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'xfdf_data' in params:
            local_var_files['xfdfData'] = params['xfdf_data']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/xfdf', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_import_fields_from_xml(self, name, **kwargs):
        """
        Update fields from XML file in request.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_import_fields_from_xml(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file xml_data: Xml file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_import_fields_from_xml_with_http_info(name, **kwargs)
        else:
            (data) = self.post_import_fields_from_xml_with_http_info(name, **kwargs)
            return data

    def post_import_fields_from_xml_with_http_info(self, name, **kwargs):
        """
        Update fields from XML file in request.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_import_fields_from_xml_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file xml_data: Xml file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'xml_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_import_fields_from_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_import_fields_from_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'xml_data' in params:
            local_var_files['xmlData'] = params['xml_data']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/xml', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_insert_image(self, name, page_number, llx, lly, urx, ury, **kwargs):
        """
        Insert image to document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_insert_image(name, page_number, llx, lly, urx, ury, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param float llx: Coordinate lower left X. (required)
        :param float lly: Coordinate lower left Y. (required)
        :param float urx: Coordinate upper right X. (required)
        :param float ury: Coordinate upper right Y. (required)
        :param str image_file_path: Path to image file if specified. Request content is used otherwise.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file image: Image file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_insert_image_with_http_info(name, page_number, llx, lly, urx, ury, **kwargs)
        else:
            (data) = self.post_insert_image_with_http_info(name, page_number, llx, lly, urx, ury, **kwargs)
            return data

    def post_insert_image_with_http_info(self, name, page_number, llx, lly, urx, ury, **kwargs):
        """
        Insert image to document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_insert_image_with_http_info(name, page_number, llx, lly, urx, ury, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param float llx: Coordinate lower left X. (required)
        :param float lly: Coordinate lower left Y. (required)
        :param float urx: Coordinate upper right X. (required)
        :param float ury: Coordinate upper right Y. (required)
        :param str image_file_path: Path to image file if specified. Request content is used otherwise.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file image: Image file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'llx', 'lly', 'urx', 'ury', 'image_file_path', 'storage', 'folder', 'image']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_insert_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_insert_image`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_insert_image`")
        # verify the required parameter 'llx' is set
        if ('llx' not in params) or (params['llx'] is None):
            raise ValueError("Missing the required parameter `llx` when calling `post_insert_image`")
        # verify the required parameter 'lly' is set
        if ('lly' not in params) or (params['lly'] is None):
            raise ValueError("Missing the required parameter `lly` when calling `post_insert_image`")
        # verify the required parameter 'urx' is set
        if ('urx' not in params) or (params['urx'] is None):
            raise ValueError("Missing the required parameter `urx` when calling `post_insert_image`")
        # verify the required parameter 'ury' is set
        if ('ury' not in params) or (params['ury'] is None):
            raise ValueError("Missing the required parameter `ury` when calling `post_insert_image`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'llx' in params:
            query_params.append(('llx', params['llx']))
        if 'lly' in params:
            query_params.append(('lly', params['lly']))
        if 'urx' in params:
            query_params.append(('urx', params['urx']))
        if 'ury' in params:
            query_params.append(('ury', params['ury']))
        if 'image_file_path' in params:
            query_params.append(('imageFilePath', params['image_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_list_box_fields(self, name, fields, **kwargs):
        """
        Add document listbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_list_box_fields(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[ListBoxField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_list_box_fields_with_http_info(name, fields, **kwargs)
        else:
            (data) = self.post_list_box_fields_with_http_info(name, fields, **kwargs)
            return data

    def post_list_box_fields_with_http_info(self, name, fields, **kwargs):
        """
        Add document listbox fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_list_box_fields_with_http_info(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[ListBoxField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fields', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_list_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_list_box_fields`")
        # verify the required parameter 'fields' is set
        if ('fields' not in params) or (params['fields'] is None):
            raise ValueError("Missing the required parameter `fields` when calling `post_list_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'fields' in params:
            body_params = params['fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/listbox', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_move_page(self, name, page_number, new_index, **kwargs):
        """
        Move page to new position.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_move_page(name, page_number, new_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int new_index: The new page position/index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_move_page_with_http_info(name, page_number, new_index, **kwargs)
        else:
            (data) = self.post_move_page_with_http_info(name, page_number, new_index, **kwargs)
            return data

    def post_move_page_with_http_info(self, name, page_number, new_index, **kwargs):
        """
        Move page to new position.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_move_page_with_http_info(name, page_number, new_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int new_index: The new page position/index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'new_index', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_move_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_move_page`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_move_page`")
        # verify the required parameter 'new_index' is set
        if ('new_index' not in params) or (params['new_index'] is None):
            raise ValueError("Missing the required parameter `new_index` when calling `post_move_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'new_index' in params:
            query_params.append(('newIndex', params['new_index']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/movePage', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_optimize_document(self, name, options, **kwargs):
        """
        Optimize document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_optimize_document(name, options, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param OptimizeOptions options: The optimization options. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_optimize_document_with_http_info(name, options, **kwargs)
        else:
            (data) = self.post_optimize_document_with_http_info(name, options, **kwargs)
            return data

    def post_optimize_document_with_http_info(self, name, options, **kwargs):
        """
        Optimize document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_optimize_document_with_http_info(name, options, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param OptimizeOptions options: The optimization options. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'options', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_optimize_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_optimize_document`")
        # verify the required parameter 'options' is set
        if ('options' not in params) or (params['options'] is None):
            raise ValueError("Missing the required parameter `options` when calling `post_optimize_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'options' in params:
            body_params = params['options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/optimize', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_organize_document(self, name, pages, out_path, **kwargs):
        """
        Merge selected pages of a document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_organize_document(name, pages, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The original document name. (required)
        :param str pages: 1-based page numbers of the source document that make up the resulting document. (required)
        :param str out_path: Full filename of the resulting document. (required)
        :param str storage: The documents storage.
        :param str folder: The source document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_organize_document_with_http_info(name, pages, out_path, **kwargs)
        else:
            (data) = self.post_organize_document_with_http_info(name, pages, out_path, **kwargs)
            return data

    def post_organize_document_with_http_info(self, name, pages, out_path, **kwargs):
        """
        Merge selected pages of a document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_organize_document_with_http_info(name, pages, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The original document name. (required)
        :param str pages: 1-based page numbers of the source document that make up the resulting document. (required)
        :param str out_path: Full filename of the resulting document. (required)
        :param str storage: The documents storage.
        :param str folder: The source document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pages', 'out_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_organize_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_organize_document`")
        # verify the required parameter 'pages' is set
        if ('pages' not in params) or (params['pages'] is None):
            raise ValueError("Missing the required parameter `pages` when calling `post_organize_document`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `post_organize_document`")

        if 'pages' in params and len(params['pages']) < 1:
            raise ValueError("Invalid value for parameter `pages` when calling `post_organize_document`, length must be greater than or equal to `1`")
        if 'out_path' in params and len(params['out_path']) < 1:
            raise ValueError("Invalid value for parameter `out_path` when calling `post_organize_document`, length must be greater than or equal to `1`")

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'pages' in params:
            query_params.append(('pages', params['pages']))
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/organize', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_organize_documents(self, organize_documents, out_path, **kwargs):
        """
        Merge selected pages of different documents.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_organize_documents(organize_documents, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param OrganizeDocumentRequest organize_documents: Array of OrganizeDocumentData to make up the resulting document. (required)
        :param str out_path: Full filename of the resulting document. (required)
        :param str storage: The documents storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_organize_documents_with_http_info(organize_documents, out_path, **kwargs)
        else:
            (data) = self.post_organize_documents_with_http_info(organize_documents, out_path, **kwargs)
            return data

    def post_organize_documents_with_http_info(self, organize_documents, out_path, **kwargs):
        """
        Merge selected pages of different documents.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_organize_documents_with_http_info(organize_documents, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param OrganizeDocumentRequest organize_documents: Array of OrganizeDocumentData to make up the resulting document. (required)
        :param str out_path: Full filename of the resulting document. (required)
        :param str storage: The documents storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organize_documents', 'out_path', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_organize_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organize_documents' is set
        if ('organize_documents' not in params) or (params['organize_documents'] is None):
            raise ValueError("Missing the required parameter `organize_documents` when calling `post_organize_documents`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `post_organize_documents`")

        if 'out_path' in params and len(params['out_path']) < 1:
            raise ValueError("Invalid value for parameter `out_path` when calling `post_organize_documents`, length must be greater than or equal to `1`")

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organize_documents' in params:
            body_params = params['organize_documents']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/organize', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_caret_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page caret annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_caret_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[CaretAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_caret_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_caret_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_caret_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page caret annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_caret_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[CaretAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_caret_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_caret_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_caret_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_caret_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/caret', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_certify(self, name, page_number, sign, doc_mdp_access_permission_type, **kwargs):
        """
        Certify document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_certify(name, page_number, sign, doc_mdp_access_permission_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Signature sign: Signature object containing signature data. (required)
        :param str doc_mdp_access_permission_type: The access permissions granted for this document. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_certify_with_http_info(name, page_number, sign, doc_mdp_access_permission_type, **kwargs)
        else:
            (data) = self.post_page_certify_with_http_info(name, page_number, sign, doc_mdp_access_permission_type, **kwargs)
            return data

    def post_page_certify_with_http_info(self, name, page_number, sign, doc_mdp_access_permission_type, **kwargs):
        """
        Certify document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_certify_with_http_info(name, page_number, sign, doc_mdp_access_permission_type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Signature sign: Signature object containing signature data. (required)
        :param str doc_mdp_access_permission_type: The access permissions granted for this document. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'sign', 'doc_mdp_access_permission_type', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_certify" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_certify`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_certify`")
        # verify the required parameter 'sign' is set
        if ('sign' not in params) or (params['sign'] is None):
            raise ValueError("Missing the required parameter `sign` when calling `post_page_certify`")
        # verify the required parameter 'doc_mdp_access_permission_type' is set
        if ('doc_mdp_access_permission_type' not in params) or (params['doc_mdp_access_permission_type'] is None):
            raise ValueError("Missing the required parameter `doc_mdp_access_permission_type` when calling `post_page_certify`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'doc_mdp_access_permission_type' in params:
            query_params.append(('docMdpAccessPermissionType', params['doc_mdp_access_permission_type']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign' in params:
            body_params = params['sign']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/certify', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_circle_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page circle annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_circle_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[CircleAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_circle_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_circle_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_circle_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page circle annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_circle_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[CircleAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_circle_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_circle_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_circle_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_circle_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/circle', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_file_attachment_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page FileAttachment annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_file_attachment_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[FileAttachmentAnnotation] annotations: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_file_attachment_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_file_attachment_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_file_attachment_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page FileAttachment annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_file_attachment_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[FileAttachmentAnnotation] annotations: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_file_attachment_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_file_attachment_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_file_attachment_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_file_attachment_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/fileattachment', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_free_text_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page free text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_free_text_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[FreeTextAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_free_text_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_free_text_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_free_text_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page free text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_free_text_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[FreeTextAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_free_text_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_free_text_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_free_text_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_free_text_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/freetext', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_highlight_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page highlight annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_highlight_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[HighlightAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_highlight_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_highlight_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_highlight_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page highlight annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_highlight_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[HighlightAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_highlight_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_highlight_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_highlight_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_highlight_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/highlight', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_image_stamps(self, name, page_number, stamps, **kwargs):
        """
        Add document page image stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_image_stamps(name, page_number, stamps, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[ImageStamp] stamps: The array of stamp. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_image_stamps_with_http_info(name, page_number, stamps, **kwargs)
        else:
            (data) = self.post_page_image_stamps_with_http_info(name, page_number, stamps, **kwargs)
            return data

    def post_page_image_stamps_with_http_info(self, name, page_number, stamps, **kwargs):
        """
        Add document page image stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_image_stamps_with_http_info(name, page_number, stamps, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[ImageStamp] stamps: The array of stamp. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'stamps', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_image_stamps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_image_stamps`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_image_stamps`")
        # verify the required parameter 'stamps' is set
        if ('stamps' not in params) or (params['stamps'] is None):
            raise ValueError("Missing the required parameter `stamps` when calling `post_page_image_stamps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stamps' in params:
            body_params = params['stamps']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/stamps/image', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_ink_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page ink annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_ink_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[InkAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_ink_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_ink_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_ink_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page ink annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_ink_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[InkAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_ink_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_ink_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_ink_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_ink_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/ink', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_line_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page line annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_line_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[LineAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_line_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_line_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_line_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page line annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_line_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[LineAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_line_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_line_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_line_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_line_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/line', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_link_annotations(self, name, page_number, links, **kwargs):
        """
        Add document page link annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_link_annotations(name, page_number, links, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[LinkAnnotation] links: Array of link annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_link_annotations_with_http_info(name, page_number, links, **kwargs)
        else:
            (data) = self.post_page_link_annotations_with_http_info(name, page_number, links, **kwargs)
            return data

    def post_page_link_annotations_with_http_info(self, name, page_number, links, **kwargs):
        """
        Add document page link annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_link_annotations_with_http_info(name, page_number, links, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[LinkAnnotation] links: Array of link annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'links', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_link_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_link_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_link_annotations`")
        # verify the required parameter 'links' is set
        if ('links' not in params) or (params['links'] is None):
            raise ValueError("Missing the required parameter `links` when calling `post_page_link_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'links' in params:
            body_params = params['links']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/links', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_movie_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page movie annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_movie_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[MovieAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_movie_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_movie_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_movie_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page movie annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_movie_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[MovieAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_movie_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_movie_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_movie_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_movie_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/movie', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_pdf_page_stamps(self, name, page_number, stamps, **kwargs):
        """
        Add document pdf page stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_pdf_page_stamps(name, page_number, stamps, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[PdfPageStamp] stamps: The array of stamp. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_pdf_page_stamps_with_http_info(name, page_number, stamps, **kwargs)
        else:
            (data) = self.post_page_pdf_page_stamps_with_http_info(name, page_number, stamps, **kwargs)
            return data

    def post_page_pdf_page_stamps_with_http_info(self, name, page_number, stamps, **kwargs):
        """
        Add document pdf page stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_pdf_page_stamps_with_http_info(name, page_number, stamps, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[PdfPageStamp] stamps: The array of stamp. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'stamps', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_pdf_page_stamps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_pdf_page_stamps`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_pdf_page_stamps`")
        # verify the required parameter 'stamps' is set
        if ('stamps' not in params) or (params['stamps'] is None):
            raise ValueError("Missing the required parameter `stamps` when calling `post_page_pdf_page_stamps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stamps' in params:
            body_params = params['stamps']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/stamps/pdfpage', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_poly_line_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page polyline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_poly_line_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[PolyLineAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_poly_line_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_poly_line_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_poly_line_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page polyline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_poly_line_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[PolyLineAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_poly_line_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_poly_line_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_poly_line_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_poly_line_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/polyline', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_polygon_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page polygon annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_polygon_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[PolygonAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_polygon_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_polygon_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_polygon_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page polygon annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_polygon_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[PolygonAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_polygon_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_polygon_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_polygon_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_polygon_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/polygon', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_redaction_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page redaction annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_redaction_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[RedactionAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param bool apply: Apply redaction immediately after adding.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_redaction_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_redaction_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_redaction_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page redaction annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_redaction_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[RedactionAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param bool apply: Apply redaction immediately after adding.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder', 'apply']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_redaction_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_redaction_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_redaction_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_redaction_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'apply' in params:
            query_params.append(('apply', params['apply']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/redaction', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_screen_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page screen annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_screen_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[ScreenAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_screen_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_screen_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_screen_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page screen annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_screen_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[ScreenAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_screen_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_screen_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_screen_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_screen_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/screen', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_sound_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page sound annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_sound_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[SoundAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_sound_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_sound_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_sound_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page sound annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_sound_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[SoundAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_sound_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_sound_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_sound_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_sound_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/sound', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_square_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page square annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_square_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[SquareAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_square_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_square_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_square_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page square annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_square_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[SquareAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_square_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_square_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_square_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_square_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/square', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_squiggly_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page squiggly annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_squiggly_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[SquigglyAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_squiggly_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_squiggly_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_squiggly_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page squiggly annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_squiggly_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[SquigglyAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_squiggly_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_squiggly_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_squiggly_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_squiggly_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/squiggly', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_stamp_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page stamp annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_stamp_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[StampAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_stamp_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_stamp_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_stamp_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page stamp annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_stamp_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[StampAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_stamp_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_stamp_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_stamp_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_stamp_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/stamp', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_strike_out_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page StrikeOut annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_strike_out_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[StrikeOutAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_strike_out_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_strike_out_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_strike_out_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page StrikeOut annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_strike_out_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[StrikeOutAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_strike_out_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_strike_out_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_strike_out_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_strike_out_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/strikeout', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_tables(self, name, page_number, tables, **kwargs):
        """
        Add document page tables.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_tables(name, page_number, tables, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[Table] tables: The array of table. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_tables_with_http_info(name, page_number, tables, **kwargs)
        else:
            (data) = self.post_page_tables_with_http_info(name, page_number, tables, **kwargs)
            return data

    def post_page_tables_with_http_info(self, name, page_number, tables, **kwargs):
        """
        Add document page tables.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_tables_with_http_info(name, page_number, tables, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[Table] tables: The array of table. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'tables', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_tables" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_tables`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_tables`")
        # verify the required parameter 'tables' is set
        if ('tables' not in params) or (params['tables'] is None):
            raise ValueError("Missing the required parameter `tables` when calling `post_page_tables`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tables' in params:
            body_params = params['tables']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/tables', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_text_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_text_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[TextAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_text_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_text_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_text_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page text annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_text_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[TextAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_text_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_text_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_text_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_text_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/text', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_text_replace(self, name, page_number, text_replace_list_request, **kwargs):
        """
        Page's replace text method.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_text_replace(name, page_number, text_replace_list_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param TextReplaceListRequest text_replace_list_request: (required)
        :param str storage:
        :param str folder:
        :return: TextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_text_replace_with_http_info(name, page_number, text_replace_list_request, **kwargs)
        else:
            (data) = self.post_page_text_replace_with_http_info(name, page_number, text_replace_list_request, **kwargs)
            return data

    def post_page_text_replace_with_http_info(self, name, page_number, text_replace_list_request, **kwargs):
        """
        Page's replace text method.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_text_replace_with_http_info(name, page_number, text_replace_list_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param TextReplaceListRequest text_replace_list_request: (required)
        :param str storage:
        :param str folder:
        :return: TextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'text_replace_list_request', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_text_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_text_replace`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_text_replace`")
        # verify the required parameter 'text_replace_list_request' is set
        if ('text_replace_list_request' not in params) or (params['text_replace_list_request'] is None):
            raise ValueError("Missing the required parameter `text_replace_list_request` when calling `post_page_text_replace`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_replace_list_request' in params:
            body_params = params['text_replace_list_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/text/replace', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextReplaceResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_text_stamps(self, name, page_number, stamps, **kwargs):
        """
        Add document page text stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_text_stamps(name, page_number, stamps, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[TextStamp] stamps: The array of stamp. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_text_stamps_with_http_info(name, page_number, stamps, **kwargs)
        else:
            (data) = self.post_page_text_stamps_with_http_info(name, page_number, stamps, **kwargs)
            return data

    def post_page_text_stamps_with_http_info(self, name, page_number, stamps, **kwargs):
        """
        Add document page text stamps.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_text_stamps_with_http_info(name, page_number, stamps, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[TextStamp] stamps: The array of stamp. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'stamps', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_text_stamps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_text_stamps`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_text_stamps`")
        # verify the required parameter 'stamps' is set
        if ('stamps' not in params) or (params['stamps'] is None):
            raise ValueError("Missing the required parameter `stamps` when calling `post_page_text_stamps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stamps' in params:
            body_params = params['stamps']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/stamps/text', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_underline_annotations(self, name, page_number, annotations, **kwargs):
        """
        Add document page underline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_underline_annotations(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[UnderlineAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_underline_annotations_with_http_info(name, page_number, annotations, **kwargs)
        else:
            (data) = self.post_page_underline_annotations_with_http_info(name, page_number, annotations, **kwargs)
            return data

    def post_page_underline_annotations_with_http_info(self, name, page_number, annotations, **kwargs):
        """
        Add document page underline annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_underline_annotations_with_http_info(name, page_number, annotations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param list[UnderlineAnnotation] annotations: The array of annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotations', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_underline_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_underline_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_underline_annotations`")
        # verify the required parameter 'annotations' is set
        if ('annotations' not in params) or (params['annotations'] is None):
            raise ValueError("Missing the required parameter `annotations` when calling `post_page_underline_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotations' in params:
            body_params = params['annotations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/underline', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_pdf_to_xlsx(self, **kwargs):
        """
        Converts PDF document (in request content) to XLSX format and uploads and returns resulting file in response content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_pdf_to_xlsx(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param bool uniform_worksheets: Uniform worksheets
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_pdf_to_xlsx_with_http_info(**kwargs)
        else:
            (data) = self.post_pdf_to_xlsx_with_http_info(**kwargs)
            return data

    def post_pdf_to_xlsx_with_http_info(self, **kwargs):
        """
        Converts PDF document (in request content) to XLSX format and uploads and returns resulting file in response content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_pdf_to_xlsx_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param bool uniform_worksheets: Uniform worksheets
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'uniform_worksheets', 'password', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_pdf_to_xlsx" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/xlsx', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_popup_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Add document popup annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_popup_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The parent annotation ID. (required)
        :param PopupAnnotation annotation: The annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_popup_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.post_popup_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def post_popup_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Add document popup annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_popup_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The parent annotation ID. (required)
        :param PopupAnnotation annotation: The annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_popup_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_popup_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `post_popup_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `post_popup_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/{annotationId}/popup', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_radio_button_fields(self, name, fields, **kwargs):
        """
        Add document RadioButton fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_radio_button_fields(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[RadioButtonField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_radio_button_fields_with_http_info(name, fields, **kwargs)
        else:
            (data) = self.post_radio_button_fields_with_http_info(name, fields, **kwargs)
            return data

    def post_radio_button_fields_with_http_info(self, name, fields, **kwargs):
        """
        Add document RadioButton fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_radio_button_fields_with_http_info(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[RadioButtonField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fields', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_radio_button_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_radio_button_fields`")
        # verify the required parameter 'fields' is set
        if ('fields' not in params) or (params['fields'] is None):
            raise ValueError("Missing the required parameter `fields` when calling `post_radio_button_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'fields' in params:
            body_params = params['fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/radiobutton', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_sign_document(self, name, sign, **kwargs):
        """
        Sign document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_sign_document(name, sign, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param Signature sign: Signature object containing signature data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_sign_document_with_http_info(name, sign, **kwargs)
        else:
            (data) = self.post_sign_document_with_http_info(name, sign, **kwargs)
            return data

    def post_sign_document_with_http_info(self, name, sign, **kwargs):
        """
        Sign document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_sign_document_with_http_info(name, sign, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param Signature sign: Signature object containing signature data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'sign', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_sign_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_sign_document`")
        # verify the required parameter 'sign' is set
        if ('sign' not in params) or (params['sign'] is None):
            raise ValueError("Missing the required parameter `sign` when calling `post_sign_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign' in params:
            body_params = params['sign']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/sign', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_sign_page(self, name, page_number, sign, **kwargs):
        """
        Sign page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_sign_page(name, page_number, sign, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Signature sign: Signature object containing signature data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_sign_page_with_http_info(name, page_number, sign, **kwargs)
        else:
            (data) = self.post_sign_page_with_http_info(name, page_number, sign, **kwargs)
            return data

    def post_sign_page_with_http_info(self, name, page_number, sign, **kwargs):
        """
        Sign page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_sign_page_with_http_info(name, page_number, sign, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Signature sign: Signature object containing signature data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'sign', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_sign_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_sign_page`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_sign_page`")
        # verify the required parameter 'sign' is set
        if ('sign' not in params) or (params['sign'] is None):
            raise ValueError("Missing the required parameter `sign` when calling `post_sign_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign' in params:
            body_params = params['sign']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/sign', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_signature_field(self, name, field, **kwargs):
        """
        Add document signature field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_signature_field(name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param SignatureField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_signature_field_with_http_info(name, field, **kwargs)
        else:
            (data) = self.post_signature_field_with_http_info(name, field, **kwargs)
            return data

    def post_signature_field_with_http_info(self, name, field, **kwargs):
        """
        Add document signature field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_signature_field_with_http_info(name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param SignatureField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_signature_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_signature_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `post_signature_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/signature', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_split_document(self, name, **kwargs):
        """
        Split document to parts.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_split_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str format: Resulting documents format.
        :param int _from: Start page if defined.
        :param int to: End page if defined.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: SplitResultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_split_document_with_http_info(name, **kwargs)
        else:
            (data) = self.post_split_document_with_http_info(name, **kwargs)
            return data

    def post_split_document_with_http_info(self, name, **kwargs):
        """
        Split document to parts.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_split_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str format: Resulting documents format.
        :param int _from: Start page if defined.
        :param int to: End page if defined.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: SplitResultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', '_from', 'to', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_split_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_split_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
        if '_from' in params:
            query_params.append(('from', params['_from']))
        if 'to' in params:
            query_params.append(('to', params['to']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/split', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SplitResultResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_split_range_pdf_document(self, name, options, **kwargs):
        """
        Split document into ranges.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_split_range_pdf_document(name, options, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param SplitRangePdfOptions options: The splitting options. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: SplitResultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_split_range_pdf_document_with_http_info(name, options, **kwargs)
        else:
            (data) = self.post_split_range_pdf_document_with_http_info(name, options, **kwargs)
            return data

    def post_split_range_pdf_document_with_http_info(self, name, options, **kwargs):
        """
        Split document into ranges.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_split_range_pdf_document_with_http_info(name, options, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param SplitRangePdfOptions options: The splitting options. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: Base64 encoded password.
        :return: SplitResultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'options', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_split_range_pdf_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_split_range_pdf_document`")
        # verify the required parameter 'options' is set
        if ('options' not in params) or (params['options'] is None):
            raise ValueError("Missing the required parameter `options` when calling `post_split_range_pdf_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'options' in params:
            body_params = params['options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/splitrangepdf', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SplitResultResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_text_box_fields(self, name, fields, **kwargs):
        """
        Add document text box fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_text_box_fields(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[TextBoxField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_text_box_fields_with_http_info(name, fields, **kwargs)
        else:
            (data) = self.post_text_box_fields_with_http_info(name, fields, **kwargs)
            return data

    def post_text_box_fields_with_http_info(self, name, fields, **kwargs):
        """
        Add document text box fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_text_box_fields_with_http_info(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[TextBoxField] fields: The array of field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fields', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_text_box_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_text_box_fields`")
        # verify the required parameter 'fields' is set
        if ('fields' not in params) or (params['fields'] is None):
            raise ValueError("Missing the required parameter `fields` when calling `post_text_box_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'fields' in params:
            body_params = params['fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/textbox', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_add_new_page(self, name, **kwargs):
        """
        Add new page to end of the document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_new_page(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_add_new_page_with_http_info(name, **kwargs)
        else:
            (data) = self.put_add_new_page_with_http_info(name, **kwargs)
            return data

    def put_add_new_page_with_http_info(self, name, **kwargs):
        """
        Add new page to end of the document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_new_page_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_add_new_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_add_new_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPagesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_add_text(self, name, page_number, paragraph, **kwargs):
        """
        Add text to PDF document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_text(name, page_number, paragraph, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: Number of page (starting from 1). (required)
        :param Paragraph paragraph: Paragraph data. (required)
        :param str folder: Document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_add_text_with_http_info(name, page_number, paragraph, **kwargs)
        else:
            (data) = self.put_add_text_with_http_info(name, page_number, paragraph, **kwargs)
            return data

    def put_add_text_with_http_info(self, name, page_number, paragraph, **kwargs):
        """
        Add text to PDF document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_text_with_http_info(name, page_number, paragraph, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: Number of page (starting from 1). (required)
        :param Paragraph paragraph: Paragraph data. (required)
        :param str folder: Document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'paragraph', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_add_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_add_text`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_add_text`")
        # verify the required parameter 'paragraph' is set
        if ('paragraph' not in params) or (params['paragraph'] is None):
            raise ValueError("Missing the required parameter `paragraph` when calling `put_add_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'paragraph' in params:
            body_params = params['paragraph']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/text', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_annotations_flatten(self, name, **kwargs):
        """
        Flattens the annotations of the specified types
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_annotations_flatten(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int start_page: The start page number.
        :param int end_page: The end page number.
        :param list[AnnotationType] annotation_types: Array of annotation types.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_annotations_flatten_with_http_info(name, **kwargs)
        else:
            (data) = self.put_annotations_flatten_with_http_info(name, **kwargs)
            return data

    def put_annotations_flatten_with_http_info(self, name, **kwargs):
        """
        Flattens the annotations of the specified types
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_annotations_flatten_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int start_page: The start page number.
        :param int end_page: The end page number.
        :param list[AnnotationType] annotation_types: Array of annotation types.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'start_page', 'end_page', 'annotation_types', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_annotations_flatten" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_annotations_flatten`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'start_page' in params:
            query_params.append(('startPage', params['start_page']))
        if 'end_page' in params:
            query_params.append(('endPage', params['end_page']))
        if 'annotation_types' in params:
            query_params.append(('annotationTypes', params['annotation_types']))
            collection_formats['annotationTypes'] = 'csv'
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/flatten', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_bookmark(self, name, bookmark_path, bookmark, **kwargs):
        """
        Update document bookmark.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_bookmark(name, bookmark_path, bookmark, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. (required)
        :param Bookmark bookmark: The bookmark. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_bookmark_with_http_info(name, bookmark_path, bookmark, **kwargs)
        else:
            (data) = self.put_bookmark_with_http_info(name, bookmark_path, bookmark, **kwargs)
            return data

    def put_bookmark_with_http_info(self, name, bookmark_path, bookmark, **kwargs):
        """
        Update document bookmark.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_bookmark_with_http_info(name, bookmark_path, bookmark, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. (required)
        :param Bookmark bookmark: The bookmark. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: BookmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bookmark_path', 'bookmark', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_bookmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_bookmark`")
        # verify the required parameter 'bookmark_path' is set
        if ('bookmark_path' not in params) or (params['bookmark_path'] is None):
            raise ValueError("Missing the required parameter `bookmark_path` when calling `put_bookmark`")
        # verify the required parameter 'bookmark' is set
        if ('bookmark' not in params) or (params['bookmark'] is None):
            raise ValueError("Missing the required parameter `bookmark` when calling `put_bookmark`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'bookmark_path' in params:
            path_params['bookmarkPath'] = params['bookmark_path']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bookmark' in params:
            body_params = params['bookmark']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/bookmarks/bookmark/{bookmarkPath}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BookmarkResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_caret_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document caret annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_caret_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param CaretAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CaretAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_caret_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_caret_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_caret_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document caret annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_caret_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param CaretAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CaretAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_caret_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_caret_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_caret_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_caret_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/caret/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CaretAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_change_password_document(self, out_path, owner_password, new_user_password, new_owner_password, **kwargs):
        """
        Change document password from content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_change_password_document(out_path, owner_password, new_user_password, new_owner_password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param str owner_password: Owner password (encrypted Base64). (required)
        :param str new_user_password: New user password (encrypted Base64). (required)
        :param str new_owner_password: New owner password (encrypted Base64). (required)
        :param str storage: The document storage.
        :param file file: A file to be changed password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_change_password_document_with_http_info(out_path, owner_password, new_user_password, new_owner_password, **kwargs)
        else:
            (data) = self.put_change_password_document_with_http_info(out_path, owner_password, new_user_password, new_owner_password, **kwargs)
            return data

    def put_change_password_document_with_http_info(self, out_path, owner_password, new_user_password, new_owner_password, **kwargs):
        """
        Change document password from content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_change_password_document_with_http_info(out_path, owner_password, new_user_password, new_owner_password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param str owner_password: Owner password (encrypted Base64). (required)
        :param str new_user_password: New user password (encrypted Base64). (required)
        :param str new_owner_password: New owner password (encrypted Base64). (required)
        :param str storage: The document storage.
        :param file file: A file to be changed password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'owner_password', 'new_user_password', 'new_owner_password', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_change_password_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_change_password_document`")
        # verify the required parameter 'owner_password' is set
        if ('owner_password' not in params) or (params['owner_password'] is None):
            raise ValueError("Missing the required parameter `owner_password` when calling `put_change_password_document`")
        # verify the required parameter 'new_user_password' is set
        if ('new_user_password' not in params) or (params['new_user_password'] is None):
            raise ValueError("Missing the required parameter `new_user_password` when calling `put_change_password_document`")
        # verify the required parameter 'new_owner_password' is set
        if ('new_owner_password' not in params) or (params['new_owner_password'] is None):
            raise ValueError("Missing the required parameter `new_owner_password` when calling `put_change_password_document`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'owner_password' in params:
            query_params.append(('ownerPassword', params['owner_password']))
        if 'new_user_password' in params:
            query_params.append(('newUserPassword', params['new_user_password']))
        if 'new_owner_password' in params:
            query_params.append(('newOwnerPassword', params['new_owner_password']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/changepassword', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_check_box_field(self, name, field_name, field, **kwargs):
        """
        Replace document checkbox field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_check_box_field(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param CheckBoxField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CheckBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_check_box_field_with_http_info(name, field_name, field, **kwargs)
        else:
            (data) = self.put_check_box_field_with_http_info(name, field_name, field, **kwargs)
            return data

    def put_check_box_field_with_http_info(self, name, field_name, field, **kwargs):
        """
        Replace document checkbox field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_check_box_field_with_http_info(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param CheckBoxField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CheckBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_check_box_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_check_box_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `put_check_box_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `put_check_box_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/checkbox/{fieldName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CheckBoxFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_circle_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document circle annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_circle_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param CircleAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CircleAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_circle_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_circle_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_circle_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document circle annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_circle_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param CircleAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: CircleAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_circle_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_circle_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_circle_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_circle_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/circle/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CircleAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_combo_box_field(self, name, field_name, field, **kwargs):
        """
        Replace document combobox field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_combo_box_field(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param ComboBoxField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ComboBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_combo_box_field_with_http_info(name, field_name, field, **kwargs)
        else:
            (data) = self.put_combo_box_field_with_http_info(name, field_name, field, **kwargs)
            return data

    def put_combo_box_field_with_http_info(self, name, field_name, field, **kwargs):
        """
        Replace document combobox field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_combo_box_field_with_http_info(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param ComboBoxField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ComboBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_combo_box_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_combo_box_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `put_combo_box_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `put_combo_box_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/combobox/{fieldName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ComboBoxFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_create_document(self, name, **kwargs):
        """
        Create empty document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_create_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The new document name. (required)
        :param str storage: The document storage.
        :param str folder: The new document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_create_document_with_http_info(name, **kwargs)
        else:
            (data) = self.put_create_document_with_http_info(name, **kwargs)
            return data

    def put_create_document_with_http_info(self, name, **kwargs):
        """
        Create empty document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_create_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The new document name. (required)
        :param str storage: The document storage.
        :param str folder: The new document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_create_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_create_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_decrypt_document(self, out_path, password, **kwargs):
        """
        Decrypt document from content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_decrypt_document(out_path, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param str password: The password (encrypted Base64). (required)
        :param str storage: The document storage.
        :param file file: A file to be decrypted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_decrypt_document_with_http_info(out_path, password, **kwargs)
        else:
            (data) = self.put_decrypt_document_with_http_info(out_path, password, **kwargs)
            return data

    def put_decrypt_document_with_http_info(self, out_path, password, **kwargs):
        """
        Decrypt document from content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_decrypt_document_with_http_info(out_path, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param str password: The password (encrypted Base64). (required)
        :param str storage: The document storage.
        :param file file: A file to be decrypted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'password', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_decrypt_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_decrypt_document`")
        # verify the required parameter 'password' is set
        if ('password' not in params) or (params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `put_decrypt_document`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'password' in params:
            query_params.append(('password', params['password']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/decrypt', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_document_display_properties(self, name, display_properties, **kwargs):
        """
        Update document display properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_document_display_properties(name, display_properties, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param DisplayProperties display_properties: The display properties. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DisplayPropertiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_document_display_properties_with_http_info(name, display_properties, **kwargs)
        else:
            (data) = self.put_document_display_properties_with_http_info(name, display_properties, **kwargs)
            return data

    def put_document_display_properties_with_http_info(self, name, display_properties, **kwargs):
        """
        Update document display properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_document_display_properties_with_http_info(name, display_properties, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param DisplayProperties display_properties: The display properties. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DisplayPropertiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'display_properties', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_document_display_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_document_display_properties`")
        # verify the required parameter 'display_properties' is set
        if ('display_properties' not in params) or (params['display_properties'] is None):
            raise ValueError("Missing the required parameter `display_properties` when calling `put_document_display_properties`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'display_properties' in params:
            body_params = params['display_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/displayproperties', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DisplayPropertiesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_encrypt_document(self, out_path, user_password, owner_password, crypto_algorithm, **kwargs):
        """
        Encrypt document from content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_encrypt_document(out_path, user_password, owner_password, crypto_algorithm, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param str user_password: User password (encrypted Base64). (required)
        :param str owner_password: Owner password (encrypted Base64). (required)
        :param str crypto_algorithm: Cryptographic algorithm, see CryptoAlgorithm for details. (required)
        :param list[PermissionsFlags] permissions_flags: Array of document permissions, see PermissionsFlags for details.
        :param bool use_pdf20: Support for revision 6 (Extension 8).
        :param str storage: The document storage.
        :param file file: A file to be encrypted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_encrypt_document_with_http_info(out_path, user_password, owner_password, crypto_algorithm, **kwargs)
        else:
            (data) = self.put_encrypt_document_with_http_info(out_path, user_password, owner_password, crypto_algorithm, **kwargs)
            return data

    def put_encrypt_document_with_http_info(self, out_path, user_password, owner_password, crypto_algorithm, **kwargs):
        """
        Encrypt document from content.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_encrypt_document_with_http_info(out_path, user_password, owner_password, crypto_algorithm, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param str user_password: User password (encrypted Base64). (required)
        :param str owner_password: Owner password (encrypted Base64). (required)
        :param str crypto_algorithm: Cryptographic algorithm, see CryptoAlgorithm for details. (required)
        :param list[PermissionsFlags] permissions_flags: Array of document permissions, see PermissionsFlags for details.
        :param bool use_pdf20: Support for revision 6 (Extension 8).
        :param str storage: The document storage.
        :param file file: A file to be encrypted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'user_password', 'owner_password', 'crypto_algorithm', 'permissions_flags', 'use_pdf20', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_encrypt_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_encrypt_document`")
        # verify the required parameter 'user_password' is set
        if ('user_password' not in params) or (params['user_password'] is None):
            raise ValueError("Missing the required parameter `user_password` when calling `put_encrypt_document`")
        # verify the required parameter 'owner_password' is set
        if ('owner_password' not in params) or (params['owner_password'] is None):
            raise ValueError("Missing the required parameter `owner_password` when calling `put_encrypt_document`")
        # verify the required parameter 'crypto_algorithm' is set
        if ('crypto_algorithm' not in params) or (params['crypto_algorithm'] is None):
            raise ValueError("Missing the required parameter `crypto_algorithm` when calling `put_encrypt_document`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'user_password' in params:
            query_params.append(('userPassword', params['user_password']))
        if 'owner_password' in params:
            query_params.append(('ownerPassword', params['owner_password']))
        if 'crypto_algorithm' in params:
            query_params.append(('cryptoAlgorithm', params['crypto_algorithm']))
        if 'permissions_flags' in params:
            query_params.append(('permissionsFlags', params['permissions_flags']))
            collection_formats['permissionsFlags'] = 'csv'
        if 'use_pdf20' in params:
            query_params.append(('usePdf20', params['use_pdf20']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/encrypt', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_epub_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert EPUB file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_epub_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.epub) (required)
        :param str storage: The document storage.
        :param str dst_folder: The destination document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_epub_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_epub_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_epub_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert EPUB file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_epub_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.epub) (required)
        :param str storage: The document storage.
        :param str dst_folder: The destination document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'storage', 'dst_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_epub_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_epub_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_epub_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/epub', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_export_fields_from_pdf_to_fdf_in_storage(self, name, fdf_output_file_path, **kwargs):
        """
        Export fields from from PDF in storage to FDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_export_fields_from_pdf_to_fdf_in_storage(name, fdf_output_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str fdf_output_file_path: The output Fdf file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_export_fields_from_pdf_to_fdf_in_storage_with_http_info(name, fdf_output_file_path, **kwargs)
        else:
            (data) = self.put_export_fields_from_pdf_to_fdf_in_storage_with_http_info(name, fdf_output_file_path, **kwargs)
            return data

    def put_export_fields_from_pdf_to_fdf_in_storage_with_http_info(self, name, fdf_output_file_path, **kwargs):
        """
        Export fields from from PDF in storage to FDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_export_fields_from_pdf_to_fdf_in_storage_with_http_info(name, fdf_output_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str fdf_output_file_path: The output Fdf file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fdf_output_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_export_fields_from_pdf_to_fdf_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_export_fields_from_pdf_to_fdf_in_storage`")
        # verify the required parameter 'fdf_output_file_path' is set
        if ('fdf_output_file_path' not in params) or (params['fdf_output_file_path'] is None):
            raise ValueError("Missing the required parameter `fdf_output_file_path` when calling `put_export_fields_from_pdf_to_fdf_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'fdf_output_file_path' in params:
            query_params.append(('fdfOutputFilePath', params['fdf_output_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/export/fdf', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_export_fields_from_pdf_to_xfdf_in_storage(self, name, xfdf_output_file_path, **kwargs):
        """
        Export fields from from PDF in storage to XFDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_export_fields_from_pdf_to_xfdf_in_storage(name, xfdf_output_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xfdf_output_file_path: The output xfdf file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_export_fields_from_pdf_to_xfdf_in_storage_with_http_info(name, xfdf_output_file_path, **kwargs)
        else:
            (data) = self.put_export_fields_from_pdf_to_xfdf_in_storage_with_http_info(name, xfdf_output_file_path, **kwargs)
            return data

    def put_export_fields_from_pdf_to_xfdf_in_storage_with_http_info(self, name, xfdf_output_file_path, **kwargs):
        """
        Export fields from from PDF in storage to XFDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_export_fields_from_pdf_to_xfdf_in_storage_with_http_info(name, xfdf_output_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xfdf_output_file_path: The output xfdf file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'xfdf_output_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_export_fields_from_pdf_to_xfdf_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_export_fields_from_pdf_to_xfdf_in_storage`")
        # verify the required parameter 'xfdf_output_file_path' is set
        if ('xfdf_output_file_path' not in params) or (params['xfdf_output_file_path'] is None):
            raise ValueError("Missing the required parameter `xfdf_output_file_path` when calling `put_export_fields_from_pdf_to_xfdf_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'xfdf_output_file_path' in params:
            query_params.append(('xfdfOutputFilePath', params['xfdf_output_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/export/xfdf', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_export_fields_from_pdf_to_xml_in_storage(self, name, xml_output_file_path, **kwargs):
        """
        Export fields from from PDF in storage to XML file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_export_fields_from_pdf_to_xml_in_storage(name, xml_output_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xml_output_file_path: The output xml file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_export_fields_from_pdf_to_xml_in_storage_with_http_info(name, xml_output_file_path, **kwargs)
        else:
            (data) = self.put_export_fields_from_pdf_to_xml_in_storage_with_http_info(name, xml_output_file_path, **kwargs)
            return data

    def put_export_fields_from_pdf_to_xml_in_storage_with_http_info(self, name, xml_output_file_path, **kwargs):
        """
        Export fields from from PDF in storage to XML file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_export_fields_from_pdf_to_xml_in_storage_with_http_info(name, xml_output_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xml_output_file_path: The output xml file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'xml_output_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_export_fields_from_pdf_to_xml_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_export_fields_from_pdf_to_xml_in_storage`")
        # verify the required parameter 'xml_output_file_path' is set
        if ('xml_output_file_path' not in params) or (params['xml_output_file_path'] is None):
            raise ValueError("Missing the required parameter `xml_output_file_path` when calling `put_export_fields_from_pdf_to_xml_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'xml_output_file_path' in params:
            query_params.append(('xmlOutputFilePath', params['xml_output_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/export/xml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_fields_flatten(self, name, **kwargs):
        """
        Flatten form fields in document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_fields_flatten(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_fields_flatten_with_http_info(name, **kwargs)
        else:
            (data) = self.put_fields_flatten_with_http_info(name, **kwargs)
            return data

    def put_fields_flatten_with_http_info(self, name, **kwargs):
        """
        Flatten form fields in document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_fields_flatten_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_fields_flatten" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_fields_flatten`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/flatten', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_file_attachment_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document FileAttachment annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_file_attachment_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param FileAttachmentAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FileAttachmentAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_file_attachment_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_file_attachment_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_file_attachment_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document FileAttachment annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_file_attachment_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param FileAttachmentAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FileAttachmentAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_file_attachment_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_file_attachment_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_file_attachment_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_file_attachment_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/fileattachment/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FileAttachmentAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_file_attachment_annotation_data_extract(self, name, annotation_id, **kwargs):
        """
        Extract document FileAttachment annotation content to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_file_attachment_annotation_data_extract(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str out_folder: The output folder.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_file_attachment_annotation_data_extract_with_http_info(name, annotation_id, **kwargs)
        else:
            (data) = self.put_file_attachment_annotation_data_extract_with_http_info(name, annotation_id, **kwargs)
            return data

    def put_file_attachment_annotation_data_extract_with_http_info(self, name, annotation_id, **kwargs):
        """
        Extract document FileAttachment annotation content to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_file_attachment_annotation_data_extract_with_http_info(name, annotation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str out_folder: The output folder.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'out_folder', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_file_attachment_annotation_data_extract" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_file_attachment_annotation_data_extract`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_file_attachment_annotation_data_extract`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'out_folder' in params:
            query_params.append(('outFolder', params['out_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/fileattachment/{annotationId}/data/extract', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_free_text_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document free text annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_free_text_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param FreeTextAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FreeTextAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_free_text_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_free_text_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_free_text_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document free text annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_free_text_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param FreeTextAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FreeTextAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_free_text_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_free_text_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_free_text_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_free_text_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/freetext/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FreeTextAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_highlight_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document highlight annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_highlight_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param HighlightAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: HighlightAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_highlight_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_highlight_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_highlight_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document highlight annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_highlight_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param HighlightAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: HighlightAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_highlight_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_highlight_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_highlight_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_highlight_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/highlight/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='HighlightAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_html_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert HTML file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_html_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.zip) (required)
        :param str html_file_name: Name of HTML file in ZIP.
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_html_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_html_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_html_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert HTML file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_html_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.zip) (required)
        :param str html_file_name: Name of HTML file in ZIP.
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'html_file_name', 'height', 'width', 'is_landscape', 'margin_left', 'margin_bottom', 'margin_right', 'margin_top', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_html_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_html_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_html_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'html_file_name' in params:
            query_params.append(('htmlFileName', params['html_file_name']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'is_landscape' in params:
            query_params.append(('isLandscape', params['is_landscape']))
        if 'margin_left' in params:
            query_params.append(('marginLeft', params['margin_left']))
        if 'margin_bottom' in params:
            query_params.append(('marginBottom', params['margin_bottom']))
        if 'margin_right' in params:
            query_params.append(('marginRight', params['margin_right']))
        if 'margin_top' in params:
            query_params.append(('marginTop', params['margin_top']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/html', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_image_extract_as_gif(self, name, image_id, **kwargs):
        """
        Extract document image in GIF format to folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_extract_as_gif(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_image_extract_as_gif_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.put_image_extract_as_gif_with_http_info(name, image_id, **kwargs)
            return data

    def put_image_extract_as_gif_with_http_info(self, name, image_id, **kwargs):
        """
        Extract document image in GIF format to folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_extract_as_gif_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'width', 'height', 'storage', 'folder', 'dest_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_extract_as_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_image_extract_as_gif`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_image_extract_as_gif`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'dest_folder' in params:
            query_params.append(('destFolder', params['dest_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}/extract/gif', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_image_extract_as_jpeg(self, name, image_id, **kwargs):
        """
        Extract document image in JPEG format to folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_extract_as_jpeg(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_image_extract_as_jpeg_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.put_image_extract_as_jpeg_with_http_info(name, image_id, **kwargs)
            return data

    def put_image_extract_as_jpeg_with_http_info(self, name, image_id, **kwargs):
        """
        Extract document image in JPEG format to folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_extract_as_jpeg_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'width', 'height', 'storage', 'folder', 'dest_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_extract_as_jpeg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_image_extract_as_jpeg`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_image_extract_as_jpeg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'dest_folder' in params:
            query_params.append(('destFolder', params['dest_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}/extract/jpeg', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_image_extract_as_png(self, name, image_id, **kwargs):
        """
        Extract document image in PNG format to folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_extract_as_png(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_image_extract_as_png_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.put_image_extract_as_png_with_http_info(name, image_id, **kwargs)
            return data

    def put_image_extract_as_png_with_http_info(self, name, image_id, **kwargs):
        """
        Extract document image in PNG format to folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_extract_as_png_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'width', 'height', 'storage', 'folder', 'dest_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_extract_as_png" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_image_extract_as_png`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_image_extract_as_png`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'dest_folder' in params:
            query_params.append(('destFolder', params['dest_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}/extract/png', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_image_extract_as_tiff(self, name, image_id, **kwargs):
        """
        Extract document image in TIFF format to folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_extract_as_tiff(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_image_extract_as_tiff_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.put_image_extract_as_tiff_with_http_info(name, image_id, **kwargs)
            return data

    def put_image_extract_as_tiff_with_http_info(self, name, image_id, **kwargs):
        """
        Extract document image in TIFF format to folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_extract_as_tiff_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: Image ID. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'width', 'height', 'storage', 'folder', 'dest_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_extract_as_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_image_extract_as_tiff`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_image_extract_as_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'dest_folder' in params:
            query_params.append(('destFolder', params['dest_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}/extract/tiff', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_image_in_storage_to_pdf(self, name, image_templates, **kwargs):
        """
        Convert image file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_in_storage_to_pdf(name, image_templates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param ImageTemplatesRequest image_templates: ImageTemplatesRequestImage templates (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_image_in_storage_to_pdf_with_http_info(name, image_templates, **kwargs)
        else:
            (data) = self.put_image_in_storage_to_pdf_with_http_info(name, image_templates, **kwargs)
            return data

    def put_image_in_storage_to_pdf_with_http_info(self, name, image_templates, **kwargs):
        """
        Convert image file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_image_in_storage_to_pdf_with_http_info(name, image_templates, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param ImageTemplatesRequest image_templates: ImageTemplatesRequestImage templates (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_templates', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_image_in_storage_to_pdf`")
        # verify the required parameter 'image_templates' is set
        if ('image_templates' not in params) or (params['image_templates'] is None):
            raise ValueError("Missing the required parameter `image_templates` when calling `put_image_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'image_templates' in params:
            body_params = params['image_templates']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/images', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_images_extract_as_gif(self, name, page_number, **kwargs):
        """
        Extract document images in GIF format to folder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_images_extract_as_gif(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_images_extract_as_gif_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.put_images_extract_as_gif_with_http_info(name, page_number, **kwargs)
            return data

    def put_images_extract_as_gif_with_http_info(self, name, page_number, **kwargs):
        """
        Extract document images in GIF format to folder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_images_extract_as_gif_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'storage', 'folder', 'dest_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_images_extract_as_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_images_extract_as_gif`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_images_extract_as_gif`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'dest_folder' in params:
            query_params.append(('destFolder', params['dest_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images/extract/gif', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_images_extract_as_jpeg(self, name, page_number, **kwargs):
        """
        Extract document images in JPEG format to folder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_images_extract_as_jpeg(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_images_extract_as_jpeg_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.put_images_extract_as_jpeg_with_http_info(name, page_number, **kwargs)
            return data

    def put_images_extract_as_jpeg_with_http_info(self, name, page_number, **kwargs):
        """
        Extract document images in JPEG format to folder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_images_extract_as_jpeg_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'storage', 'folder', 'dest_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_images_extract_as_jpeg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_images_extract_as_jpeg`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_images_extract_as_jpeg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'dest_folder' in params:
            query_params.append(('destFolder', params['dest_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images/extract/jpeg', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_images_extract_as_png(self, name, page_number, **kwargs):
        """
        Extract document images in PNG format to folder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_images_extract_as_png(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_images_extract_as_png_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.put_images_extract_as_png_with_http_info(name, page_number, **kwargs)
            return data

    def put_images_extract_as_png_with_http_info(self, name, page_number, **kwargs):
        """
        Extract document images in PNG format to folder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_images_extract_as_png_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'storage', 'folder', 'dest_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_images_extract_as_png" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_images_extract_as_png`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_images_extract_as_png`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'dest_folder' in params:
            query_params.append(('destFolder', params['dest_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images/extract/png', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_images_extract_as_tiff(self, name, page_number, **kwargs):
        """
        Extract document images in TIFF format to folder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_images_extract_as_tiff(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_images_extract_as_tiff_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.put_images_extract_as_tiff_with_http_info(name, page_number, **kwargs)
            return data

    def put_images_extract_as_tiff_with_http_info(self, name, page_number, **kwargs):
        """
        Extract document images in TIFF format to folder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_images_extract_as_tiff_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str dest_folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'width', 'height', 'storage', 'folder', 'dest_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_images_extract_as_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_images_extract_as_tiff`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_images_extract_as_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'dest_folder' in params:
            query_params.append(('destFolder', params['dest_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images/extract/tiff', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_import_fields_from_fdf_in_storage(self, name, fdf_file_path, **kwargs):
        """
        Update fields from FDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_import_fields_from_fdf_in_storage(name, fdf_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str fdf_file_path: The Fdf file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_import_fields_from_fdf_in_storage_with_http_info(name, fdf_file_path, **kwargs)
        else:
            (data) = self.put_import_fields_from_fdf_in_storage_with_http_info(name, fdf_file_path, **kwargs)
            return data

    def put_import_fields_from_fdf_in_storage_with_http_info(self, name, fdf_file_path, **kwargs):
        """
        Update fields from FDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_import_fields_from_fdf_in_storage_with_http_info(name, fdf_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str fdf_file_path: The Fdf file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fdf_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_import_fields_from_fdf_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_import_fields_from_fdf_in_storage`")
        # verify the required parameter 'fdf_file_path' is set
        if ('fdf_file_path' not in params) or (params['fdf_file_path'] is None):
            raise ValueError("Missing the required parameter `fdf_file_path` when calling `put_import_fields_from_fdf_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'fdf_file_path' in params:
            query_params.append(('fdfFilePath', params['fdf_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/fdf', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_import_fields_from_xfdf_in_storage(self, name, xfdf_file_path, **kwargs):
        """
        Update fields from XFDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_import_fields_from_xfdf_in_storage(name, xfdf_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xfdf_file_path: The XFDF file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_import_fields_from_xfdf_in_storage_with_http_info(name, xfdf_file_path, **kwargs)
        else:
            (data) = self.put_import_fields_from_xfdf_in_storage_with_http_info(name, xfdf_file_path, **kwargs)
            return data

    def put_import_fields_from_xfdf_in_storage_with_http_info(self, name, xfdf_file_path, **kwargs):
        """
        Update fields from XFDF file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_import_fields_from_xfdf_in_storage_with_http_info(name, xfdf_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xfdf_file_path: The XFDF file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'xfdf_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_import_fields_from_xfdf_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_import_fields_from_xfdf_in_storage`")
        # verify the required parameter 'xfdf_file_path' is set
        if ('xfdf_file_path' not in params) or (params['xfdf_file_path'] is None):
            raise ValueError("Missing the required parameter `xfdf_file_path` when calling `put_import_fields_from_xfdf_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'xfdf_file_path' in params:
            query_params.append(('xfdfFilePath', params['xfdf_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/xfdf', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_import_fields_from_xml_in_storage(self, name, xml_file_path, **kwargs):
        """
        Update fields from XML file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_import_fields_from_xml_in_storage(name, xml_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xml_file_path: Full source filename (ex. /folder1/folder2/template.xml) (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_import_fields_from_xml_in_storage_with_http_info(name, xml_file_path, **kwargs)
        else:
            (data) = self.put_import_fields_from_xml_in_storage_with_http_info(name, xml_file_path, **kwargs)
            return data

    def put_import_fields_from_xml_in_storage_with_http_info(self, name, xml_file_path, **kwargs):
        """
        Update fields from XML file in storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_import_fields_from_xml_in_storage_with_http_info(name, xml_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str xml_file_path: Full source filename (ex. /folder1/folder2/template.xml) (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'xml_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_import_fields_from_xml_in_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_import_fields_from_xml_in_storage`")
        # verify the required parameter 'xml_file_path' is set
        if ('xml_file_path' not in params) or (params['xml_file_path'] is None):
            raise ValueError("Missing the required parameter `xml_file_path` when calling `put_import_fields_from_xml_in_storage`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'xml_file_path' in params:
            query_params.append(('xmlFilePath', params['xml_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/import/xml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_ink_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document ink annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_ink_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param InkAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: InkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_ink_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_ink_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_ink_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document ink annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_ink_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param InkAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: InkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ink_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ink_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_ink_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_ink_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/ink/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InkAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_line_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document line annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_line_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param LineAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_line_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_line_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_line_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document line annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_line_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param LineAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_line_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_line_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_line_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_line_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/line/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LineAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_link_annotation(self, name, link_id, link, **kwargs):
        """
        Replace document page link annotations
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_link_annotation(name, link_id, link, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str link_id: The link ID. (required)
        :param LinkAnnotation link: Link annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_link_annotation_with_http_info(name, link_id, link, **kwargs)
        else:
            (data) = self.put_link_annotation_with_http_info(name, link_id, link, **kwargs)
            return data

    def put_link_annotation_with_http_info(self, name, link_id, link, **kwargs):
        """
        Replace document page link annotations
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_link_annotation_with_http_info(name, link_id, link, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str link_id: The link ID. (required)
        :param LinkAnnotation link: Link annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'link_id', 'link', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_link_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_link_annotation`")
        # verify the required parameter 'link_id' is set
        if ('link_id' not in params) or (params['link_id'] is None):
            raise ValueError("Missing the required parameter `link_id` when calling `put_link_annotation`")
        # verify the required parameter 'link' is set
        if ('link' not in params) or (params['link'] is None):
            raise ValueError("Missing the required parameter `link` when calling `put_link_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'link_id' in params:
            path_params['linkId'] = params['link_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'link' in params:
            body_params = params['link']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/links/{linkId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LinkAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_list_box_field(self, name, field_name, field, **kwargs):
        """
        Replace document listbox field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_list_box_field(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param ListBoxField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ListBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_list_box_field_with_http_info(name, field_name, field, **kwargs)
        else:
            (data) = self.put_list_box_field_with_http_info(name, field_name, field, **kwargs)
            return data

    def put_list_box_field_with_http_info(self, name, field_name, field, **kwargs):
        """
        Replace document listbox field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_list_box_field_with_http_info(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param ListBoxField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ListBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_list_box_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_list_box_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `put_list_box_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `put_list_box_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/listbox/{fieldName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListBoxFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_markdown_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert MD file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_markdown_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.md) (required)
        :param str storage: The document storage.
        :param str dst_folder: The destination document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_markdown_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_markdown_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_markdown_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert MD file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_markdown_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.md) (required)
        :param str storage: The document storage.
        :param str dst_folder: The destination document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'storage', 'dst_folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_markdown_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_markdown_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_markdown_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/markdown', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_merge_documents(self, name, merge_documents, **kwargs):
        """
        Merge a list of documents.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_merge_documents(name, merge_documents, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Resulting document name. (required)
        :param MergeDocuments merge_documents: MergeDocuments with a list of documents. (required)
        :param str storage: Resulting document storage.
        :param str folder: Resulting document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_merge_documents_with_http_info(name, merge_documents, **kwargs)
        else:
            (data) = self.put_merge_documents_with_http_info(name, merge_documents, **kwargs)
            return data

    def put_merge_documents_with_http_info(self, name, merge_documents, **kwargs):
        """
        Merge a list of documents.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_merge_documents_with_http_info(name, merge_documents, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Resulting document name. (required)
        :param MergeDocuments merge_documents: MergeDocuments with a list of documents. (required)
        :param str storage: Resulting document storage.
        :param str folder: Resulting document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'merge_documents', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_merge_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_merge_documents`")
        # verify the required parameter 'merge_documents' is set
        if ('merge_documents' not in params) or (params['merge_documents'] is None):
            raise ValueError("Missing the required parameter `merge_documents` when calling `put_merge_documents`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'merge_documents' in params:
            body_params = params['merge_documents']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/merge', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_mht_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert MHT file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_mht_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.mht) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_mht_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_mht_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_mht_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert MHT file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_mht_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.mht) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_mht_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_mht_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_mht_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/mht', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_movie_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document movie annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_movie_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param MovieAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: MovieAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_movie_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_movie_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_movie_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document movie annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_movie_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param MovieAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: MovieAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_movie_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_movie_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_movie_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_movie_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/movie/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='MovieAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_page_add_stamp(self, name, page_number, stamp, **kwargs):
        """
        Add page stamp.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_add_stamp(name, page_number, stamp, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Stamp stamp: Stamp with data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_page_add_stamp_with_http_info(name, page_number, stamp, **kwargs)
        else:
            (data) = self.put_page_add_stamp_with_http_info(name, page_number, stamp, **kwargs)
            return data

    def put_page_add_stamp_with_http_info(self, name, page_number, stamp, **kwargs):
        """
        Add page stamp.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_add_stamp_with_http_info(name, page_number, stamp, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Stamp stamp: Stamp with data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'stamp', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_page_add_stamp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_page_add_stamp`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_page_add_stamp`")
        # verify the required parameter 'stamp' is set
        if ('stamp' not in params) or (params['stamp'] is None):
            raise ValueError("Missing the required parameter `stamp` when calling `put_page_add_stamp`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stamp' in params:
            body_params = params['stamp']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/stamp', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_page_convert_to_bmp(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to bmp image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_bmp(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_page_convert_to_bmp_with_http_info(name, page_number, out_path, **kwargs)
        else:
            (data) = self.put_page_convert_to_bmp_with_http_info(name, page_number, out_path, **kwargs)
            return data

    def put_page_convert_to_bmp_with_http_info(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to bmp image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_bmp_with_http_info(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'out_path', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_page_convert_to_bmp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_page_convert_to_bmp`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_page_convert_to_bmp`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_page_convert_to_bmp`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/bmp', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_page_convert_to_emf(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to emf image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_emf(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_page_convert_to_emf_with_http_info(name, page_number, out_path, **kwargs)
        else:
            (data) = self.put_page_convert_to_emf_with_http_info(name, page_number, out_path, **kwargs)
            return data

    def put_page_convert_to_emf_with_http_info(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to emf image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_emf_with_http_info(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'out_path', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_page_convert_to_emf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_page_convert_to_emf`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_page_convert_to_emf`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_page_convert_to_emf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/emf', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_page_convert_to_gif(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to gif image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_gif(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_page_convert_to_gif_with_http_info(name, page_number, out_path, **kwargs)
        else:
            (data) = self.put_page_convert_to_gif_with_http_info(name, page_number, out_path, **kwargs)
            return data

    def put_page_convert_to_gif_with_http_info(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to gif image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_gif_with_http_info(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'out_path', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_page_convert_to_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_page_convert_to_gif`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_page_convert_to_gif`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_page_convert_to_gif`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/gif', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_page_convert_to_jpeg(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to Jpeg image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_jpeg(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_page_convert_to_jpeg_with_http_info(name, page_number, out_path, **kwargs)
        else:
            (data) = self.put_page_convert_to_jpeg_with_http_info(name, page_number, out_path, **kwargs)
            return data

    def put_page_convert_to_jpeg_with_http_info(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to Jpeg image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_jpeg_with_http_info(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'out_path', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_page_convert_to_jpeg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_page_convert_to_jpeg`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_page_convert_to_jpeg`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_page_convert_to_jpeg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/jpeg', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_page_convert_to_png(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to png image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_png(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_page_convert_to_png_with_http_info(name, page_number, out_path, **kwargs)
        else:
            (data) = self.put_page_convert_to_png_with_http_info(name, page_number, out_path, **kwargs)
            return data

    def put_page_convert_to_png_with_http_info(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to png image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_png_with_http_info(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'out_path', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_page_convert_to_png" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_page_convert_to_png`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_page_convert_to_png`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_page_convert_to_png`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/png', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_page_convert_to_tiff(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to Tiff image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_tiff(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_page_convert_to_tiff_with_http_info(name, page_number, out_path, **kwargs)
        else:
            (data) = self.put_page_convert_to_tiff_with_http_info(name, page_number, out_path, **kwargs)
            return data

    def put_page_convert_to_tiff_with_http_info(self, name, page_number, out_path, **kwargs):
        """
        Convert document page to Tiff image and upload resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_convert_to_tiff_with_http_info(name, page_number, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str out_path: The out path of result image. (required)
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'out_path', 'width', 'height', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_page_convert_to_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_page_convert_to_tiff`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_page_convert_to_tiff`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_page_convert_to_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/convert/tiff', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pcl_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert PCL file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pcl_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.pcl) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pcl_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_pcl_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_pcl_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert PCL file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pcl_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.pcl) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pcl_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pcl_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_pcl_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/pcl', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_a_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert PDFA file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_a_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.pdf) (required)
        :param str dst_folder: The destination document folder.
        :param bool dont_optimize: If set, document resources will not be optimized.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_a_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_pdf_a_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_pdf_a_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert PDFA file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_a_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.pdf) (required)
        :param str dst_folder: The destination document folder.
        :param bool dont_optimize: If set, document resources will not be optimized.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'dst_folder', 'dont_optimize', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_a_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_a_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_pdf_a_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'dont_optimize' in params:
            query_params.append(('dontOptimize', params['dont_optimize']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/pdfa', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_doc(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_doc(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param float max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_doc_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_doc_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_doc_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_doc_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param float max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'add_return_to_line_end', 'format', 'image_resolution_x', 'image_resolution_y', 'max_distance_between_text_lines', 'mode', 'recognize_bullets', 'relative_horizontal_proximity', 'storage', 'password', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_doc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_doc`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'add_return_to_line_end' in params:
            query_params.append(('addReturnToLineEnd', params['add_return_to_line_end']))
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'image_resolution_x' in params:
            query_params.append(('imageResolutionX', params['image_resolution_x']))
        if 'image_resolution_y' in params:
            query_params.append(('imageResolutionY', params['image_resolution_y']))
        if 'max_distance_between_text_lines' in params:
            query_params.append(('maxDistanceBetweenTextLines', params['max_distance_between_text_lines']))
        if 'mode' in params:
            query_params.append(('mode', params['mode']))
        if 'recognize_bullets' in params:
            query_params.append(('recognizeBullets', params['recognize_bullets']))
        if 'relative_horizontal_proximity' in params:
            query_params.append(('relativeHorizontalProximity', params['relative_horizontal_proximity']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/doc', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_epub(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_epub(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.epub) (required)
        :param str content_recognition_mode: Property tunes conversion for this or that desirable method of recognition of content.
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_epub_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_epub_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_epub_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_epub_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.epub) (required)
        :param str content_recognition_mode: Property tunes conversion for this or that desirable method of recognition of content.
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'content_recognition_mode', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_epub" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_epub`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'content_recognition_mode' in params:
            query_params.append(('contentRecognitionMode', params['content_recognition_mode']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/epub', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_html(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to Html format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_html(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.html) (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param str document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str storage: The document storage.
        :param bool flow_layout_paragraph_full_width: This attribute specifies full width paragraph text for Flow mode, FixedLayout = false.
        :param str output_format: This parameter determines the type of result. The zip archive will be uploaded into the storage if the parameter is \"Zip\" or missed (default). In case of the \"Folder\", all resulting files and directories will be uploaded to the folder of the resulting HTML file.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_html_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_html_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_html_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to Html format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_html_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.html) (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param str document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str storage: The document storage.
        :param bool flow_layout_paragraph_full_width: This attribute specifies full width paragraph text for Flow mode, FixedLayout = false.
        :param str output_format: This parameter determines the type of result. The zip archive will be uploaded into the storage if the parameter is \"Zip\" or missed (default). In case of the \"Folder\", all resulting files and directories will be uploaded to the folder of the resulting HTML file.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'additional_margin_width_in_points', 'compress_svg_graphics_if_any', 'convert_marked_content_to_layers', 'default_font_name', 'document_type', 'fixed_layout', 'image_resolution', 'minimal_line_width', 'prevent_glyphs_grouping', 'split_css_into_pages', 'split_into_pages', 'use_z_order', 'antialiasing_processing', 'css_class_names_prefix', 'explicit_list_of_saved_pages', 'font_encoding_strategy', 'font_saving_mode', 'html_markup_generation_mode', 'letters_positioning_method', 'pages_flow_type_depends_on_viewers_screen_size', 'parts_embedding_mode', 'raster_images_saving_mode', 'remove_empty_areas_on_top_and_bottom', 'save_shadowed_texts_as_transparent_texts', 'save_transparent_texts', 'special_folder_for_all_images', 'special_folder_for_svg_images', 'try_save_text_underlining_and_strikeouting_in_css', 'storage', 'flow_layout_paragraph_full_width', 'output_format', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_html" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_html`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'additional_margin_width_in_points' in params:
            query_params.append(('additionalMarginWidthInPoints', params['additional_margin_width_in_points']))
        if 'compress_svg_graphics_if_any' in params:
            query_params.append(('compressSvgGraphicsIfAny', params['compress_svg_graphics_if_any']))
        if 'convert_marked_content_to_layers' in params:
            query_params.append(('convertMarkedContentToLayers', params['convert_marked_content_to_layers']))
        if 'default_font_name' in params:
            query_params.append(('defaultFontName', params['default_font_name']))
        if 'document_type' in params:
            query_params.append(('documentType', params['document_type']))
        if 'fixed_layout' in params:
            query_params.append(('fixedLayout', params['fixed_layout']))
        if 'image_resolution' in params:
            query_params.append(('imageResolution', params['image_resolution']))
        if 'minimal_line_width' in params:
            query_params.append(('minimalLineWidth', params['minimal_line_width']))
        if 'prevent_glyphs_grouping' in params:
            query_params.append(('preventGlyphsGrouping', params['prevent_glyphs_grouping']))
        if 'split_css_into_pages' in params:
            query_params.append(('splitCssIntoPages', params['split_css_into_pages']))
        if 'split_into_pages' in params:
            query_params.append(('splitIntoPages', params['split_into_pages']))
        if 'use_z_order' in params:
            query_params.append(('useZOrder', params['use_z_order']))
        if 'antialiasing_processing' in params:
            query_params.append(('antialiasingProcessing', params['antialiasing_processing']))
        if 'css_class_names_prefix' in params:
            query_params.append(('cssClassNamesPrefix', params['css_class_names_prefix']))
        if 'explicit_list_of_saved_pages' in params:
            query_params.append(('explicitListOfSavedPages', params['explicit_list_of_saved_pages']))
            collection_formats['explicitListOfSavedPages'] = 'csv'
        if 'font_encoding_strategy' in params:
            query_params.append(('fontEncodingStrategy', params['font_encoding_strategy']))
        if 'font_saving_mode' in params:
            query_params.append(('fontSavingMode', params['font_saving_mode']))
        if 'html_markup_generation_mode' in params:
            query_params.append(('htmlMarkupGenerationMode', params['html_markup_generation_mode']))
        if 'letters_positioning_method' in params:
            query_params.append(('lettersPositioningMethod', params['letters_positioning_method']))
        if 'pages_flow_type_depends_on_viewers_screen_size' in params:
            query_params.append(('pagesFlowTypeDependsOnViewersScreenSize', params['pages_flow_type_depends_on_viewers_screen_size']))
        if 'parts_embedding_mode' in params:
            query_params.append(('partsEmbeddingMode', params['parts_embedding_mode']))
        if 'raster_images_saving_mode' in params:
            query_params.append(('rasterImagesSavingMode', params['raster_images_saving_mode']))
        if 'remove_empty_areas_on_top_and_bottom' in params:
            query_params.append(('removeEmptyAreasOnTopAndBottom', params['remove_empty_areas_on_top_and_bottom']))
        if 'save_shadowed_texts_as_transparent_texts' in params:
            query_params.append(('saveShadowedTextsAsTransparentTexts', params['save_shadowed_texts_as_transparent_texts']))
        if 'save_transparent_texts' in params:
            query_params.append(('saveTransparentTexts', params['save_transparent_texts']))
        if 'special_folder_for_all_images' in params:
            query_params.append(('specialFolderForAllImages', params['special_folder_for_all_images']))
        if 'special_folder_for_svg_images' in params:
            query_params.append(('specialFolderForSvgImages', params['special_folder_for_svg_images']))
        if 'try_save_text_underlining_and_strikeouting_in_css' in params:
            query_params.append(('trySaveTextUnderliningAndStrikeoutingInCss', params['try_save_text_underlining_and_strikeouting_in_css']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'flow_layout_paragraph_full_width' in params:
            query_params.append(('flowLayoutParagraphFullWidth', params['flow_layout_paragraph_full_width']))
        if 'output_format' in params:
            query_params.append(('outputFormat', params['output_format']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/html', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_mobi_xml(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to MOBIXML format and uploads resulting ZIP archive file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_mobi_xml(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_mobi_xml_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_mobi_xml_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_mobi_xml_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to MOBIXML format and uploads resulting ZIP archive file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_mobi_xml_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_mobi_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_mobi_xml`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/mobixml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_pdf_a(self, out_path, type, **kwargs):
        """
        Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_pdf_a(out_path, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str type: Type of PdfA format. (required)
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_pdf_a_with_http_info(out_path, type, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_pdf_a_with_http_info(out_path, type, **kwargs)
            return data

    def put_pdf_in_request_to_pdf_a_with_http_info(self, out_path, type, **kwargs):
        """
        Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_pdf_a_with_http_info(out_path, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str type: Type of PdfA format. (required)
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'type', 'storage', 'password', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_pdf_a" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_pdf_a`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_pdf_in_request_to_pdf_a`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'type' in params:
            query_params.append(('type', params['type']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/pdfa', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_pptx(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_pptx(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str storage: The document storage.
        :param str password: Base64 encoded password.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_pptx_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_pptx_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_pptx_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_pptx_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str storage: The document storage.
        :param str password: Base64 encoded password.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'separate_images', 'slides_as_images', 'storage', 'password', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_pptx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_pptx`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'separate_images' in params:
            query_params.append(('separateImages', params['separate_images']))
        if 'slides_as_images' in params:
            query_params.append(('slidesAsImages', params['slides_as_images']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/pptx', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_svg(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_svg(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.svg) (required)
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_svg_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_svg_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_svg_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_svg_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.svg) (required)
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'storage', 'password', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_svg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_svg`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/svg', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_te_x(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to TeX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_te_x(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tex) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_te_x_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_te_x_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_te_x_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to TeX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_te_x_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tex) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_te_x" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_te_x`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/tex', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_tiff(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_tiff(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_tiff_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_tiff_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_tiff_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_tiff_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'brightness', 'compression', 'color_depth', 'left_margin', 'right_margin', 'top_margin', 'bottom_margin', 'orientation', 'skip_blank_pages', 'width', 'height', 'x_resolution', 'y_resolution', 'page_index', 'page_count', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_tiff`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'brightness' in params:
            query_params.append(('brightness', params['brightness']))
        if 'compression' in params:
            query_params.append(('compression', params['compression']))
        if 'color_depth' in params:
            query_params.append(('colorDepth', params['color_depth']))
        if 'left_margin' in params:
            query_params.append(('leftMargin', params['left_margin']))
        if 'right_margin' in params:
            query_params.append(('rightMargin', params['right_margin']))
        if 'top_margin' in params:
            query_params.append(('topMargin', params['top_margin']))
        if 'bottom_margin' in params:
            query_params.append(('bottomMargin', params['bottom_margin']))
        if 'orientation' in params:
            query_params.append(('orientation', params['orientation']))
        if 'skip_blank_pages' in params:
            query_params.append(('skipBlankPages', params['skip_blank_pages']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'x_resolution' in params:
            query_params.append(('xResolution', params['x_resolution']))
        if 'y_resolution' in params:
            query_params.append(('yResolution', params['y_resolution']))
        if 'page_index' in params:
            query_params.append(('pageIndex', params['page_index']))
        if 'page_count' in params:
            query_params.append(('pageCount', params['page_count']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/tiff', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_xls(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xls(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xls) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_xls_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_xls_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_xls_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xls_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xls) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'storage', 'password', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_xls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_xls`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/xls', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_xlsx(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XLSX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xlsx(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_xlsx_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_xlsx_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_xlsx_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XLSX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xlsx_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'storage', 'password', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_xlsx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_xlsx`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/xlsx', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_xml(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XML format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xml(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xml) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_xml_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_xml_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_xml_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XML format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xml_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xml) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_xml`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/xml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_xps(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xps(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xps) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_xps_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_xps_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_xps_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xps_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xps) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_xps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_xps`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/xps', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_doc(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to DOC format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_doc(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param float max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_doc_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_doc_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_doc_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to DOC format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_doc_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param float max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'add_return_to_line_end', 'format', 'image_resolution_x', 'image_resolution_y', 'max_distance_between_text_lines', 'mode', 'recognize_bullets', 'relative_horizontal_proximity', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_doc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_doc`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_doc`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'add_return_to_line_end' in params:
            query_params.append(('addReturnToLineEnd', params['add_return_to_line_end']))
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'image_resolution_x' in params:
            query_params.append(('imageResolutionX', params['image_resolution_x']))
        if 'image_resolution_y' in params:
            query_params.append(('imageResolutionY', params['image_resolution_y']))
        if 'max_distance_between_text_lines' in params:
            query_params.append(('maxDistanceBetweenTextLines', params['max_distance_between_text_lines']))
        if 'mode' in params:
            query_params.append(('mode', params['mode']))
        if 'recognize_bullets' in params:
            query_params.append(('recognizeBullets', params['recognize_bullets']))
        if 'relative_horizontal_proximity' in params:
            query_params.append(('relativeHorizontalProximity', params['relative_horizontal_proximity']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/doc', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_epub(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_epub(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.epub) (required)
        :param str content_recognition_mode: Property tunes conversion for this or that desirable method of recognition of content.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_epub_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_epub_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_epub_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_epub_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.epub) (required)
        :param str content_recognition_mode: Property tunes conversion for this or that desirable method of recognition of content.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'content_recognition_mode', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_epub" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_epub`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_epub`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'content_recognition_mode' in params:
            query_params.append(('contentRecognitionMode', params['content_recognition_mode']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/epub', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_html(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to Html format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_html(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.html) (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param str document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param bool flow_layout_paragraph_full_width: This attribute specifies full width paragraph text for Flow mode, FixedLayout = false.
        :param str output_format: This parameter determines the type of result. The zip archive will be uploaded into the storage if the parameter is \"Zip\" or missed (default). In case of the \"Folder\", all resulting files and directories will be uploaded to the folder of the resulting HTML file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_html_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_html_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_html_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to Html format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_html_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.html) (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param str document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param bool flow_layout_paragraph_full_width: This attribute specifies full width paragraph text for Flow mode, FixedLayout = false.
        :param str output_format: This parameter determines the type of result. The zip archive will be uploaded into the storage if the parameter is \"Zip\" or missed (default). In case of the \"Folder\", all resulting files and directories will be uploaded to the folder of the resulting HTML file.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'additional_margin_width_in_points', 'compress_svg_graphics_if_any', 'convert_marked_content_to_layers', 'default_font_name', 'document_type', 'fixed_layout', 'image_resolution', 'minimal_line_width', 'prevent_glyphs_grouping', 'split_css_into_pages', 'split_into_pages', 'use_z_order', 'antialiasing_processing', 'css_class_names_prefix', 'explicit_list_of_saved_pages', 'font_encoding_strategy', 'font_saving_mode', 'html_markup_generation_mode', 'letters_positioning_method', 'pages_flow_type_depends_on_viewers_screen_size', 'parts_embedding_mode', 'raster_images_saving_mode', 'remove_empty_areas_on_top_and_bottom', 'save_shadowed_texts_as_transparent_texts', 'save_transparent_texts', 'special_folder_for_all_images', 'special_folder_for_svg_images', 'try_save_text_underlining_and_strikeouting_in_css', 'folder', 'storage', 'flow_layout_paragraph_full_width', 'output_format']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_html" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_html`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_html`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'additional_margin_width_in_points' in params:
            query_params.append(('additionalMarginWidthInPoints', params['additional_margin_width_in_points']))
        if 'compress_svg_graphics_if_any' in params:
            query_params.append(('compressSvgGraphicsIfAny', params['compress_svg_graphics_if_any']))
        if 'convert_marked_content_to_layers' in params:
            query_params.append(('convertMarkedContentToLayers', params['convert_marked_content_to_layers']))
        if 'default_font_name' in params:
            query_params.append(('defaultFontName', params['default_font_name']))
        if 'document_type' in params:
            query_params.append(('documentType', params['document_type']))
        if 'fixed_layout' in params:
            query_params.append(('fixedLayout', params['fixed_layout']))
        if 'image_resolution' in params:
            query_params.append(('imageResolution', params['image_resolution']))
        if 'minimal_line_width' in params:
            query_params.append(('minimalLineWidth', params['minimal_line_width']))
        if 'prevent_glyphs_grouping' in params:
            query_params.append(('preventGlyphsGrouping', params['prevent_glyphs_grouping']))
        if 'split_css_into_pages' in params:
            query_params.append(('splitCssIntoPages', params['split_css_into_pages']))
        if 'split_into_pages' in params:
            query_params.append(('splitIntoPages', params['split_into_pages']))
        if 'use_z_order' in params:
            query_params.append(('useZOrder', params['use_z_order']))
        if 'antialiasing_processing' in params:
            query_params.append(('antialiasingProcessing', params['antialiasing_processing']))
        if 'css_class_names_prefix' in params:
            query_params.append(('cssClassNamesPrefix', params['css_class_names_prefix']))
        if 'explicit_list_of_saved_pages' in params:
            query_params.append(('explicitListOfSavedPages', params['explicit_list_of_saved_pages']))
            collection_formats['explicitListOfSavedPages'] = 'csv'
        if 'font_encoding_strategy' in params:
            query_params.append(('fontEncodingStrategy', params['font_encoding_strategy']))
        if 'font_saving_mode' in params:
            query_params.append(('fontSavingMode', params['font_saving_mode']))
        if 'html_markup_generation_mode' in params:
            query_params.append(('htmlMarkupGenerationMode', params['html_markup_generation_mode']))
        if 'letters_positioning_method' in params:
            query_params.append(('lettersPositioningMethod', params['letters_positioning_method']))
        if 'pages_flow_type_depends_on_viewers_screen_size' in params:
            query_params.append(('pagesFlowTypeDependsOnViewersScreenSize', params['pages_flow_type_depends_on_viewers_screen_size']))
        if 'parts_embedding_mode' in params:
            query_params.append(('partsEmbeddingMode', params['parts_embedding_mode']))
        if 'raster_images_saving_mode' in params:
            query_params.append(('rasterImagesSavingMode', params['raster_images_saving_mode']))
        if 'remove_empty_areas_on_top_and_bottom' in params:
            query_params.append(('removeEmptyAreasOnTopAndBottom', params['remove_empty_areas_on_top_and_bottom']))
        if 'save_shadowed_texts_as_transparent_texts' in params:
            query_params.append(('saveShadowedTextsAsTransparentTexts', params['save_shadowed_texts_as_transparent_texts']))
        if 'save_transparent_texts' in params:
            query_params.append(('saveTransparentTexts', params['save_transparent_texts']))
        if 'special_folder_for_all_images' in params:
            query_params.append(('specialFolderForAllImages', params['special_folder_for_all_images']))
        if 'special_folder_for_svg_images' in params:
            query_params.append(('specialFolderForSvgImages', params['special_folder_for_svg_images']))
        if 'try_save_text_underlining_and_strikeouting_in_css' in params:
            query_params.append(('trySaveTextUnderliningAndStrikeoutingInCss', params['try_save_text_underlining_and_strikeouting_in_css']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'flow_layout_paragraph_full_width' in params:
            query_params.append(('flowLayoutParagraphFullWidth', params['flow_layout_paragraph_full_width']))
        if 'output_format' in params:
            query_params.append(('outputFormat', params['output_format']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/html', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_mobi_xml(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to MOBIXML format and uploads resulting ZIP archive file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_mobi_xml(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_mobi_xml_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_mobi_xml_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_mobi_xml_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to MOBIXML format and uploads resulting ZIP archive file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_mobi_xml_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_mobi_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_mobi_xml`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_mobi_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/mobixml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_pdf_a(self, name, out_path, type, **kwargs):
        """
        Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_pdf_a(name, out_path, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str type: Type of PdfA format. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_pdf_a_with_http_info(name, out_path, type, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_pdf_a_with_http_info(name, out_path, type, **kwargs)
            return data

    def put_pdf_in_storage_to_pdf_a_with_http_info(self, name, out_path, type, **kwargs):
        """
        Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_pdf_a_with_http_info(name, out_path, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str type: Type of PdfA format. (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'type', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_pdf_a" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_pdf_a`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_pdf_a`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_pdf_in_storage_to_pdf_a`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'type' in params:
            query_params.append(('type', params['type']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/pdfa', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_pptx(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_pptx(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_pptx_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_pptx_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_pptx_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_pptx_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: Base64 encoded password.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'separate_images', 'slides_as_images', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_pptx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_pptx`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_pptx`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'separate_images' in params:
            query_params.append(('separateImages', params['separate_images']))
        if 'slides_as_images' in params:
            query_params.append(('slidesAsImages', params['slides_as_images']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/pptx', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_svg(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_svg(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.svg) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_svg_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_svg_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_svg_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_svg_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.svg) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_svg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_svg`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_svg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/svg', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_te_x(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to TeX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_te_x(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tex) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_te_x_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_te_x_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_te_x_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to TeX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_te_x_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tex) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_te_x" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_te_x`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_te_x`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/tex', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_tiff(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_tiff(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_tiff_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_tiff_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_tiff_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_tiff_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'brightness', 'compression', 'color_depth', 'left_margin', 'right_margin', 'top_margin', 'bottom_margin', 'orientation', 'skip_blank_pages', 'width', 'height', 'x_resolution', 'y_resolution', 'page_index', 'page_count', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_tiff`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'brightness' in params:
            query_params.append(('brightness', params['brightness']))
        if 'compression' in params:
            query_params.append(('compression', params['compression']))
        if 'color_depth' in params:
            query_params.append(('colorDepth', params['color_depth']))
        if 'left_margin' in params:
            query_params.append(('leftMargin', params['left_margin']))
        if 'right_margin' in params:
            query_params.append(('rightMargin', params['right_margin']))
        if 'top_margin' in params:
            query_params.append(('topMargin', params['top_margin']))
        if 'bottom_margin' in params:
            query_params.append(('bottomMargin', params['bottom_margin']))
        if 'orientation' in params:
            query_params.append(('orientation', params['orientation']))
        if 'skip_blank_pages' in params:
            query_params.append(('skipBlankPages', params['skip_blank_pages']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'x_resolution' in params:
            query_params.append(('xResolution', params['x_resolution']))
        if 'y_resolution' in params:
            query_params.append(('yResolution', params['y_resolution']))
        if 'page_index' in params:
            query_params.append(('pageIndex', params['page_index']))
        if 'page_count' in params:
            query_params.append(('pageCount', params['page_count']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/tiff', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_xls(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xls(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xls) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_xls_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_xls_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_xls_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xls_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xls) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_xls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_xls`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_xls`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xls', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_xlsx(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XLSX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xlsx(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_xlsx_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_xlsx_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_xlsx_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XLSX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xlsx_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor (Obsolete)
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :param str storage: The document storage.
        :param str password: The password (Base64).
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'folder', 'storage', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_xlsx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_xlsx`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_xlsx`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xlsx', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_xml(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XML format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xml(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xml) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_xml_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_xml_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_xml_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XML format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xml_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xml) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_xml`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_xps(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xps(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xps) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_xps_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_xps_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_xps_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xps_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xps) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_xps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_xps`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_xps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xps', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_poly_line_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document polyline annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_poly_line_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param PolyLineAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolyLineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_poly_line_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_poly_line_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_poly_line_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document polyline annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_poly_line_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param PolyLineAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolyLineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_poly_line_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_poly_line_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_poly_line_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_poly_line_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/polyline/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PolyLineAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_polygon_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document polygon annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_polygon_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param PolygonAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolygonAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_polygon_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_polygon_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_polygon_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document polygon annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_polygon_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param PolygonAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PolygonAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_polygon_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_polygon_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_polygon_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_polygon_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/polygon/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PolygonAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_popup_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document popup annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_popup_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param PopupAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_popup_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_popup_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_popup_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document popup annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_popup_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param PopupAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: PopupAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_popup_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_popup_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_popup_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_popup_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/popup/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PopupAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_privileges(self, name, privileges, **kwargs):
        """
        Update privilege document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_privileges(name, privileges, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param DocumentPrivilege privileges: Document privileges. DocumentPrivilege (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_privileges_with_http_info(name, privileges, **kwargs)
        else:
            (data) = self.put_privileges_with_http_info(name, privileges, **kwargs)
            return data

    def put_privileges_with_http_info(self, name, privileges, **kwargs):
        """
        Update privilege document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_privileges_with_http_info(name, privileges, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param DocumentPrivilege privileges: Document privileges. DocumentPrivilege (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'privileges', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_privileges" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_privileges`")
        # verify the required parameter 'privileges' is set
        if ('privileges' not in params) or (params['privileges'] is None):
            raise ValueError("Missing the required parameter `privileges` when calling `put_privileges`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'privileges' in params:
            body_params = params['privileges']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/privileges', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_ps_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert PS file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_ps_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.ps) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_ps_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_ps_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_ps_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert PS file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_ps_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.ps) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ps_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ps_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_ps_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/ps', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_radio_button_field(self, name, field_name, field, **kwargs):
        """
        Replace document RadioButton field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_radio_button_field(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param RadioButtonField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RadioButtonFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_radio_button_field_with_http_info(name, field_name, field, **kwargs)
        else:
            (data) = self.put_radio_button_field_with_http_info(name, field_name, field, **kwargs)
            return data

    def put_radio_button_field_with_http_info(self, name, field_name, field, **kwargs):
        """
        Replace document RadioButton field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_radio_button_field_with_http_info(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param RadioButtonField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: RadioButtonFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_radio_button_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_radio_button_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `put_radio_button_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `put_radio_button_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/radiobutton/{fieldName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RadioButtonFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_redaction_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document redaction annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_redaction_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param RedactionAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param bool apply: Apply redaction immediately after adding.
        :return: RedactionAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_redaction_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_redaction_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_redaction_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document redaction annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_redaction_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param RedactionAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param bool apply: Apply redaction immediately after adding.
        :return: RedactionAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder', 'apply']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_redaction_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_redaction_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_redaction_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_redaction_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'apply' in params:
            query_params.append(('apply', params['apply']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/redaction/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RedactionAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_replace_image(self, name, image_id, **kwargs):
        """
        Replace document image.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_replace_image(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: The image ID. (required)
        :param str image_file_path: Path to image file if specified. Request content is used otherwise.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file image: Image file.
        :return: ImageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_replace_image_with_http_info(name, image_id, **kwargs)
        else:
            (data) = self.put_replace_image_with_http_info(name, image_id, **kwargs)
            return data

    def put_replace_image_with_http_info(self, name, image_id, **kwargs):
        """
        Replace document image.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_replace_image_with_http_info(name, image_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str image_id: The image ID. (required)
        :param str image_file_path: Path to image file if specified. Request content is used otherwise.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file image: Image file.
        :return: ImageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_id', 'image_file_path', 'storage', 'folder', 'image']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_replace_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_replace_image`")
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params) or (params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_replace_image`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'image_id' in params:
            path_params['imageId'] = params['image_id']

        query_params = []
        if 'image_file_path' in params:
            query_params.append(('imageFilePath', params['image_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/{imageId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImageResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_replace_multiple_image(self, name, image_ids, **kwargs):
        """
        Replace document multiple image.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_replace_multiple_image(name, image_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[str] image_ids: The image IDs. (required)
        :param str image_file_path: Path to image file if specified. Request content is used otherwise.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file image: Image file.
        :return: ImagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_replace_multiple_image_with_http_info(name, image_ids, **kwargs)
        else:
            (data) = self.put_replace_multiple_image_with_http_info(name, image_ids, **kwargs)
            return data

    def put_replace_multiple_image_with_http_info(self, name, image_ids, **kwargs):
        """
        Replace document multiple image.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_replace_multiple_image_with_http_info(name, image_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param list[str] image_ids: The image IDs. (required)
        :param str image_file_path: Path to image file if specified. Request content is used otherwise.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file image: Image file.
        :return: ImagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'image_ids', 'image_file_path', 'storage', 'folder', 'image']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_replace_multiple_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_replace_multiple_image`")
        # verify the required parameter 'image_ids' is set
        if ('image_ids' not in params) or (params['image_ids'] is None):
            raise ValueError("Missing the required parameter `image_ids` when calling `put_replace_multiple_image`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'image_ids' in params:
            query_params.append(('imageIds', params['image_ids']))
            collection_formats['imageIds'] = 'csv'
        if 'image_file_path' in params:
            query_params.append(('imageFilePath', params['image_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/images/replace', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImagesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_screen_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document screen annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_screen_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param ScreenAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ScreenAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_screen_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_screen_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_screen_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document screen annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_screen_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param ScreenAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ScreenAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_screen_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_screen_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_screen_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_screen_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/screen/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ScreenAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_screen_annotation_data_extract(self, name, annotation_id, out_file_path, **kwargs):
        """
        Extract document screen annotation content to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_screen_annotation_data_extract(name, annotation_id, out_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str out_file_path: The output file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_screen_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, **kwargs)
        else:
            (data) = self.put_screen_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, **kwargs)
            return data

    def put_screen_annotation_data_extract_with_http_info(self, name, annotation_id, out_file_path, **kwargs):
        """
        Extract document screen annotation content to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_screen_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str out_file_path: The output file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'out_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_screen_annotation_data_extract" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_screen_annotation_data_extract`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_screen_annotation_data_extract`")
        # verify the required parameter 'out_file_path' is set
        if ('out_file_path' not in params) or (params['out_file_path'] is None):
            raise ValueError("Missing the required parameter `out_file_path` when calling `put_screen_annotation_data_extract`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'out_file_path' in params:
            query_params.append(('outFilePath', params['out_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/screen/{annotationId}/data/extract', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_searchable_document(self, name, **kwargs):
        """
        Create searchable PDF document. Generate OCR layer for images in input PDF document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_searchable_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str lang: language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus 
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_searchable_document_with_http_info(name, **kwargs)
        else:
            (data) = self.put_searchable_document_with_http_info(name, **kwargs)
            return data

    def put_searchable_document_with_http_info(self, name, **kwargs):
        """
        Create searchable PDF document. Generate OCR layer for images in input PDF document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_searchable_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str lang: language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus 
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'lang']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_searchable_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_searchable_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'lang' in params:
            query_params.append(('lang', params['lang']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/ocr', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_set_property(self, name, property_name, value, **kwargs):
        """
        Add/update document property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_set_property(name, property_name, value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str property_name: Property name. (required)
        :param str value: Property value. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: DocumentPropertyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_set_property_with_http_info(name, property_name, value, **kwargs)
        else:
            (data) = self.put_set_property_with_http_info(name, property_name, value, **kwargs)
            return data

    def put_set_property_with_http_info(self, name, property_name, value, **kwargs):
        """
        Add/update document property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_set_property_with_http_info(name, property_name, value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str property_name: Property name. (required)
        :param str value: Property value. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str password: The password (Base64).
        :return: DocumentPropertyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'property_name', 'value', 'storage', 'folder', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_set_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_set_property`")
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params) or (params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `put_set_property`")
        # verify the required parameter 'value' is set
        if ('value' not in params) or (params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `put_set_property`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'property_name' in params:
            path_params['propertyName'] = params['property_name']

        query_params = []
        if 'value' in params:
            query_params.append(('value', params['value']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'password' in params:
            query_params.append(('password', params['password']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/documentproperties/{propertyName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPropertyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_signature_field(self, name, field_name, field, **kwargs):
        """
        Replace document signature field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_signature_field(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param SignatureField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_signature_field_with_http_info(name, field_name, field, **kwargs)
        else:
            (data) = self.put_signature_field_with_http_info(name, field_name, field, **kwargs)
            return data

    def put_signature_field_with_http_info(self, name, field_name, field, **kwargs):
        """
        Replace document signature field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_signature_field_with_http_info(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param SignatureField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SignatureFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_signature_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_signature_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `put_signature_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `put_signature_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/signature/{fieldName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SignatureFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_sound_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document sound annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_sound_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param SoundAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SoundAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_sound_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_sound_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_sound_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document sound annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_sound_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param SoundAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SoundAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_sound_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_sound_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_sound_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_sound_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/sound/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SoundAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_sound_annotation_data_extract(self, name, annotation_id, out_file_path, **kwargs):
        """
        Extract document sound annotation content to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_sound_annotation_data_extract(name, annotation_id, out_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str out_file_path: The output file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_sound_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, **kwargs)
        else:
            (data) = self.put_sound_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, **kwargs)
            return data

    def put_sound_annotation_data_extract_with_http_info(self, name, annotation_id, out_file_path, **kwargs):
        """
        Extract document sound annotation content to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_sound_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str out_file_path: The output file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'out_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_sound_annotation_data_extract" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_sound_annotation_data_extract`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_sound_annotation_data_extract`")
        # verify the required parameter 'out_file_path' is set
        if ('out_file_path' not in params) or (params['out_file_path'] is None):
            raise ValueError("Missing the required parameter `out_file_path` when calling `put_sound_annotation_data_extract`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'out_file_path' in params:
            query_params.append(('outFilePath', params['out_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/sound/{annotationId}/data/extract', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_square_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document square annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_square_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param SquareAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquareAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_square_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_square_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_square_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document square annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_square_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param SquareAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquareAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_square_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_square_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_square_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_square_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/square/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SquareAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_squiggly_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document squiggly annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_squiggly_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param SquigglyAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquigglyAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_squiggly_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_squiggly_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_squiggly_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document squiggly annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_squiggly_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param SquigglyAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SquigglyAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_squiggly_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_squiggly_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_squiggly_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_squiggly_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/squiggly/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SquigglyAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_stamp_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document stamp annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_stamp_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param StampAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_stamp_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_stamp_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_stamp_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document stamp annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_stamp_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param StampAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StampAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_stamp_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_stamp_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_stamp_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_stamp_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/stamp/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StampAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_stamp_annotation_data_extract(self, name, annotation_id, out_file_path, **kwargs):
        """
        Extract document stamp annotation content to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_stamp_annotation_data_extract(name, annotation_id, out_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str out_file_path: The output file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_stamp_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, **kwargs)
        else:
            (data) = self.put_stamp_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, **kwargs)
            return data

    def put_stamp_annotation_data_extract_with_http_info(self, name, annotation_id, out_file_path, **kwargs):
        """
        Extract document stamp annotation content to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_stamp_annotation_data_extract_with_http_info(name, annotation_id, out_file_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param str out_file_path: The output file path. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'out_file_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_stamp_annotation_data_extract" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_stamp_annotation_data_extract`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_stamp_annotation_data_extract`")
        # verify the required parameter 'out_file_path' is set
        if ('out_file_path' not in params) or (params['out_file_path'] is None):
            raise ValueError("Missing the required parameter `out_file_path` when calling `put_stamp_annotation_data_extract`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'out_file_path' in params:
            query_params.append(('outFilePath', params['out_file_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/stamp/{annotationId}/data/extract', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_strike_out_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document StrikeOut annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_strike_out_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param StrikeOutAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StrikeOutAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_strike_out_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_strike_out_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_strike_out_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document StrikeOut annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_strike_out_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param StrikeOutAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: StrikeOutAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_strike_out_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_strike_out_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_strike_out_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_strike_out_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/strikeout/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StrikeOutAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_svg_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert SVG file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_svg_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.svg) (required)
        :param bool adjust_page_size: Adjust page size
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_svg_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_svg_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_svg_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert SVG file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_svg_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.svg) (required)
        :param bool adjust_page_size: Adjust page size
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'adjust_page_size', 'height', 'width', 'is_landscape', 'margin_left', 'margin_bottom', 'margin_right', 'margin_top', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_svg_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_svg_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_svg_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'adjust_page_size' in params:
            query_params.append(('adjustPageSize', params['adjust_page_size']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'is_landscape' in params:
            query_params.append(('isLandscape', params['is_landscape']))
        if 'margin_left' in params:
            query_params.append(('marginLeft', params['margin_left']))
        if 'margin_bottom' in params:
            query_params.append(('marginBottom', params['margin_bottom']))
        if 'margin_right' in params:
            query_params.append(('marginRight', params['margin_right']))
        if 'margin_top' in params:
            query_params.append(('marginTop', params['margin_top']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/svg', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_table(self, name, table_id, table, **kwargs):
        """
        Replace document page table.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_table(name, table_id, table, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str table_id: The table ID. (required)
        :param Table table: The table. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_table_with_http_info(name, table_id, table, **kwargs)
        else:
            (data) = self.put_table_with_http_info(name, table_id, table, **kwargs)
            return data

    def put_table_with_http_info(self, name, table_id, table, **kwargs):
        """
        Replace document page table.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_table_with_http_info(name, table_id, table, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str table_id: The table ID. (required)
        :param Table table: The table. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'table_id', 'table', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_table`")
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `put_table`")
        # verify the required parameter 'table' is set
        if ('table' not in params) or (params['table'] is None):
            raise ValueError("Missing the required parameter `table` when calling `put_table`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'table' in params:
            body_params = params['table']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/tables/{tableId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_te_x_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert TeX file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_te_x_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.tex) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_te_x_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_te_x_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_te_x_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert TeX file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_te_x_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.tex) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_te_x_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_te_x_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_te_x_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/tex', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_text_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document text annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_text_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param TextAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_text_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_text_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_text_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document text annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_text_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param TextAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_text_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_text_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_text_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_text_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/text/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_text_box_field(self, name, field_name, field, **kwargs):
        """
        Replace document text box field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_text_box_field(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param TextBoxField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_text_box_field_with_http_info(name, field_name, field, **kwargs)
        else:
            (data) = self.put_text_box_field_with_http_info(name, field_name, field, **kwargs)
            return data

    def put_text_box_field_with_http_info(self, name, field_name, field, **kwargs):
        """
        Replace document text box field
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_text_box_field_with_http_info(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name. (required)
        :param TextBoxField field: The field. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: TextBoxFieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_text_box_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_text_box_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `put_text_box_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `put_text_box_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/textbox/{fieldName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextBoxFieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_underline_annotation(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document underline annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_underline_annotation(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param UnderlineAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: UnderlineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_underline_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
        else:
            (data) = self.put_underline_annotation_with_http_info(name, annotation_id, annotation, **kwargs)
            return data

    def put_underline_annotation_with_http_info(self, name, annotation_id, annotation, **kwargs):
        """
        Replace document underline annotation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_underline_annotation_with_http_info(name, annotation_id, annotation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str annotation_id: The annotation ID. (required)
        :param UnderlineAnnotation annotation: Annotation. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: UnderlineAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'annotation_id', 'annotation', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_underline_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_underline_annotation`")
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params) or (params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `put_underline_annotation`")
        # verify the required parameter 'annotation' is set
        if ('annotation' not in params) or (params['annotation'] is None):
            raise ValueError("Missing the required parameter `annotation` when calling `put_underline_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'annotation' in params:
            body_params = params['annotation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/annotations/underline/{annotationId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UnderlineAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_update_field(self, name, field_name, field, **kwargs):
        """
        Update field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_update_field(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The name of a field to be updated. (required)
        :param Field field: Field with the field data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_update_field_with_http_info(name, field_name, field, **kwargs)
        else:
            (data) = self.put_update_field_with_http_info(name, field_name, field, **kwargs)
            return data

    def put_update_field_with_http_info(self, name, field_name, field, **kwargs):
        """
        Update field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_update_field_with_http_info(name, field_name, field, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The name of a field to be updated. (required)
        :param Field field: Field with the field data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_update_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_update_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `put_update_field`")
        # verify the required parameter 'field' is set
        if ('field' not in params) or (params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `put_update_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields/{fieldName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_update_fields(self, name, fields, **kwargs):
        """
        Update fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_update_fields(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param Fields fields: Fields with the fields data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_update_fields_with_http_info(name, fields, **kwargs)
        else:
            (data) = self.put_update_fields_with_http_info(name, fields, **kwargs)
            return data

    def put_update_fields_with_http_info(self, name, fields, **kwargs):
        """
        Update fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_update_fields_with_http_info(name, fields, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param Fields fields: Fields with the fields data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fields', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_update_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_update_fields`")
        # verify the required parameter 'fields' is set
        if ('fields' not in params) or (params['fields'] is None):
            raise ValueError("Missing the required parameter `fields` when calling `put_update_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'fields' in params:
            body_params = params['fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/fields', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_web_in_storage_to_pdf(self, name, url, **kwargs):
        """
        Convert web page to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_web_in_storage_to_pdf(name, url, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str url: Source url (required)
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_web_in_storage_to_pdf_with_http_info(name, url, **kwargs)
        else:
            (data) = self.put_web_in_storage_to_pdf_with_http_info(name, url, **kwargs)
            return data

    def put_web_in_storage_to_pdf_with_http_info(self, name, url, **kwargs):
        """
        Convert web page to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_web_in_storage_to_pdf_with_http_info(name, url, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str url: Source url (required)
        :param float height: Page height
        :param float width: Page width
        :param bool is_landscape: Is page landscaped
        :param float margin_left: Page margin left
        :param float margin_bottom: Page margin bottom
        :param float margin_right: Page margin right
        :param float margin_top: Page margin top
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'url', 'height', 'width', 'is_landscape', 'margin_left', 'margin_bottom', 'margin_right', 'margin_top', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_web_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_web_in_storage_to_pdf`")
        # verify the required parameter 'url' is set
        if ('url' not in params) or (params['url'] is None):
            raise ValueError("Missing the required parameter `url` when calling `put_web_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'url' in params:
            query_params.append(('url', params['url']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'is_landscape' in params:
            query_params.append(('isLandscape', params['is_landscape']))
        if 'margin_left' in params:
            query_params.append(('marginLeft', params['margin_left']))
        if 'margin_bottom' in params:
            query_params.append(('marginBottom', params['margin_bottom']))
        if 'margin_right' in params:
            query_params.append(('marginRight', params['margin_right']))
        if 'margin_top' in params:
            query_params.append(('marginTop', params['margin_top']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/web', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_xfa_pdf_in_request_to_acro_form(self, out_path, **kwargs):
        """
        Converts PDF document which contains XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xfa_pdf_in_request_to_acro_form(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_xfa_pdf_in_request_to_acro_form_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_xfa_pdf_in_request_to_acro_form_with_http_info(out_path, **kwargs)
            return data

    def put_xfa_pdf_in_request_to_acro_form_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document which contains XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xfa_pdf_in_request_to_acro_form_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str storage: The document storage.
        :param file file: A file to be converted.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'storage', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_xfa_pdf_in_request_to_acro_form" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_xfa_pdf_in_request_to_acro_form`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/convert/xfatoacroform', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_xfa_pdf_in_storage_to_acro_form(self, name, out_path, **kwargs):
        """
        Converts PDF document which contains XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xfa_pdf_in_storage_to_acro_form(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_xfa_pdf_in_storage_to_acro_form_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_xfa_pdf_in_storage_to_acro_form_with_http_info(name, out_path, **kwargs)
            return data

    def put_xfa_pdf_in_storage_to_acro_form_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document which contains XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xfa_pdf_in_storage_to_acro_form_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str folder: The document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_xfa_pdf_in_storage_to_acro_form" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_xfa_pdf_in_storage_to_acro_form`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_xfa_pdf_in_storage_to_acro_form`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/convert/xfatoacroform', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_xml_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert XML file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xml_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xml) (required)
        :param str xsl_file_path: Full XSL source filename (ex. /folder1/folder2/template.xsl)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_xml_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_xml_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_xml_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert XML file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xml_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xml) (required)
        :param str xsl_file_path: Full XSL source filename (ex. /folder1/folder2/template.xsl)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'xsl_file_path', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_xml_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_xml_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_xml_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'xsl_file_path' in params:
            query_params.append(('xslFilePath', params['xsl_file_path']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/xml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_xps_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert XPS file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xps_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xps) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_xps_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_xps_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_xps_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert XPS file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xps_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xps) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_xps_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_xps_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_xps_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/xps', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_xsl_fo_in_storage_to_pdf(self, name, src_path, **kwargs):
        """
        Convert XslFo file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xsl_fo_in_storage_to_pdf(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_xsl_fo_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
        else:
            (data) = self.put_xsl_fo_in_storage_to_pdf_with_http_info(name, src_path, **kwargs)
            return data

    def put_xsl_fo_in_storage_to_pdf_with_http_info(self, name, src_path, **kwargs):
        """
        Convert XslFo file (located on storage) to PDF format and upload resulting file to storage. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xsl_fo_in_storage_to_pdf_with_http_info(name, src_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str src_path: Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
        :param str dst_folder: The destination document folder.
        :param str storage: The document storage.
        :return: AsposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src_path', 'dst_folder', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_xsl_fo_in_storage_to_pdf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_xsl_fo_in_storage_to_pdf`")
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params) or (params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `put_xsl_fo_in_storage_to_pdf`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'src_path' in params:
            query_params.append(('srcPath', params['src_path']))
        if 'dst_folder' in params:
            query_params.append(('dstFolder', params['dst_folder']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/{name}/create/xslfo', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AsposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def storage_exists(self, storage_name, **kwargs):
        """
        Check if storage exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.storage_exists(storage_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str storage_name: Storage name (required)
        :return: StorageExist
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.storage_exists_with_http_info(storage_name, **kwargs)
        else:
            (data) = self.storage_exists_with_http_info(storage_name, **kwargs)
            return data

    def storage_exists_with_http_info(self, storage_name, **kwargs):
        """
        Check if storage exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.storage_exists_with_http_info(storage_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str storage_name: Storage name (required)
        :return: StorageExist
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['storage_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'storage_name' is set
        if ('storage_name' not in params) or (params['storage_name'] is None):
            raise ValueError("Missing the required parameter `storage_name` when calling `storage_exists`")


        collection_formats = {}

        path_params = {}
        if 'storage_name' in params:
            path_params['storageName'] = params['storage_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/{storageName}/exist', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StorageExist',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def upload_file(self, path, file, **kwargs):
        """
        Upload file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_file(path, file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.              (required)
        :param file file: File to upload (required)
        :param str storage_name: Storage name
        :return: FilesUploadResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upload_file_with_http_info(path, file, **kwargs)
        else:
            (data) = self.upload_file_with_http_info(path, file, **kwargs)
            return data

    def upload_file_with_http_info(self, path, file, **kwargs):
        """
        Upload file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_file_with_http_info(path, file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.              (required)
        :param file file: File to upload (required)
        :param str storage_name: Storage name
        :return: FilesUploadResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'file', 'storage_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `upload_file`")
        # verify the required parameter 'file' is set
        if ('file' not in params) or (params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_file`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['File'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['JWT']

        return self.api_client.call_api('/pdf/storage/file/{path}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FilesUploadResult',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
