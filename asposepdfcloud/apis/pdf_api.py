# coding: utf-8

"""
    Aspose.PDF for Cloud API Reference


   Copyright (c) 2018 Aspose.Pdf for Cloud
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.



    OpenAPI spec version: 1.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class PdfApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def delete_field(self, name, field_name, **kwargs):
        """
        Delete document field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name/ (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.delete_field_with_http_info(name, field_name, **kwargs)
            return data

    def delete_field_with_http_info(self, name, field_name, **kwargs):
        """
        Delete document field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name/ (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `delete_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/fields/{fieldName}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_page(self, name, page_number, **kwargs):
        """
        Delete document page by its number.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_page_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.delete_page_with_http_info(name, page_number, **kwargs)
            return data

    def delete_page_with_http_info(self, name, page_number, **kwargs):
        """
        Delete document page by its number.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_page_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_page`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `delete_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_properties(self, name, **kwargs):
        """
        Delete custom document properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_properties(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str storage:
        :param str folder:
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_properties_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_properties_with_http_info(name, **kwargs)
            return data

    def delete_properties_with_http_info(self, name, **kwargs):
        """
        Delete custom document properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_properties_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str storage:
        :param str folder:
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_properties`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/documentproperties', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_property(self, name, property_name, **kwargs):
        """
        Delete document property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_property(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str property_name: (required)
        :param str storage:
        :param str folder:
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_property_with_http_info(name, property_name, **kwargs)
        else:
            (data) = self.delete_property_with_http_info(name, property_name, **kwargs)
            return data

    def delete_property_with_http_info(self, name, property_name, **kwargs):
        """
        Delete document property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_property_with_http_info(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str property_name: (required)
        :param str storage:
        :param str folder:
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'property_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_property`")
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params) or (params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `delete_property`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'property_name' in params:
            path_params['propertyName'] = params['property_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/documentproperties/{propertyName}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document(self, name, **kwargs):
        """
        Read common document info or convert to some format if the format specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str format: The format to convert.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str out_path: Path to save result
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_with_http_info(name, **kwargs)
            return data

    def get_document_with_http_info(self, name, **kwargs):
        """
        Read common document info or convert to some format if the format specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str format: The format to convert.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str out_path: Path to save result
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'storage', 'folder', 'out_path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_attachment_by_index(self, name, attachment_index, **kwargs):
        """
        Read document attachment info by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_attachment_by_index(name, attachment_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int attachment_index: The attachment index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_attachment_by_index_with_http_info(name, attachment_index, **kwargs)
        else:
            (data) = self.get_document_attachment_by_index_with_http_info(name, attachment_index, **kwargs)
            return data

    def get_document_attachment_by_index_with_http_info(self, name, attachment_index, **kwargs):
        """
        Read document attachment info by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_attachment_by_index_with_http_info(name, attachment_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int attachment_index: The attachment index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'attachment_index', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_attachment_by_index" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_attachment_by_index`")
        # verify the required parameter 'attachment_index' is set
        if ('attachment_index' not in params) or (params['attachment_index'] is None):
            raise ValueError("Missing the required parameter `attachment_index` when calling `get_document_attachment_by_index`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'attachment_index' in params:
            path_params['attachmentIndex'] = params['attachment_index']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/attachments/{attachmentIndex}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AttachmentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_attachments(self, name, **kwargs):
        """
        Read document attachments info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_attachments(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_attachments_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_attachments_with_http_info(name, **kwargs)
            return data

    def get_document_attachments_with_http_info(self, name, **kwargs):
        """
        Read document attachments info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_attachments_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AttachmentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_attachments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_attachments`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/attachments', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AttachmentsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_bookmarks(self, name, **kwargs):
        """
        Read document bookmark/bookmarks (including children).
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_bookmarks(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. Leave it empty if you want to get all the bookmarks in the document.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_bookmarks_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_bookmarks_with_http_info(name, **kwargs)
            return data

    def get_document_bookmarks_with_http_info(self, name, **kwargs):
        """
        Read document bookmark/bookmarks (including children).
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_bookmarks_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str bookmark_path: The bookmark path. Leave it empty if you want to get all the bookmarks in the document.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bookmark_path', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_bookmarks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_bookmarks`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'bookmark_path' in params:
            query_params.append(('bookmarkPath', params['bookmark_path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/bookmarks', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_properties(self, name, **kwargs):
        """
        Read document properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_properties(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str storage:
        :param str folder:
        :return: DocumentPropertiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_properties_with_http_info(name, **kwargs)
        else:
            (data) = self.get_document_properties_with_http_info(name, **kwargs)
            return data

    def get_document_properties_with_http_info(self, name, **kwargs):
        """
        Read document properties.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_properties_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str storage:
        :param str folder:
        :return: DocumentPropertiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_properties`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/documentproperties', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPropertiesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_document_property(self, name, property_name, **kwargs):
        """
        Read document property by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_property(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str property_name: (required)
        :param str storage:
        :param str folder:
        :return: DocumentPropertyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_document_property_with_http_info(name, property_name, **kwargs)
        else:
            (data) = self.get_document_property_with_http_info(name, property_name, **kwargs)
            return data

    def get_document_property_with_http_info(self, name, property_name, **kwargs):
        """
        Read document property by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_document_property_with_http_info(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str property_name: (required)
        :param str storage:
        :param str folder:
        :return: DocumentPropertyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'property_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_document_property`")
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params) or (params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `get_document_property`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'property_name' in params:
            path_params['propertyName'] = params['property_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/documentproperties/{propertyName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPropertyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_download(self, path, **kwargs):
        """
        Download a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_download(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Path of the file including the file name and extension e.g. /file.ext (required)
        :param str version_id: File's version
        :param str storage: User's storage name
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_download_with_http_info(path, **kwargs)
        else:
            (data) = self.get_download_with_http_info(path, **kwargs)
            return data

    def get_download_with_http_info(self, path, **kwargs):
        """
        Download a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_download_with_http_info(path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Path of the file including the file name and extension e.g. /file.ext (required)
        :param str version_id: File's version
        :param str storage: User's storage name
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'version_id', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_download" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_download`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/file', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_download_document_attachment_by_index(self, name, attachment_index, **kwargs):
        """
        Download document attachment content by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_download_document_attachment_by_index(name, attachment_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int attachment_index: The attachment index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_download_document_attachment_by_index_with_http_info(name, attachment_index, **kwargs)
        else:
            (data) = self.get_download_document_attachment_by_index_with_http_info(name, attachment_index, **kwargs)
            return data

    def get_download_document_attachment_by_index_with_http_info(self, name, attachment_index, **kwargs):
        """
        Download document attachment content by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_download_document_attachment_by_index_with_http_info(name, attachment_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int attachment_index: The attachment index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'attachment_index', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_download_document_attachment_by_index" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_download_document_attachment_by_index`")
        # verify the required parameter 'attachment_index' is set
        if ('attachment_index' not in params) or (params['attachment_index'] is None):
            raise ValueError("Missing the required parameter `attachment_index` when calling `get_download_document_attachment_by_index`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'attachment_index' in params:
            path_params['attachmentIndex'] = params['attachment_index']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/attachments/{attachmentIndex}/download', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_field(self, name, field_name, **kwargs):
        """
        Get document field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name/ (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.get_field_with_http_info(name, field_name, **kwargs)
            return data

    def get_field_with_http_info(self, name, field_name, **kwargs):
        """
        Get document field by name.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The field name/ (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `get_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/fields/{fieldName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_fields(self, name, **kwargs):
        """
        Get document fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.get_fields_with_http_info(name, **kwargs)
            return data

    def get_fields_with_http_info(self, name, **kwargs):
        """
        Get document fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/fields', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_fragment(self, name, page_number, fragment_number, **kwargs):
        """
        Read page fragment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fragment(name, page_number, fragment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_fragment_with_http_info(name, page_number, fragment_number, **kwargs)
        else:
            (data) = self.get_fragment_with_http_info(name, page_number, fragment_number, **kwargs)
            return data

    def get_fragment_with_http_info(self, name, page_number, fragment_number, **kwargs):
        """
        Read page fragment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fragment_with_http_info(name, page_number, fragment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'fragment_number', 'with_empty', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fragment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_fragment`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_fragment`")
        # verify the required parameter 'fragment_number' is set
        if ('fragment_number' not in params) or (params['fragment_number'] is None):
            raise ValueError("Missing the required parameter `fragment_number` when calling `get_fragment`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'fragment_number' in params:
            path_params['fragmentNumber'] = params['fragment_number']

        query_params = []
        if 'with_empty' in params:
            query_params.append(('withEmpty', params['with_empty']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextItemsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_fragment_text_format(self, name, page_number, fragment_number, **kwargs):
        """
        Read page fragment text format.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fragment_text_format(name, page_number, fragment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param str storage:
        :param str folder:
        :return: TextFormatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_fragment_text_format_with_http_info(name, page_number, fragment_number, **kwargs)
        else:
            (data) = self.get_fragment_text_format_with_http_info(name, page_number, fragment_number, **kwargs)
            return data

    def get_fragment_text_format_with_http_info(self, name, page_number, fragment_number, **kwargs):
        """
        Read page fragment text format.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fragment_text_format_with_http_info(name, page_number, fragment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param str storage:
        :param str folder:
        :return: TextFormatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'fragment_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fragment_text_format" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_fragment_text_format`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_fragment_text_format`")
        # verify the required parameter 'fragment_number' is set
        if ('fragment_number' not in params) or (params['fragment_number'] is None):
            raise ValueError("Missing the required parameter `fragment_number` when calling `get_fragment_text_format`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'fragment_number' in params:
            path_params['fragmentNumber'] = params['fragment_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/textFormat', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextFormatResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_fragments(self, name, page_number, **kwargs):
        """
        Read page fragments.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fragments(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_fragments_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_fragments_with_http_info(name, page_number, **kwargs)
            return data

    def get_fragments_with_http_info(self, name, page_number, **kwargs):
        """
        Read page fragments.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_fragments_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'with_empty', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fragments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_fragments`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_fragments`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'with_empty' in params:
            query_params.append(('withEmpty', params['with_empty']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/fragments', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextItemsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_image(self, name, page_number, image_number, **kwargs):
        """
        Extract document image in format specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image(name, page_number, image_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int image_number: The image format. (required)
        :param str format: Image format to convert, if not specified the common image data is read.
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_image_with_http_info(name, page_number, image_number, **kwargs)
        else:
            (data) = self.get_image_with_http_info(name, page_number, image_number, **kwargs)
            return data

    def get_image_with_http_info(self, name, page_number, image_number, **kwargs):
        """
        Extract document image in format specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image_with_http_info(name, page_number, image_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int image_number: The image format. (required)
        :param str format: Image format to convert, if not specified the common image data is read.
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'image_number', 'format', 'width', 'height', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_image`")
        # verify the required parameter 'image_number' is set
        if ('image_number' not in params) or (params['image_number'] is None):
            raise ValueError("Missing the required parameter `image_number` when calling `get_image`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'image_number' in params:
            path_params['imageNumber'] = params['image_number']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images/{imageNumber}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_images(self, name, page_number, **kwargs):
        """
        Read document images.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_images(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ImagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_images_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_images_with_http_info(name, page_number, **kwargs)
            return data

    def get_images_with_http_info(self, name, page_number, **kwargs):
        """
        Read document images.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_images_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: ImagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_images`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_images`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImagesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page(self, name, page_number, **kwargs):
        """
        Convert document page to format specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str format: The format to convert if specified.
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_with_http_info(self, name, page_number, **kwargs):
        """
        Convert document page to format specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str format: The format to convert if specified.
        :param int width: The converted image width.
        :param int height: The converted image height.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'format', 'width', 'height', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_annotation(self, name, page_number, annotation_number, **kwargs):
        """
        Read document page annotation by its number.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_annotation(name, page_number, annotation_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int annotation_number: The annotation number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_annotation_with_http_info(name, page_number, annotation_number, **kwargs)
        else:
            (data) = self.get_page_annotation_with_http_info(name, page_number, annotation_number, **kwargs)
            return data

    def get_page_annotation_with_http_info(self, name, page_number, annotation_number, **kwargs):
        """
        Read document page annotation by its number.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_annotation_with_http_info(name, page_number, annotation_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int annotation_number: The annotation number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'annotation_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_annotation`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_annotation`")
        # verify the required parameter 'annotation_number' is set
        if ('annotation_number' not in params) or (params['annotation_number'] is None):
            raise ValueError("Missing the required parameter `annotation_number` when calling `get_page_annotation`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'annotation_number' in params:
            path_params['annotationNumber'] = params['annotation_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations/{annotationNumber}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_annotations(self, name, page_number, **kwargs):
        """
        Read documant page annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read documant page annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: AnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/annotations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_link_annotation_by_index(self, name, page_number, link_index, **kwargs):
        """
        Read document page link annotation by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_link_annotation_by_index(name, page_number, link_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int link_index: The link index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_link_annotation_by_index_with_http_info(name, page_number, link_index, **kwargs)
        else:
            (data) = self.get_page_link_annotation_by_index_with_http_info(name, page_number, link_index, **kwargs)
            return data

    def get_page_link_annotation_by_index_with_http_info(self, name, page_number, link_index, **kwargs):
        """
        Read document page link annotation by its index.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_link_annotation_by_index_with_http_info(name, page_number, link_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int link_index: The link index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'link_index', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_link_annotation_by_index" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_link_annotation_by_index`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_link_annotation_by_index`")
        # verify the required parameter 'link_index' is set
        if ('link_index' not in params) or (params['link_index'] is None):
            raise ValueError("Missing the required parameter `link_index` when calling `get_page_link_annotation_by_index`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'link_index' in params:
            path_params['linkIndex'] = params['link_index']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/links/{linkIndex}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LinkAnnotationResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_link_annotations(self, name, page_number, **kwargs):
        """
        Read document page link annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_link_annotations(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_link_annotations_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_link_annotations_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_link_annotations_with_http_info(self, name, page_number, **kwargs):
        """
        Read document page link annotations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_link_annotations_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: LinkAnnotationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_link_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_link_annotations`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_link_annotations`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/links', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LinkAnnotationsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_text(self, name, page_number, x, y, width, height, **kwargs):
        """
        Read page text items.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text(name, page_number, x, y, width, height, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: Number of page (starting from 1). (required)
        :param int x: (required)
        :param int y: (required)
        :param int width: (required)
        :param int height: (required)
        :param list[str] format: List of formats for search.
        :param str regex: Formats are specified as a regular expression.
        :param bool split_rects: Split result fragments (default is true).
        :param str folder: The document folder.
        :return: TextRectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_text_with_http_info(name, page_number, x, y, width, height, **kwargs)
        else:
            (data) = self.get_page_text_with_http_info(name, page_number, x, y, width, height, **kwargs)
            return data

    def get_page_text_with_http_info(self, name, page_number, x, y, width, height, **kwargs):
        """
        Read page text items.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text_with_http_info(name, page_number, x, y, width, height, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: Number of page (starting from 1). (required)
        :param int x: (required)
        :param int y: (required)
        :param int width: (required)
        :param int height: (required)
        :param list[str] format: List of formats for search.
        :param str regex: Formats are specified as a regular expression.
        :param bool split_rects: Split result fragments (default is true).
        :param str folder: The document folder.
        :return: TextRectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'x', 'y', 'width', 'height', 'format', 'regex', 'split_rects', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_text`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_text`")
        # verify the required parameter 'x' is set
        if ('x' not in params) or (params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `get_page_text`")
        # verify the required parameter 'y' is set
        if ('y' not in params) or (params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `get_page_text`")
        # verify the required parameter 'width' is set
        if ('width' not in params) or (params['width'] is None):
            raise ValueError("Missing the required parameter `width` when calling `get_page_text`")
        # verify the required parameter 'height' is set
        if ('height' not in params) or (params['height'] is None):
            raise ValueError("Missing the required parameter `height` when calling `get_page_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
            collection_formats['format'] = 'multi'
        if 'regex' in params:
            query_params.append(('regex', params['regex']))
        if 'x' in params:
            query_params.append(('X', params['x']))
        if 'y' in params:
            query_params.append(('Y', params['y']))
        if 'width' in params:
            query_params.append(('Width', params['width']))
        if 'height' in params:
            query_params.append(('Height', params['height']))
        if 'split_rects' in params:
            query_params.append(('splitRects', params['split_rects']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/text', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextRectsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_page_text_items(self, name, page_number, **kwargs):
        """
        Read page text items.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text_items(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_page_text_items_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.get_page_text_items_with_http_info(name, page_number, **kwargs)
            return data

    def get_page_text_items_with_http_info(self, name, page_number, **kwargs):
        """
        Read page text items.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_page_text_items_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'with_empty', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_page_text_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_page_text_items`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_page_text_items`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'with_empty' in params:
            query_params.append(('withEmpty', params['with_empty']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/textItems', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextItemsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pages(self, name, **kwargs):
        """
        Read document pages info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pages(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pages_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pages_with_http_info(name, **kwargs)
            return data

    def get_pages_with_http_info(self, name, **kwargs):
        """
        Read document pages info.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pages_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pages`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPagesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_doc(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to DOC format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_doc(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param int max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_doc_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_doc_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_doc_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to DOC format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_doc_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param int max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'add_return_to_line_end', 'format', 'image_resolution_x', 'image_resolution_y', 'max_distance_between_text_lines', 'mode', 'recognize_bullets', 'relative_horizontal_proximity', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_doc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_doc`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'add_return_to_line_end' in params:
            query_params.append(('addReturnToLineEnd', params['add_return_to_line_end']))
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'image_resolution_x' in params:
            query_params.append(('imageResolutionX', params['image_resolution_x']))
        if 'image_resolution_y' in params:
            query_params.append(('imageResolutionY', params['image_resolution_y']))
        if 'max_distance_between_text_lines' in params:
            query_params.append(('maxDistanceBetweenTextLines', params['max_distance_between_text_lines']))
        if 'mode' in params:
            query_params.append(('mode', params['mode']))
        if 'recognize_bullets' in params:
            query_params.append(('recognizeBullets', params['recognize_bullets']))
        if 'relative_horizontal_proximity' in params:
            query_params.append(('relativeHorizontalProximity', params['relative_horizontal_proximity']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/doc', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_epub(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_epub(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str content_recognition_mode: roperty tunes conversion for this or that desirable method of recognition of content.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_epub_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_epub_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_epub_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_epub_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str content_recognition_mode: roperty tunes conversion for this or that desirable method of recognition of content.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'content_recognition_mode', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_epub" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_epub`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'content_recognition_mode' in params:
            query_params.append(('contentRecognitionMode', params['content_recognition_mode']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/epub', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_html(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to Html format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_html(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param int document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_html_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_html_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_html_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to Html format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_html_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param int document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'additional_margin_width_in_points', 'compress_svg_graphics_if_any', 'convert_marked_content_to_layers', 'default_font_name', 'document_type', 'fixed_layout', 'image_resolution', 'minimal_line_width', 'prevent_glyphs_grouping', 'split_css_into_pages', 'split_into_pages', 'use_z_order', 'antialiasing_processing', 'css_class_names_prefix', 'explicit_list_of_saved_pages', 'font_encoding_strategy', 'font_saving_mode', 'html_markup_generation_mode', 'letters_positioning_method', 'pages_flow_type_depends_on_viewers_screen_size', 'parts_embedding_mode', 'raster_images_saving_mode', 'remove_empty_areas_on_top_and_bottom', 'save_shadowed_texts_as_transparent_texts', 'save_transparent_texts', 'special_folder_for_all_images', 'special_folder_for_svg_images', 'try_save_text_underlining_and_strikeouting_in_css', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_html" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_html`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'additional_margin_width_in_points' in params:
            query_params.append(('additionalMarginWidthInPoints', params['additional_margin_width_in_points']))
        if 'compress_svg_graphics_if_any' in params:
            query_params.append(('compressSvgGraphicsIfAny', params['compress_svg_graphics_if_any']))
        if 'convert_marked_content_to_layers' in params:
            query_params.append(('convertMarkedContentToLayers', params['convert_marked_content_to_layers']))
        if 'default_font_name' in params:
            query_params.append(('defaultFontName', params['default_font_name']))
        if 'document_type' in params:
            query_params.append(('documentType', params['document_type']))
        if 'fixed_layout' in params:
            query_params.append(('fixedLayout', params['fixed_layout']))
        if 'image_resolution' in params:
            query_params.append(('imageResolution', params['image_resolution']))
        if 'minimal_line_width' in params:
            query_params.append(('minimalLineWidth', params['minimal_line_width']))
        if 'prevent_glyphs_grouping' in params:
            query_params.append(('preventGlyphsGrouping', params['prevent_glyphs_grouping']))
        if 'split_css_into_pages' in params:
            query_params.append(('splitCssIntoPages', params['split_css_into_pages']))
        if 'split_into_pages' in params:
            query_params.append(('splitIntoPages', params['split_into_pages']))
        if 'use_z_order' in params:
            query_params.append(('useZOrder', params['use_z_order']))
        if 'antialiasing_processing' in params:
            query_params.append(('antialiasingProcessing', params['antialiasing_processing']))
        if 'css_class_names_prefix' in params:
            query_params.append(('cssClassNamesPrefix', params['css_class_names_prefix']))
        if 'explicit_list_of_saved_pages' in params:
            query_params.append(('explicitListOfSavedPages', params['explicit_list_of_saved_pages']))
            collection_formats['explicitListOfSavedPages'] = 'multi'
        if 'font_encoding_strategy' in params:
            query_params.append(('fontEncodingStrategy', params['font_encoding_strategy']))
        if 'font_saving_mode' in params:
            query_params.append(('fontSavingMode', params['font_saving_mode']))
        if 'html_markup_generation_mode' in params:
            query_params.append(('htmlMarkupGenerationMode', params['html_markup_generation_mode']))
        if 'letters_positioning_method' in params:
            query_params.append(('lettersPositioningMethod', params['letters_positioning_method']))
        if 'pages_flow_type_depends_on_viewers_screen_size' in params:
            query_params.append(('pagesFlowTypeDependsOnViewersScreenSize', params['pages_flow_type_depends_on_viewers_screen_size']))
        if 'parts_embedding_mode' in params:
            query_params.append(('partsEmbeddingMode', params['parts_embedding_mode']))
        if 'raster_images_saving_mode' in params:
            query_params.append(('rasterImagesSavingMode', params['raster_images_saving_mode']))
        if 'remove_empty_areas_on_top_and_bottom' in params:
            query_params.append(('removeEmptyAreasOnTopAndBottom', params['remove_empty_areas_on_top_and_bottom']))
        if 'save_shadowed_texts_as_transparent_texts' in params:
            query_params.append(('saveShadowedTextsAsTransparentTexts', params['save_shadowed_texts_as_transparent_texts']))
        if 'save_transparent_texts' in params:
            query_params.append(('saveTransparentTexts', params['save_transparent_texts']))
        if 'special_folder_for_all_images' in params:
            query_params.append(('specialFolderForAllImages', params['special_folder_for_all_images']))
        if 'special_folder_for_svg_images' in params:
            query_params.append(('specialFolderForSvgImages', params['special_folder_for_svg_images']))
        if 'try_save_text_underlining_and_strikeouting_in_css' in params:
            query_params.append(('trySaveTextUnderliningAndStrikeoutingInCss', params['try_save_text_underlining_and_strikeouting_in_css']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/html', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_la_te_x(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_la_te_x(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int pages_count: Pages count.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_la_te_x_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_la_te_x_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_la_te_x_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_la_te_x_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int pages_count: Pages count.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pages_count', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_la_te_x" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_la_te_x`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'pages_count' in params:
            query_params.append(('pagesCount', params['pages_count']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/latex', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_mobi_xml(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_mobi_xml(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_mobi_xml_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_mobi_xml_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_mobi_xml_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_mobi_xml_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_mobi_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_mobi_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/mobixml', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_pdf_a(self, name, type, **kwargs):
        """
        Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_pdf_a(name, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str type: Type of PdfA format. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_pdf_a_with_http_info(name, type, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_pdf_a_with_http_info(name, type, **kwargs)
            return data

    def get_pdf_in_storage_to_pdf_a_with_http_info(self, name, type, **kwargs):
        """
        Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_pdf_a_with_http_info(name, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str type: Type of PdfA format. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_pdf_a" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_pdf_a`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_pdf_in_storage_to_pdf_a`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/pdfa', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_pptx(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_pptx(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_pptx_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_pptx_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_pptx_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_pptx_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'separate_images', 'slides_as_images', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_pptx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_pptx`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'separate_images' in params:
            query_params.append(('separateImages', params['separate_images']))
        if 'slides_as_images' in params:
            query_params.append(('slidesAsImages', params['slides_as_images']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/pptx', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_svg(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to SVG format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_svg(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool compress_output_to_zip_archive: Specifies whether output will be created as one zip-archive.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_svg_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_svg_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_svg_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to SVG format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_svg_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool compress_output_to_zip_archive: Specifies whether output will be created as one zip-archive.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'compress_output_to_zip_archive', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_svg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_svg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'compress_output_to_zip_archive' in params:
            query_params.append(('compressOutputToZipArchive', params['compress_output_to_zip_archive']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/svg', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_tiff(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_tiff(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_tiff_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_tiff_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_tiff_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_tiff_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'brightness', 'compression', 'color_depth', 'left_margin', 'right_margin', 'top_margin', 'bottom_margin', 'orientation', 'skip_blank_pages', 'width', 'height', 'x_resolution', 'y_resolution', 'page_index', 'page_count', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'brightness' in params:
            query_params.append(('brightness', params['brightness']))
        if 'compression' in params:
            query_params.append(('compression', params['compression']))
        if 'color_depth' in params:
            query_params.append(('colorDepth', params['color_depth']))
        if 'left_margin' in params:
            query_params.append(('leftMargin', params['left_margin']))
        if 'right_margin' in params:
            query_params.append(('rightMargin', params['right_margin']))
        if 'top_margin' in params:
            query_params.append(('topMargin', params['top_margin']))
        if 'bottom_margin' in params:
            query_params.append(('bottomMargin', params['bottom_margin']))
        if 'orientation' in params:
            query_params.append(('orientation', params['orientation']))
        if 'skip_blank_pages' in params:
            query_params.append(('skipBlankPages', params['skip_blank_pages']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'x_resolution' in params:
            query_params.append(('xResolution', params['x_resolution']))
        if 'y_resolution' in params:
            query_params.append(('yResolution', params['y_resolution']))
        if 'page_index' in params:
            query_params.append(('pageIndex', params['page_index']))
        if 'page_count' in params:
            query_params.append(('pageCount', params['page_count']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/tiff', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_xls(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XLS format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xls(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_xls_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_xls_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_xls_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XLS format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xls_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_xls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_xls`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/xls', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_xml(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XML format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xml(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_xml_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_xml_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_xml_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XML format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xml_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/xml', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pdf_in_storage_to_xps(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XPS format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xps(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pdf_in_storage_to_xps_with_http_info(name, **kwargs)
        else:
            (data) = self.get_pdf_in_storage_to_xps_with_http_info(name, **kwargs)
            return data

    def get_pdf_in_storage_to_xps_with_http_info(self, name, **kwargs):
        """
        Converts PDF document (located on storage) to XPS format and returns resulting file in response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pdf_in_storage_to_xps_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pdf_in_storage_to_xps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pdf_in_storage_to_xps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/xps', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_segment(self, name, page_number, fragment_number, segment_number, **kwargs):
        """
        Read segment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_segment(name, page_number, fragment_number, segment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param int segment_number: (required)
        :param str storage:
        :param str folder:
        :return: TextItemResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_segment_with_http_info(name, page_number, fragment_number, segment_number, **kwargs)
        else:
            (data) = self.get_segment_with_http_info(name, page_number, fragment_number, segment_number, **kwargs)
            return data

    def get_segment_with_http_info(self, name, page_number, fragment_number, segment_number, **kwargs):
        """
        Read segment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_segment_with_http_info(name, page_number, fragment_number, segment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param int segment_number: (required)
        :param str storage:
        :param str folder:
        :return: TextItemResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'fragment_number', 'segment_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_segment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_segment`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_segment`")
        # verify the required parameter 'fragment_number' is set
        if ('fragment_number' not in params) or (params['fragment_number'] is None):
            raise ValueError("Missing the required parameter `fragment_number` when calling `get_segment`")
        # verify the required parameter 'segment_number' is set
        if ('segment_number' not in params) or (params['segment_number'] is None):
            raise ValueError("Missing the required parameter `segment_number` when calling `get_segment`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'fragment_number' in params:
            path_params['fragmentNumber'] = params['fragment_number']
        if 'segment_number' in params:
            path_params['segmentNumber'] = params['segment_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments/{segmentNumber}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextItemResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_segment_text_format(self, name, page_number, fragment_number, segment_number, **kwargs):
        """
        Read segment text format.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_segment_text_format(name, page_number, fragment_number, segment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param int segment_number: (required)
        :param str storage:
        :param str folder:
        :return: TextFormatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_segment_text_format_with_http_info(name, page_number, fragment_number, segment_number, **kwargs)
        else:
            (data) = self.get_segment_text_format_with_http_info(name, page_number, fragment_number, segment_number, **kwargs)
            return data

    def get_segment_text_format_with_http_info(self, name, page_number, fragment_number, segment_number, **kwargs):
        """
        Read segment text format.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_segment_text_format_with_http_info(name, page_number, fragment_number, segment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param int segment_number: (required)
        :param str storage:
        :param str folder:
        :return: TextFormatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'fragment_number', 'segment_number', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_segment_text_format" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_segment_text_format`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_segment_text_format`")
        # verify the required parameter 'fragment_number' is set
        if ('fragment_number' not in params) or (params['fragment_number'] is None):
            raise ValueError("Missing the required parameter `fragment_number` when calling `get_segment_text_format`")
        # verify the required parameter 'segment_number' is set
        if ('segment_number' not in params) or (params['segment_number'] is None):
            raise ValueError("Missing the required parameter `segment_number` when calling `get_segment_text_format`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'fragment_number' in params:
            path_params['fragmentNumber'] = params['fragment_number']
        if 'segment_number' in params:
            path_params['segmentNumber'] = params['segment_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments/{segmentNumber}/textformat', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextFormatResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_segments(self, name, page_number, fragment_number, **kwargs):
        """
        Read fragment segments.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_segments(name, page_number, fragment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_segments_with_http_info(name, page_number, fragment_number, **kwargs)
        else:
            (data) = self.get_segments_with_http_info(name, page_number, fragment_number, **kwargs)
            return data

    def get_segments_with_http_info(self, name, page_number, fragment_number, **kwargs):
        """
        Read fragment segments.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_segments_with_http_info(name, page_number, fragment_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param int fragment_number: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'fragment_number', 'with_empty', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_segments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_segments`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `get_segments`")
        # verify the required parameter 'fragment_number' is set
        if ('fragment_number' not in params) or (params['fragment_number'] is None):
            raise ValueError("Missing the required parameter `fragment_number` when calling `get_segments`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'fragment_number' in params:
            path_params['fragmentNumber'] = params['fragment_number']

        query_params = []
        if 'with_empty' in params:
            query_params.append(('withEmpty', params['with_empty']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextItemsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_text(self, name, x, y, width, height, **kwargs):
        """
        Read document text.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text(name, x, y, width, height, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int x: (required)
        :param int y: (required)
        :param int width: (required)
        :param int height: (required)
        :param list[str] format: List of formats for search.
        :param str regex: Formats are specified as a regular expression.
        :param bool split_rects: Split result fragments (default is true).
        :param str folder: The document folder.
        :return: TextRectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_text_with_http_info(name, x, y, width, height, **kwargs)
        else:
            (data) = self.get_text_with_http_info(name, x, y, width, height, **kwargs)
            return data

    def get_text_with_http_info(self, name, x, y, width, height, **kwargs):
        """
        Read document text.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text_with_http_info(name, x, y, width, height, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int x: (required)
        :param int y: (required)
        :param int width: (required)
        :param int height: (required)
        :param list[str] format: List of formats for search.
        :param str regex: Formats are specified as a regular expression.
        :param bool split_rects: Split result fragments (default is true).
        :param str folder: The document folder.
        :return: TextRectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x', 'y', 'width', 'height', 'format', 'regex', 'split_rects', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_text`")
        # verify the required parameter 'x' is set
        if ('x' not in params) or (params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `get_text`")
        # verify the required parameter 'y' is set
        if ('y' not in params) or (params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `get_text`")
        # verify the required parameter 'width' is set
        if ('width' not in params) or (params['width'] is None):
            raise ValueError("Missing the required parameter `width` when calling `get_text`")
        # verify the required parameter 'height' is set
        if ('height' not in params) or (params['height'] is None):
            raise ValueError("Missing the required parameter `height` when calling `get_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
            collection_formats['format'] = 'multi'
        if 'regex' in params:
            query_params.append(('regex', params['regex']))
        if 'x' in params:
            query_params.append(('X', params['x']))
        if 'y' in params:
            query_params.append(('Y', params['y']))
        if 'width' in params:
            query_params.append(('Width', params['width']))
        if 'height' in params:
            query_params.append(('Height', params['height']))
        if 'split_rects' in params:
            query_params.append(('splitRects', params['split_rects']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/text', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextRectsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_text_items(self, name, **kwargs):
        """
        Read document text items.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text_items(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_text_items_with_http_info(name, **kwargs)
        else:
            (data) = self.get_text_items_with_http_info(name, **kwargs)
            return data

    def get_text_items_with_http_info(self, name, **kwargs):
        """
        Read document text items.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_text_items_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str with_empty:
        :param str storage:
        :param str folder:
        :return: TextItemsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'with_empty', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_text_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_text_items`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'with_empty' in params:
            query_params.append(('withEmpty', params['with_empty']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/textItems', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextItemsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_verify_signature(self, name, sign_name, **kwargs):
        """
        Verify signature document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_verify_signature(name, sign_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str sign_name: Sign name. (required)
        :param str folder: The document folder.
        :return: SignatureVerifyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_verify_signature_with_http_info(name, sign_name, **kwargs)
        else:
            (data) = self.get_verify_signature_with_http_info(name, sign_name, **kwargs)
            return data

    def get_verify_signature_with_http_info(self, name, sign_name, **kwargs):
        """
        Verify signature document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_verify_signature_with_http_info(name, sign_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str sign_name: Sign name. (required)
        :param str folder: The document folder.
        :return: SignatureVerifyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'sign_name', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_verify_signature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_verify_signature`")
        # verify the required parameter 'sign_name' is set
        if ('sign_name' not in params) or (params['sign_name'] is None):
            raise ValueError("Missing the required parameter `sign_name` when calling `get_verify_signature`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'sign_name' in params:
            query_params.append(('signName', params['sign_name']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/verifySignature', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SignatureVerifyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_words_per_page(self, name, **kwargs):
        """
        Get number of words per document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_words_per_page(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: WordCountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_words_per_page_with_http_info(name, **kwargs)
        else:
            (data) = self.get_words_per_page_with_http_info(name, **kwargs)
            return data

    def get_words_per_page_with_http_info(self, name, **kwargs):
        """
        Get number of words per document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_words_per_page_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: WordCountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_words_per_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_words_per_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/wordCount', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='WordCountResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_xfa_pdf_in_storage_to_acro_form(self, name, **kwargs):
        """
        Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xfa_pdf_in_storage_to_acro_form(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_xfa_pdf_in_storage_to_acro_form_with_http_info(name, **kwargs)
        else:
            (data) = self.get_xfa_pdf_in_storage_to_acro_form_with_http_info(name, **kwargs)
            return data

    def get_xfa_pdf_in_storage_to_acro_form_with_http_info(self, name, **kwargs):
        """
        Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_xfa_pdf_in_storage_to_acro_form_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_xfa_pdf_in_storage_to_acro_form" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_xfa_pdf_in_storage_to_acro_form`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/xfatoacroform', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_append_document(self, name, **kwargs):
        """
        Append document to existing one.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_append_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The original document name. (required)
        :param AppendDocument append_document: with the append document data.
        :param str append_file: Append file server path.
        :param int start_page: Appending start page.
        :param int end_page: Appending end page.
        :param str storage: The documents storage.
        :param str folder: The original document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_append_document_with_http_info(name, **kwargs)
        else:
            (data) = self.post_append_document_with_http_info(name, **kwargs)
            return data

    def post_append_document_with_http_info(self, name, **kwargs):
        """
        Append document to existing one.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_append_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The original document name. (required)
        :param AppendDocument append_document: with the append document data.
        :param str append_file: Append file server path.
        :param int start_page: Appending start page.
        :param int end_page: Appending end page.
        :param str storage: The documents storage.
        :param str folder: The original document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'append_document', 'append_file', 'start_page', 'end_page', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_append_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_append_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'append_file' in params:
            query_params.append(('appendFile', params['append_file']))
        if 'start_page' in params:
            query_params.append(('startPage', params['start_page']))
        if 'end_page' in params:
            query_params.append(('endPage', params['end_page']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'append_document' in params:
            body_params = params['append_document']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/appendDocument', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_create_field(self, name, page, **kwargs):
        """
        Create field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_create_field(name, page, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page: Document page number. (required)
        :param Field field: with the field data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_create_field_with_http_info(name, page, **kwargs)
        else:
            (data) = self.post_create_field_with_http_info(name, page, **kwargs)
            return data

    def post_create_field_with_http_info(self, name, page, **kwargs):
        """
        Create field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_create_field_with_http_info(name, page, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page: Document page number. (required)
        :param Field field: with the field data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_create_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_create_field`")
        # verify the required parameter 'page' is set
        if ('page' not in params) or (params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `post_create_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/fields', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_replace_text(self, name, text_replace, **kwargs):
        """
        Document's replace text method. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_replace_text(name, text_replace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param TextReplaceRequest text_replace: (required)
        :param str storage:
        :param str folder:
        :return: DocumentTextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_replace_text_with_http_info(name, text_replace, **kwargs)
        else:
            (data) = self.post_document_replace_text_with_http_info(name, text_replace, **kwargs)
            return data

    def post_document_replace_text_with_http_info(self, name, text_replace, **kwargs):
        """
        Document's replace text method. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_replace_text_with_http_info(name, text_replace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param TextReplaceRequest text_replace: (required)
        :param str storage:
        :param str folder:
        :return: DocumentTextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'text_replace', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_replace_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_replace_text`")
        # verify the required parameter 'text_replace' is set
        if ('text_replace' not in params) or (params['text_replace'] is None):
            raise ValueError("Missing the required parameter `text_replace` when calling `post_document_replace_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_replace' in params:
            body_params = params['text_replace']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/replaceText', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentTextReplaceResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_replace_text_list(self, name, text_replace_list_request, **kwargs):
        """
        Document's replace text method. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_replace_text_list(name, text_replace_list_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param TextReplaceListRequest text_replace_list_request: (required)
        :param str storage:
        :param str folder:
        :return: DocumentTextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_replace_text_list_with_http_info(name, text_replace_list_request, **kwargs)
        else:
            (data) = self.post_document_replace_text_list_with_http_info(name, text_replace_list_request, **kwargs)
            return data

    def post_document_replace_text_list_with_http_info(self, name, text_replace_list_request, **kwargs):
        """
        Document's replace text method. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_replace_text_list_with_http_info(name, text_replace_list_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param TextReplaceListRequest text_replace_list_request: (required)
        :param str storage:
        :param str folder:
        :return: DocumentTextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'text_replace_list_request', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_replace_text_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_replace_text_list`")
        # verify the required parameter 'text_replace_list_request' is set
        if ('text_replace_list_request' not in params) or (params['text_replace_list_request'] is None):
            raise ValueError("Missing the required parameter `text_replace_list_request` when calling `post_document_replace_text_list`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_replace_list_request' in params:
            body_params = params['text_replace_list_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/replaceTextList', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentTextReplaceResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_document_text_replace(self, name, text_replace, **kwargs):
        """
        Document's replace text method.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_text_replace(name, text_replace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param TextReplaceListRequest text_replace: (required)
        :param str storage:
        :param str folder:
        :return: TextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_document_text_replace_with_http_info(name, text_replace, **kwargs)
        else:
            (data) = self.post_document_text_replace_with_http_info(name, text_replace, **kwargs)
            return data

    def post_document_text_replace_with_http_info(self, name, text_replace, **kwargs):
        """
        Document's replace text method.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_document_text_replace_with_http_info(name, text_replace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param TextReplaceListRequest text_replace: (required)
        :param str storage:
        :param str folder:
        :return: TextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'text_replace', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_text_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_document_text_replace`")
        # verify the required parameter 'text_replace' is set
        if ('text_replace' not in params) or (params['text_replace'] is None):
            raise ValueError("Missing the required parameter `text_replace` when calling `post_document_text_replace`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_replace' in params:
            body_params = params['text_replace']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/text/replace', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextReplaceResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_move_page(self, name, page_number, new_index, **kwargs):
        """
        Move page to new position.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_move_page(name, page_number, new_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int new_index: The new page position/index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_move_page_with_http_info(name, page_number, new_index, **kwargs)
        else:
            (data) = self.post_move_page_with_http_info(name, page_number, new_index, **kwargs)
            return data

    def post_move_page_with_http_info(self, name, page_number, new_index, **kwargs):
        """
        Move page to new position.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_move_page_with_http_info(name, page_number, new_index, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int new_index: The new page position/index. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'new_index', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_move_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_move_page`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_move_page`")
        # verify the required parameter 'new_index' is set
        if ('new_index' not in params) or (params['new_index'] is None):
            raise ValueError("Missing the required parameter `new_index` when calling `post_move_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'new_index' in params:
            query_params.append(('newIndex', params['new_index']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/movePage', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_optimize_document(self, name, **kwargs):
        """
        Optimize document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_optimize_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param OptimizeOptions options: The optimization options.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_optimize_document_with_http_info(name, **kwargs)
        else:
            (data) = self.post_optimize_document_with_http_info(name, **kwargs)
            return data

    def post_optimize_document_with_http_info(self, name, **kwargs):
        """
        Optimize document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_optimize_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param OptimizeOptions options: The optimization options.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'options', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_optimize_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_optimize_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'options' in params:
            body_params = params['options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/optimize', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_replace_text(self, name, page_number, text_replace, **kwargs):
        """
        Page's replace text method. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_replace_text(name, page_number, text_replace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param TextReplaceRequest text_replace: (required)
        :param str storage:
        :param str folder:
        :return: PageTextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_replace_text_with_http_info(name, page_number, text_replace, **kwargs)
        else:
            (data) = self.post_page_replace_text_with_http_info(name, page_number, text_replace, **kwargs)
            return data

    def post_page_replace_text_with_http_info(self, name, page_number, text_replace, **kwargs):
        """
        Page's replace text method. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_replace_text_with_http_info(name, page_number, text_replace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param TextReplaceRequest text_replace: (required)
        :param str storage:
        :param str folder:
        :return: PageTextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'text_replace', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_replace_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_replace_text`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_replace_text`")
        # verify the required parameter 'text_replace' is set
        if ('text_replace' not in params) or (params['text_replace'] is None):
            raise ValueError("Missing the required parameter `text_replace` when calling `post_page_replace_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_replace' in params:
            body_params = params['text_replace']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/replaceText', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageTextReplaceResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_replace_text_list(self, name, page_number, text_replace_list_request, **kwargs):
        """
        Page's replace text method. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_replace_text_list(name, page_number, text_replace_list_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param TextReplaceListRequest text_replace_list_request: (required)
        :param str storage:
        :param str folder:
        :return: PageTextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_replace_text_list_with_http_info(name, page_number, text_replace_list_request, **kwargs)
        else:
            (data) = self.post_page_replace_text_list_with_http_info(name, page_number, text_replace_list_request, **kwargs)
            return data

    def post_page_replace_text_list_with_http_info(self, name, page_number, text_replace_list_request, **kwargs):
        """
        Page's replace text method. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_replace_text_list_with_http_info(name, page_number, text_replace_list_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param TextReplaceListRequest text_replace_list_request: (required)
        :param str storage:
        :param str folder:
        :return: PageTextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'text_replace_list_request', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_replace_text_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_replace_text_list`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_replace_text_list`")
        # verify the required parameter 'text_replace_list_request' is set
        if ('text_replace_list_request' not in params) or (params['text_replace_list_request'] is None):
            raise ValueError("Missing the required parameter `text_replace_list_request` when calling `post_page_replace_text_list`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_replace_list_request' in params:
            body_params = params['text_replace_list_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/replaceTextList', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageTextReplaceResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_page_text_replace(self, name, page_number, text_replace_list_request, **kwargs):
        """
        Page's replace text method.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_text_replace(name, page_number, text_replace_list_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param TextReplaceListRequest text_replace_list_request: (required)
        :param str storage:
        :param str folder:
        :return: TextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_page_text_replace_with_http_info(name, page_number, text_replace_list_request, **kwargs)
        else:
            (data) = self.post_page_text_replace_with_http_info(name, page_number, text_replace_list_request, **kwargs)
            return data

    def post_page_text_replace_with_http_info(self, name, page_number, text_replace_list_request, **kwargs):
        """
        Page's replace text method.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_page_text_replace_with_http_info(name, page_number, text_replace_list_request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param int page_number: (required)
        :param TextReplaceListRequest text_replace_list_request: (required)
        :param str storage:
        :param str folder:
        :return: TextReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'text_replace_list_request', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_page_text_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_page_text_replace`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_page_text_replace`")
        # verify the required parameter 'text_replace_list_request' is set
        if ('text_replace_list_request' not in params) or (params['text_replace_list_request'] is None):
            raise ValueError("Missing the required parameter `text_replace_list_request` when calling `post_page_text_replace`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'text_replace_list_request' in params:
            body_params = params['text_replace_list_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/text/replace', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TextReplaceResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_replace_image(self, name, page_number, image_number, **kwargs):
        """
        Replace document image.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_replace_image(name, page_number, image_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int image_number: The image number. (required)
        :param str image_file: Path to image file if specified. Request content is used otherwise.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file image: Image file.
        :return: ImageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_replace_image_with_http_info(name, page_number, image_number, **kwargs)
        else:
            (data) = self.post_replace_image_with_http_info(name, page_number, image_number, **kwargs)
            return data

    def post_replace_image_with_http_info(self, name, page_number, image_number, **kwargs):
        """
        Replace document image.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_replace_image_with_http_info(name, page_number, image_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param int image_number: The image number. (required)
        :param str image_file: Path to image file if specified. Request content is used otherwise.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param file image: Image file.
        :return: ImageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'image_number', 'image_file', 'storage', 'folder', 'image']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_replace_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_replace_image`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_replace_image`")
        # verify the required parameter 'image_number' is set
        if ('image_number' not in params) or (params['image_number'] is None):
            raise ValueError("Missing the required parameter `image_number` when calling `post_replace_image`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']
        if 'image_number' in params:
            path_params['imageNumber'] = params['image_number']

        query_params = []
        if 'image_file' in params:
            query_params.append(('imageFile', params['image_file']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/images/{imageNumber}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImageResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_sign_document(self, name, **kwargs):
        """
        Sign document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_sign_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param Signature signature: Signature object containing signature data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_sign_document_with_http_info(name, **kwargs)
        else:
            (data) = self.post_sign_document_with_http_info(name, **kwargs)
            return data

    def post_sign_document_with_http_info(self, name, **kwargs):
        """
        Sign document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_sign_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param Signature signature: Signature object containing signature data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'signature', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_sign_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_sign_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'signature' in params:
            body_params = params['signature']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/sign', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_sign_page(self, name, page_number, **kwargs):
        """
        Sign page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_sign_page(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Signature signature: Signature object containing signature data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_sign_page_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.post_sign_page_with_http_info(name, page_number, **kwargs)
            return data

    def post_sign_page_with_http_info(self, name, page_number, **kwargs):
        """
        Sign page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_sign_page_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Signature signature: Signature object containing signature data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'signature', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_sign_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_sign_page`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `post_sign_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'signature' in params:
            body_params = params['signature']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/sign', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_split_document(self, name, **kwargs):
        """
        Split document to parts.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_split_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str format: Resulting documents format.
        :param int _from: Start page if defined.
        :param int to: End page if defined.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SplitResultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_split_document_with_http_info(name, **kwargs)
        else:
            (data) = self.post_split_document_with_http_info(name, **kwargs)
            return data

    def post_split_document_with_http_info(self, name, **kwargs):
        """
        Split document to parts.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_split_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Document name. (required)
        :param str format: Resulting documents format.
        :param int _from: Start page if defined.
        :param int to: End page if defined.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SplitResultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', '_from', 'to', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_split_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_split_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
        if '_from' in params:
            query_params.append(('from', params['_from']))
        if 'to' in params:
            query_params.append(('to', params['to']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/split', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SplitResultResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_add_new_page(self, name, **kwargs):
        """
        Add new page to end of the document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_new_page(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_add_new_page_with_http_info(name, **kwargs)
        else:
            (data) = self.put_add_new_page_with_http_info(name, **kwargs)
            return data

    def put_add_new_page_with_http_info(self, name, **kwargs):
        """
        Add new page to end of the document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_new_page_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: DocumentPagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_add_new_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_add_new_page`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPagesResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_add_paragraph(self, name, page_number, **kwargs):
        """
        Add text to PDF document page. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_paragraph(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Name of the document to which text should be added. (required)
        :param int page_number: Number of page (starting with 1) to which text should be added. (required)
        :param Paragraph paragraph: Paragraph data.
        :param str storage: File storage to be used.
        :param str folder: Document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_add_paragraph_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.put_add_paragraph_with_http_info(name, page_number, **kwargs)
            return data

    def put_add_paragraph_with_http_info(self, name, page_number, **kwargs):
        """
        Add text to PDF document page. Deprecated
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_paragraph_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Name of the document to which text should be added. (required)
        :param int page_number: Number of page (starting with 1) to which text should be added. (required)
        :param Paragraph paragraph: Paragraph data.
        :param str storage: File storage to be used.
        :param str folder: Document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'paragraph', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_add_paragraph" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_add_paragraph`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_add_paragraph`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'paragraph' in params:
            body_params = params['paragraph']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/paragraph', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_add_text(self, name, page_number, **kwargs):
        """
        Add text to PDF document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_text(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: Number of page (starting from 1). (required)
        :param Paragraph paragraph: Paragraph data.
        :param str folder: Document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_add_text_with_http_info(name, page_number, **kwargs)
        else:
            (data) = self.put_add_text_with_http_info(name, page_number, **kwargs)
            return data

    def put_add_text_with_http_info(self, name, page_number, **kwargs):
        """
        Add text to PDF document page.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_add_text_with_http_info(name, page_number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: Number of page (starting from 1). (required)
        :param Paragraph paragraph: Paragraph data.
        :param str folder: Document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'paragraph', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_add_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_add_text`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_add_text`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'paragraph' in params:
            body_params = params['paragraph']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/text', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_convert_document(self, **kwargs):
        """
        Convert document from request content to format specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_convert_document(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str format: The format to convert.
        :param str url:
        :param str out_path: Path to save result
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_convert_document_with_http_info(**kwargs)
        else:
            (data) = self.put_convert_document_with_http_info(**kwargs)
            return data

    def put_convert_document_with_http_info(self, **kwargs):
        """
        Convert document from request content to format specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_convert_document_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str format: The format to convert.
        :param str url:
        :param str out_path: Path to save result
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'url', 'out_path', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_convert_document" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'url' in params:
            query_params.append(('url', params['url']))
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_create(self, path, file, **kwargs):
        """
        Upload a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_create(path, file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
        :param file file: File to upload (required)
        :param str version_id: Source file's version
        :param str storage: User's storage name
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_create_with_http_info(path, file, **kwargs)
        else:
            (data) = self.put_create_with_http_info(path, file, **kwargs)
            return data

    def put_create_with_http_info(self, path, file, **kwargs):
        """
        Upload a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_create_with_http_info(path, file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
        :param file file: File to upload (required)
        :param str version_id: Source file's version
        :param str storage: User's storage name
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'file', 'version_id', 'storage']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `put_create`")
        # verify the required parameter 'file' is set
        if ('file' not in params) or (params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `put_create`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['File'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/file', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_create_document(self, name, **kwargs):
        """
        Create new document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_create_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The new document name. (required)
        :param str template_file: The template file server path if defined.
        :param str data_file: The data file path (for xml template only).
        :param str template_type: The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex.
        :param str storage: The document storage.
        :param str folder: The new document folder.
        :param str url: The url of web page if defined.
        :param bool fit_size: Draw a margin around content in resulting pdf.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_create_document_with_http_info(name, **kwargs)
        else:
            (data) = self.put_create_document_with_http_info(name, **kwargs)
            return data

    def put_create_document_with_http_info(self, name, **kwargs):
        """
        Create new document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_create_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The new document name. (required)
        :param str template_file: The template file server path if defined.
        :param str data_file: The data file path (for xml template only).
        :param str template_type: The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex.
        :param str storage: The document storage.
        :param str folder: The new document folder.
        :param str url: The url of web page if defined.
        :param bool fit_size: Draw a margin around content in resulting pdf.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'template_file', 'data_file', 'template_type', 'storage', 'folder', 'url', 'fit_size']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_create_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_create_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'template_file' in params:
            query_params.append(('templateFile', params['template_file']))
        if 'data_file' in params:
            query_params.append(('dataFile', params['data_file']))
        if 'template_type' in params:
            query_params.append(('templateType', params['template_type']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'url' in params:
            query_params.append(('url', params['url']))
        if 'fit_size' in params:
            query_params.append(('fitSize', params['fit_size']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_create_document_from_images(self, name, **kwargs):
        """
        Create new document from images.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_create_document_from_images(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The new document name. (required)
        :param ImagesListRequest images: The images file paths set.  
        :param bool ocr: To create OCR layer for image or not.
        :param str ocr_lang: The language which is defined for OCR engine. Default is eng.
        :param str storage: The document storage.
        :param str folder: The new document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_create_document_from_images_with_http_info(name, **kwargs)
        else:
            (data) = self.put_create_document_from_images_with_http_info(name, **kwargs)
            return data

    def put_create_document_from_images_with_http_info(self, name, **kwargs):
        """
        Create new document from images.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_create_document_from_images_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The new document name. (required)
        :param ImagesListRequest images: The images file paths set.  
        :param bool ocr: To create OCR layer for image or not.
        :param str ocr_lang: The language which is defined for OCR engine. Default is eng.
        :param str storage: The document storage.
        :param str folder: The new document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'images', 'ocr', 'ocr_lang', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_create_document_from_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_create_document_from_images`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'ocr' in params:
            query_params.append(('ocr', params['ocr']))
        if 'ocr_lang' in params:
            query_params.append(('ocrLang', params['ocr_lang']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'images' in params:
            body_params = params['images']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/fromimages', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_document_save_as_tiff(self, name, **kwargs):
        """
        Save document as Tiff image.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_document_save_as_tiff(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param TiffExportOptions export_options: with tiff export options.
        :param str result_file: The resulting file.
        :param float brightness: The image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_document_save_as_tiff_with_http_info(name, **kwargs)
        else:
            (data) = self.put_document_save_as_tiff_with_http_info(name, **kwargs)
            return data

    def put_document_save_as_tiff_with_http_info(self, name, **kwargs):
        """
        Save document as Tiff image.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_document_save_as_tiff_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param TiffExportOptions export_options: with tiff export options.
        :param str result_file: The resulting file.
        :param float brightness: The image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'export_options', 'result_file', 'brightness', 'compression', 'color_depth', 'left_margin', 'right_margin', 'top_margin', 'bottom_margin', 'orientation', 'skip_blank_pages', 'width', 'height', 'x_resolution', 'y_resolution', 'page_index', 'page_count', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_document_save_as_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_document_save_as_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'result_file' in params:
            query_params.append(('resultFile', params['result_file']))
        if 'brightness' in params:
            query_params.append(('brightness', params['brightness']))
        if 'compression' in params:
            query_params.append(('compression', params['compression']))
        if 'color_depth' in params:
            query_params.append(('colorDepth', params['color_depth']))
        if 'left_margin' in params:
            query_params.append(('leftMargin', params['left_margin']))
        if 'right_margin' in params:
            query_params.append(('rightMargin', params['right_margin']))
        if 'top_margin' in params:
            query_params.append(('topMargin', params['top_margin']))
        if 'bottom_margin' in params:
            query_params.append(('bottomMargin', params['bottom_margin']))
        if 'orientation' in params:
            query_params.append(('orientation', params['orientation']))
        if 'skip_blank_pages' in params:
            query_params.append(('skipBlankPages', params['skip_blank_pages']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'x_resolution' in params:
            query_params.append(('xResolution', params['x_resolution']))
        if 'y_resolution' in params:
            query_params.append(('yResolution', params['y_resolution']))
        if 'page_index' in params:
            query_params.append(('pageIndex', params['page_index']))
        if 'page_count' in params:
            query_params.append(('pageCount', params['page_count']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'export_options' in params:
            body_params = params['export_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/SaveAs/tiff', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_fields_flatten(self, name, **kwargs):
        """
        Flatten form fields in document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_fields_flatten(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_fields_flatten_with_http_info(name, **kwargs)
        else:
            (data) = self.put_fields_flatten_with_http_info(name, **kwargs)
            return data

    def put_fields_flatten_with_http_info(self, name, **kwargs):
        """
        Flatten form fields in document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_fields_flatten_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_fields_flatten" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_fields_flatten`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/fields/flatten', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_merge_documents(self, name, **kwargs):
        """
        Merge a list of documents.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_merge_documents(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Resulting documen name. (required)
        :param MergeDocuments merge_documents: with a list of documents.
        :param str storage: Resulting document storage.
        :param str folder: Resulting document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_merge_documents_with_http_info(name, **kwargs)
        else:
            (data) = self.put_merge_documents_with_http_info(name, **kwargs)
            return data

    def put_merge_documents_with_http_info(self, name, **kwargs):
        """
        Merge a list of documents.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_merge_documents_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Resulting documen name. (required)
        :param MergeDocuments merge_documents: with a list of documents.
        :param str storage: Resulting document storage.
        :param str folder: Resulting document folder.
        :return: DocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'merge_documents', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_merge_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_merge_documents`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'merge_documents' in params:
            body_params = params['merge_documents']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/merge', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_page_add_stamp(self, name, page_number, stamp, **kwargs):
        """
        Add page stamp.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_add_stamp(name, page_number, stamp, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Stamp stamp: with data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_page_add_stamp_with_http_info(name, page_number, stamp, **kwargs)
        else:
            (data) = self.put_page_add_stamp_with_http_info(name, page_number, stamp, **kwargs)
            return data

    def put_page_add_stamp_with_http_info(self, name, page_number, stamp, **kwargs):
        """
        Add page stamp.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_page_add_stamp_with_http_info(name, page_number, stamp, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param int page_number: The page number. (required)
        :param Stamp stamp: with data. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page_number', 'stamp', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_page_add_stamp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_page_add_stamp`")
        # verify the required parameter 'page_number' is set
        if ('page_number' not in params) or (params['page_number'] is None):
            raise ValueError("Missing the required parameter `page_number` when calling `put_page_add_stamp`")
        # verify the required parameter 'stamp' is set
        if ('stamp' not in params) or (params['stamp'] is None):
            raise ValueError("Missing the required parameter `stamp` when calling `put_page_add_stamp`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'page_number' in params:
            path_params['pageNumber'] = params['page_number']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stamp' in params:
            body_params = params['stamp']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/pages/{pageNumber}/stamp', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_doc(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_doc(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param int max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_doc_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_doc_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_doc_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_doc_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param int max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'add_return_to_line_end', 'format', 'image_resolution_x', 'image_resolution_y', 'max_distance_between_text_lines', 'mode', 'recognize_bullets', 'relative_horizontal_proximity', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_doc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_doc`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'add_return_to_line_end' in params:
            query_params.append(('addReturnToLineEnd', params['add_return_to_line_end']))
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'image_resolution_x' in params:
            query_params.append(('imageResolutionX', params['image_resolution_x']))
        if 'image_resolution_y' in params:
            query_params.append(('imageResolutionY', params['image_resolution_y']))
        if 'max_distance_between_text_lines' in params:
            query_params.append(('maxDistanceBetweenTextLines', params['max_distance_between_text_lines']))
        if 'mode' in params:
            query_params.append(('mode', params['mode']))
        if 'recognize_bullets' in params:
            query_params.append(('recognizeBullets', params['recognize_bullets']))
        if 'relative_horizontal_proximity' in params:
            query_params.append(('relativeHorizontalProximity', params['relative_horizontal_proximity']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/doc', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_epub(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_epub(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.epub) (required)
        :param str content_recognition_mode: roperty tunes conversion for this or that desirable method of recognition of content.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_epub_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_epub_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_epub_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_epub_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.epub) (required)
        :param str content_recognition_mode: roperty tunes conversion for this or that desirable method of recognition of content.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'content_recognition_mode', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_epub" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_epub`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'content_recognition_mode' in params:
            query_params.append(('contentRecognitionMode', params['content_recognition_mode']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/epub', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_html(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to Html format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_html(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.html) (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param int document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_html_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_html_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_html_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to Html format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_html_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.html) (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param int document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'additional_margin_width_in_points', 'compress_svg_graphics_if_any', 'convert_marked_content_to_layers', 'default_font_name', 'document_type', 'fixed_layout', 'image_resolution', 'minimal_line_width', 'prevent_glyphs_grouping', 'split_css_into_pages', 'split_into_pages', 'use_z_order', 'antialiasing_processing', 'css_class_names_prefix', 'explicit_list_of_saved_pages', 'font_encoding_strategy', 'font_saving_mode', 'html_markup_generation_mode', 'letters_positioning_method', 'pages_flow_type_depends_on_viewers_screen_size', 'parts_embedding_mode', 'raster_images_saving_mode', 'remove_empty_areas_on_top_and_bottom', 'save_shadowed_texts_as_transparent_texts', 'save_transparent_texts', 'special_folder_for_all_images', 'special_folder_for_svg_images', 'try_save_text_underlining_and_strikeouting_in_css', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_html" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_html`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'additional_margin_width_in_points' in params:
            query_params.append(('additionalMarginWidthInPoints', params['additional_margin_width_in_points']))
        if 'compress_svg_graphics_if_any' in params:
            query_params.append(('compressSvgGraphicsIfAny', params['compress_svg_graphics_if_any']))
        if 'convert_marked_content_to_layers' in params:
            query_params.append(('convertMarkedContentToLayers', params['convert_marked_content_to_layers']))
        if 'default_font_name' in params:
            query_params.append(('defaultFontName', params['default_font_name']))
        if 'document_type' in params:
            query_params.append(('documentType', params['document_type']))
        if 'fixed_layout' in params:
            query_params.append(('fixedLayout', params['fixed_layout']))
        if 'image_resolution' in params:
            query_params.append(('imageResolution', params['image_resolution']))
        if 'minimal_line_width' in params:
            query_params.append(('minimalLineWidth', params['minimal_line_width']))
        if 'prevent_glyphs_grouping' in params:
            query_params.append(('preventGlyphsGrouping', params['prevent_glyphs_grouping']))
        if 'split_css_into_pages' in params:
            query_params.append(('splitCssIntoPages', params['split_css_into_pages']))
        if 'split_into_pages' in params:
            query_params.append(('splitIntoPages', params['split_into_pages']))
        if 'use_z_order' in params:
            query_params.append(('useZOrder', params['use_z_order']))
        if 'antialiasing_processing' in params:
            query_params.append(('antialiasingProcessing', params['antialiasing_processing']))
        if 'css_class_names_prefix' in params:
            query_params.append(('cssClassNamesPrefix', params['css_class_names_prefix']))
        if 'explicit_list_of_saved_pages' in params:
            query_params.append(('explicitListOfSavedPages', params['explicit_list_of_saved_pages']))
            collection_formats['explicitListOfSavedPages'] = 'multi'
        if 'font_encoding_strategy' in params:
            query_params.append(('fontEncodingStrategy', params['font_encoding_strategy']))
        if 'font_saving_mode' in params:
            query_params.append(('fontSavingMode', params['font_saving_mode']))
        if 'html_markup_generation_mode' in params:
            query_params.append(('htmlMarkupGenerationMode', params['html_markup_generation_mode']))
        if 'letters_positioning_method' in params:
            query_params.append(('lettersPositioningMethod', params['letters_positioning_method']))
        if 'pages_flow_type_depends_on_viewers_screen_size' in params:
            query_params.append(('pagesFlowTypeDependsOnViewersScreenSize', params['pages_flow_type_depends_on_viewers_screen_size']))
        if 'parts_embedding_mode' in params:
            query_params.append(('partsEmbeddingMode', params['parts_embedding_mode']))
        if 'raster_images_saving_mode' in params:
            query_params.append(('rasterImagesSavingMode', params['raster_images_saving_mode']))
        if 'remove_empty_areas_on_top_and_bottom' in params:
            query_params.append(('removeEmptyAreasOnTopAndBottom', params['remove_empty_areas_on_top_and_bottom']))
        if 'save_shadowed_texts_as_transparent_texts' in params:
            query_params.append(('saveShadowedTextsAsTransparentTexts', params['save_shadowed_texts_as_transparent_texts']))
        if 'save_transparent_texts' in params:
            query_params.append(('saveTransparentTexts', params['save_transparent_texts']))
        if 'special_folder_for_all_images' in params:
            query_params.append(('specialFolderForAllImages', params['special_folder_for_all_images']))
        if 'special_folder_for_svg_images' in params:
            query_params.append(('specialFolderForSvgImages', params['special_folder_for_svg_images']))
        if 'try_save_text_underlining_and_strikeouting_in_css' in params:
            query_params.append(('trySaveTextUnderliningAndStrikeoutingInCss', params['try_save_text_underlining_and_strikeouting_in_css']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/html', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_la_te_x(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_la_te_x(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tex) (required)
        :param int pages_count: Pages count.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_la_te_x_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_la_te_x_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_la_te_x_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_la_te_x_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tex) (required)
        :param int pages_count: Pages count.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'pages_count', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_la_te_x" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_la_te_x`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'pages_count' in params:
            query_params.append(('pagesCount', params['pages_count']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/latex', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_mobi_xml(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_mobi_xml(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_mobi_xml_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_mobi_xml_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_mobi_xml_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_mobi_xml_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_mobi_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_mobi_xml`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/mobixml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_pdf_a(self, out_path, type, **kwargs):
        """
        Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_pdf_a(out_path, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str type: Type of PdfA format. (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_pdf_a_with_http_info(out_path, type, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_pdf_a_with_http_info(out_path, type, **kwargs)
            return data

    def put_pdf_in_request_to_pdf_a_with_http_info(self, out_path, type, **kwargs):
        """
        Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_pdf_a_with_http_info(out_path, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str type: Type of PdfA format. (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'type', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_pdf_a" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_pdf_a`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_pdf_in_request_to_pdf_a`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'type' in params:
            query_params.append(('type', params['type']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/pdfa', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_pptx(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_pptx(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_pptx_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_pptx_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_pptx_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_pptx_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'separate_images', 'slides_as_images', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_pptx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_pptx`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'separate_images' in params:
            query_params.append(('separateImages', params['separate_images']))
        if 'slides_as_images' in params:
            query_params.append(('slidesAsImages', params['slides_as_images']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/pptx', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_svg(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_svg(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.svg) (required)
        :param bool compress_output_to_zip_archive: Specifies whether output will be created as one zip-archive.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_svg_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_svg_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_svg_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_svg_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.svg) (required)
        :param bool compress_output_to_zip_archive: Specifies whether output will be created as one zip-archive.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'compress_output_to_zip_archive', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_svg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_svg`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'compress_output_to_zip_archive' in params:
            query_params.append(('compressOutputToZipArchive', params['compress_output_to_zip_archive']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/svg', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_tiff(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_tiff(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_tiff_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_tiff_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_tiff_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_tiff_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'brightness', 'compression', 'color_depth', 'left_margin', 'right_margin', 'top_margin', 'bottom_margin', 'orientation', 'skip_blank_pages', 'width', 'height', 'x_resolution', 'y_resolution', 'page_index', 'page_count', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_tiff`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'brightness' in params:
            query_params.append(('brightness', params['brightness']))
        if 'compression' in params:
            query_params.append(('compression', params['compression']))
        if 'color_depth' in params:
            query_params.append(('colorDepth', params['color_depth']))
        if 'left_margin' in params:
            query_params.append(('leftMargin', params['left_margin']))
        if 'right_margin' in params:
            query_params.append(('rightMargin', params['right_margin']))
        if 'top_margin' in params:
            query_params.append(('topMargin', params['top_margin']))
        if 'bottom_margin' in params:
            query_params.append(('bottomMargin', params['bottom_margin']))
        if 'orientation' in params:
            query_params.append(('orientation', params['orientation']))
        if 'skip_blank_pages' in params:
            query_params.append(('skipBlankPages', params['skip_blank_pages']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'x_resolution' in params:
            query_params.append(('xResolution', params['x_resolution']))
        if 'y_resolution' in params:
            query_params.append(('yResolution', params['y_resolution']))
        if 'page_index' in params:
            query_params.append(('pageIndex', params['page_index']))
        if 'page_count' in params:
            query_params.append(('pageCount', params['page_count']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/tiff', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_xls(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xls(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xls) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor
        :param bool uniform_worksheets: Uniform worksheets
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_xls_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_xls_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_xls_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xls_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xls) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor
        :param bool uniform_worksheets: Uniform worksheets
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_xls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_xls`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/xls', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_xml(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XML format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xml(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xml) (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_xml_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_xml_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_xml_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XML format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xml_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xml) (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_xml`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/xml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_request_to_xps(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xps(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xps) (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_request_to_xps_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_request_to_xps_with_http_info(out_path, **kwargs)
            return data

    def put_pdf_in_request_to_xps_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_request_to_xps_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xps) (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_request_to_xps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_request_to_xps`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/xps', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_doc(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_doc(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param int max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_doc_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_doc_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_doc_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_doc_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.doc) (required)
        :param bool add_return_to_line_end: Add return to line end.
        :param str format: Allows to specify .doc or .docx file format.
        :param int image_resolution_x: Image resolution X.
        :param int image_resolution_y: Image resolution Y.
        :param int max_distance_between_text_lines: Max distance between text lines.
        :param str mode: Allows to control how a PDF document is converted into a word processing document.
        :param bool recognize_bullets: Recognize bullets.
        :param float relative_horizontal_proximity: Relative horizontal proximity.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'add_return_to_line_end', 'format', 'image_resolution_x', 'image_resolution_y', 'max_distance_between_text_lines', 'mode', 'recognize_bullets', 'relative_horizontal_proximity', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_doc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_doc`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_doc`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'add_return_to_line_end' in params:
            query_params.append(('addReturnToLineEnd', params['add_return_to_line_end']))
        if 'format' in params:
            query_params.append(('format', params['format']))
        if 'image_resolution_x' in params:
            query_params.append(('imageResolutionX', params['image_resolution_x']))
        if 'image_resolution_y' in params:
            query_params.append(('imageResolutionY', params['image_resolution_y']))
        if 'max_distance_between_text_lines' in params:
            query_params.append(('maxDistanceBetweenTextLines', params['max_distance_between_text_lines']))
        if 'mode' in params:
            query_params.append(('mode', params['mode']))
        if 'recognize_bullets' in params:
            query_params.append(('recognizeBullets', params['recognize_bullets']))
        if 'relative_horizontal_proximity' in params:
            query_params.append(('relativeHorizontalProximity', params['relative_horizontal_proximity']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/doc', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_epub(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_epub(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.epub) (required)
        :param str content_recognition_mode: roperty tunes conversion for this or that desirable method of recognition of content.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_epub_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_epub_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_epub_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_epub_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.epub) (required)
        :param str content_recognition_mode: roperty tunes conversion for this or that desirable method of recognition of content.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'content_recognition_mode', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_epub" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_epub`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_epub`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'content_recognition_mode' in params:
            query_params.append(('contentRecognitionMode', params['content_recognition_mode']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/epub', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_html(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to Html format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_html(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.html) (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param int document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_html_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_html_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_html_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to Html format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_html_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.html) (required)
        :param int additional_margin_width_in_points: Defines width of margin that will be forcibly left around that output HTML-areas.
        :param bool compress_svg_graphics_if_any: The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
        :param bool convert_marked_content_to_layers: If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \"data-pdflayer\" attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
        :param str default_font_name: Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
        :param int document_type: Result document type.
        :param bool fixed_layout: The value indicating whether that HTML is created as fixed layout.
        :param int image_resolution: Resolution for image rendering.
        :param int minimal_line_width: This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
        :param bool prevent_glyphs_grouping: This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
        :param bool split_css_into_pages: When multipage-mode selected(i.e 'SplitIntoPages' is 'true'), then this attribute defines whether should be created separate CSS-file for each result HTML page.
        :param bool split_into_pages: The flag that indicates whether each page of source document will be converted into it's own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
        :param bool use_z_order: If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
        :param str antialiasing_processing: The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
        :param str css_class_names_prefix: When PDFtoHTML converter generates result CSSs, CSS class names (something like \".stl_01 {}\" ... \".stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
        :param list[int] explicit_list_of_saved_pages: With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
        :param str font_encoding_strategy: Defines encoding special rule to tune PDF decoding for current document.
        :param str font_saving_mode: Defines font saving mode that will be used during saving of PDF to desirable format.
        :param str html_markup_generation_mode: Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
        :param str letters_positioning_method: The mode of positioning of letters in words in result HTML.
        :param bool pages_flow_type_depends_on_viewers_screen_size: If attribute 'SplitOnPages=false', than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
        :param str parts_embedding_mode: It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
        :param str raster_images_saving_mode: Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
        :param bool remove_empty_areas_on_top_and_bottom: Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
        :param bool save_shadowed_texts_as_transparent_texts: Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
        :param bool save_transparent_texts: Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
        :param str special_folder_for_all_images: The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param str special_folder_for_svg_images: The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
        :param bool try_save_text_underlining_and_strikeouting_in_css: PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text's underlining and put this info into CSS instead of drawing of underlining graphically.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'additional_margin_width_in_points', 'compress_svg_graphics_if_any', 'convert_marked_content_to_layers', 'default_font_name', 'document_type', 'fixed_layout', 'image_resolution', 'minimal_line_width', 'prevent_glyphs_grouping', 'split_css_into_pages', 'split_into_pages', 'use_z_order', 'antialiasing_processing', 'css_class_names_prefix', 'explicit_list_of_saved_pages', 'font_encoding_strategy', 'font_saving_mode', 'html_markup_generation_mode', 'letters_positioning_method', 'pages_flow_type_depends_on_viewers_screen_size', 'parts_embedding_mode', 'raster_images_saving_mode', 'remove_empty_areas_on_top_and_bottom', 'save_shadowed_texts_as_transparent_texts', 'save_transparent_texts', 'special_folder_for_all_images', 'special_folder_for_svg_images', 'try_save_text_underlining_and_strikeouting_in_css', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_html" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_html`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_html`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'additional_margin_width_in_points' in params:
            query_params.append(('additionalMarginWidthInPoints', params['additional_margin_width_in_points']))
        if 'compress_svg_graphics_if_any' in params:
            query_params.append(('compressSvgGraphicsIfAny', params['compress_svg_graphics_if_any']))
        if 'convert_marked_content_to_layers' in params:
            query_params.append(('convertMarkedContentToLayers', params['convert_marked_content_to_layers']))
        if 'default_font_name' in params:
            query_params.append(('defaultFontName', params['default_font_name']))
        if 'document_type' in params:
            query_params.append(('documentType', params['document_type']))
        if 'fixed_layout' in params:
            query_params.append(('fixedLayout', params['fixed_layout']))
        if 'image_resolution' in params:
            query_params.append(('imageResolution', params['image_resolution']))
        if 'minimal_line_width' in params:
            query_params.append(('minimalLineWidth', params['minimal_line_width']))
        if 'prevent_glyphs_grouping' in params:
            query_params.append(('preventGlyphsGrouping', params['prevent_glyphs_grouping']))
        if 'split_css_into_pages' in params:
            query_params.append(('splitCssIntoPages', params['split_css_into_pages']))
        if 'split_into_pages' in params:
            query_params.append(('splitIntoPages', params['split_into_pages']))
        if 'use_z_order' in params:
            query_params.append(('useZOrder', params['use_z_order']))
        if 'antialiasing_processing' in params:
            query_params.append(('antialiasingProcessing', params['antialiasing_processing']))
        if 'css_class_names_prefix' in params:
            query_params.append(('cssClassNamesPrefix', params['css_class_names_prefix']))
        if 'explicit_list_of_saved_pages' in params:
            query_params.append(('explicitListOfSavedPages', params['explicit_list_of_saved_pages']))
            collection_formats['explicitListOfSavedPages'] = 'multi'
        if 'font_encoding_strategy' in params:
            query_params.append(('fontEncodingStrategy', params['font_encoding_strategy']))
        if 'font_saving_mode' in params:
            query_params.append(('fontSavingMode', params['font_saving_mode']))
        if 'html_markup_generation_mode' in params:
            query_params.append(('htmlMarkupGenerationMode', params['html_markup_generation_mode']))
        if 'letters_positioning_method' in params:
            query_params.append(('lettersPositioningMethod', params['letters_positioning_method']))
        if 'pages_flow_type_depends_on_viewers_screen_size' in params:
            query_params.append(('pagesFlowTypeDependsOnViewersScreenSize', params['pages_flow_type_depends_on_viewers_screen_size']))
        if 'parts_embedding_mode' in params:
            query_params.append(('partsEmbeddingMode', params['parts_embedding_mode']))
        if 'raster_images_saving_mode' in params:
            query_params.append(('rasterImagesSavingMode', params['raster_images_saving_mode']))
        if 'remove_empty_areas_on_top_and_bottom' in params:
            query_params.append(('removeEmptyAreasOnTopAndBottom', params['remove_empty_areas_on_top_and_bottom']))
        if 'save_shadowed_texts_as_transparent_texts' in params:
            query_params.append(('saveShadowedTextsAsTransparentTexts', params['save_shadowed_texts_as_transparent_texts']))
        if 'save_transparent_texts' in params:
            query_params.append(('saveTransparentTexts', params['save_transparent_texts']))
        if 'special_folder_for_all_images' in params:
            query_params.append(('specialFolderForAllImages', params['special_folder_for_all_images']))
        if 'special_folder_for_svg_images' in params:
            query_params.append(('specialFolderForSvgImages', params['special_folder_for_svg_images']))
        if 'try_save_text_underlining_and_strikeouting_in_css' in params:
            query_params.append(('trySaveTextUnderliningAndStrikeoutingInCss', params['try_save_text_underlining_and_strikeouting_in_css']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/html', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_la_te_x(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_la_te_x(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tex) (required)
        :param int pages_count: Pages count.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_la_te_x_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_la_te_x_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_la_te_x_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_la_te_x_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tex) (required)
        :param int pages_count: Pages count.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'pages_count', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_la_te_x" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_la_te_x`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_la_te_x`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'pages_count' in params:
            query_params.append(('pagesCount', params['pages_count']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/latex', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_mobi_xml(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_mobi_xml(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_mobi_xml_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_mobi_xml_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_mobi_xml_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_mobi_xml_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_mobi_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_mobi_xml`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_mobi_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/mobixml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_pdf_a(self, name, out_path, type, **kwargs):
        """
        Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_pdf_a(name, out_path, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str type: Type of PdfA format. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_pdf_a_with_http_info(name, out_path, type, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_pdf_a_with_http_info(name, out_path, type, **kwargs)
            return data

    def put_pdf_in_storage_to_pdf_a_with_http_info(self, name, out_path, type, **kwargs):
        """
        Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_pdf_a_with_http_info(name, out_path, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str type: Type of PdfA format. (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'type', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_pdf_a" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_pdf_a`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_pdf_a`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_pdf_in_storage_to_pdf_a`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'type' in params:
            query_params.append(('type', params['type']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/pdfa', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_pptx(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_pptx(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_pptx_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_pptx_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_pptx_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_pptx_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
        :param bool separate_images: Separate images.
        :param bool slides_as_images: Slides as images.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'separate_images', 'slides_as_images', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_pptx" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_pptx`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_pptx`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'separate_images' in params:
            query_params.append(('separateImages', params['separate_images']))
        if 'slides_as_images' in params:
            query_params.append(('slidesAsImages', params['slides_as_images']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/pptx', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_svg(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_svg(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.svg) (required)
        :param bool compress_output_to_zip_archive: Specifies whether output will be created as one zip-archive.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_svg_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_svg_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_svg_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_svg_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.svg) (required)
        :param bool compress_output_to_zip_archive: Specifies whether output will be created as one zip-archive.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'compress_output_to_zip_archive', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_svg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_svg`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_svg`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'compress_output_to_zip_archive' in params:
            query_params.append(('compressOutputToZipArchive', params['compress_output_to_zip_archive']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/svg', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_tiff(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_tiff(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_tiff_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_tiff_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_tiff_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_tiff_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
        :param float brightness: Image brightness.
        :param str compression: Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
        :param str color_depth: Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
        :param int left_margin: Left image margin.
        :param int right_margin: Right image margin.
        :param int top_margin: Top image margin.
        :param int bottom_margin: Bottom image margin.
        :param str orientation: Image orientation. Possible values are: None, Landscape, Portait.
        :param bool skip_blank_pages: Skip blank pages flag.
        :param int width: Image width.
        :param int height: Image height.
        :param int x_resolution: Horizontal resolution.
        :param int y_resolution: Vertical resolution.
        :param int page_index: Start page to export.
        :param int page_count: Number of pages to export.
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'brightness', 'compression', 'color_depth', 'left_margin', 'right_margin', 'top_margin', 'bottom_margin', 'orientation', 'skip_blank_pages', 'width', 'height', 'x_resolution', 'y_resolution', 'page_index', 'page_count', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_tiff`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_tiff`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'brightness' in params:
            query_params.append(('brightness', params['brightness']))
        if 'compression' in params:
            query_params.append(('compression', params['compression']))
        if 'color_depth' in params:
            query_params.append(('colorDepth', params['color_depth']))
        if 'left_margin' in params:
            query_params.append(('leftMargin', params['left_margin']))
        if 'right_margin' in params:
            query_params.append(('rightMargin', params['right_margin']))
        if 'top_margin' in params:
            query_params.append(('topMargin', params['top_margin']))
        if 'bottom_margin' in params:
            query_params.append(('bottomMargin', params['bottom_margin']))
        if 'orientation' in params:
            query_params.append(('orientation', params['orientation']))
        if 'skip_blank_pages' in params:
            query_params.append(('skipBlankPages', params['skip_blank_pages']))
        if 'width' in params:
            query_params.append(('width', params['width']))
        if 'height' in params:
            query_params.append(('height', params['height']))
        if 'x_resolution' in params:
            query_params.append(('xResolution', params['x_resolution']))
        if 'y_resolution' in params:
            query_params.append(('yResolution', params['y_resolution']))
        if 'page_index' in params:
            query_params.append(('pageIndex', params['page_index']))
        if 'page_count' in params:
            query_params.append(('pageCount', params['page_count']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/tiff', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_xls(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xls(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xls) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_xls_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_xls_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_xls_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xls_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xls) (required)
        :param bool insert_blank_column_at_first: Insert blank column at first
        :param bool minimize_the_number_of_worksheets: Minimize the number of worksheets
        :param float scale_factor: Scale factor
        :param bool uniform_worksheets: Uniform worksheets
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'insert_blank_column_at_first', 'minimize_the_number_of_worksheets', 'scale_factor', 'uniform_worksheets', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_xls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_xls`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_xls`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'insert_blank_column_at_first' in params:
            query_params.append(('insertBlankColumnAtFirst', params['insert_blank_column_at_first']))
        if 'minimize_the_number_of_worksheets' in params:
            query_params.append(('minimizeTheNumberOfWorksheets', params['minimize_the_number_of_worksheets']))
        if 'scale_factor' in params:
            query_params.append(('scaleFactor', params['scale_factor']))
        if 'uniform_worksheets' in params:
            query_params.append(('uniformWorksheets', params['uniform_worksheets']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/xls', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_xml(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XML format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xml(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xml) (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_xml_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_xml_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_xml_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XML format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xml_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xml) (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_xml`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_xml`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/xml', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_pdf_in_storage_to_xps(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xps(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xps) (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_pdf_in_storage_to_xps_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_pdf_in_storage_to_xps_with_http_info(name, out_path, **kwargs)
            return data

    def put_pdf_in_storage_to_xps_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_pdf_in_storage_to_xps_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.xps) (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_pdf_in_storage_to_xps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_pdf_in_storage_to_xps`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_pdf_in_storage_to_xps`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/xps', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_privileges(self, name, **kwargs):
        """
        Update privilege document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_privileges(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param DocumentPrivilege privileges: Document privileges. 
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_privileges_with_http_info(name, **kwargs)
        else:
            (data) = self.put_privileges_with_http_info(name, **kwargs)
            return data

    def put_privileges_with_http_info(self, name, **kwargs):
        """
        Update privilege document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_privileges_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param DocumentPrivilege privileges: Document privileges. 
        :param str folder: The document folder.
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'privileges', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_privileges" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_privileges`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'privileges' in params:
            body_params = params['privileges']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/privileges', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_searchable_document(self, name, **kwargs):
        """
        Create searchable PDF document. Generate OCR layer for images in input PDF document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_searchable_document(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str lang: language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus 
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_searchable_document_with_http_info(name, **kwargs)
        else:
            (data) = self.put_searchable_document_with_http_info(name, **kwargs)
            return data

    def put_searchable_document_with_http_info(self, name, **kwargs):
        """
        Create searchable PDF document. Generate OCR layer for images in input PDF document.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_searchable_document_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str storage: The document storage.
        :param str folder: The document folder.
        :param str lang: language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus 
        :return: SaaSposeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'lang']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_searchable_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_searchable_document`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))
        if 'lang' in params:
            query_params.append(('lang', params['lang']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/ocr', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SaaSposeResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_set_property(self, name, property_name, **kwargs):
        """
        Add/update document property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_set_property(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str property_name: (required)
        :param DocumentProperty _property:
        :param str storage:
        :param str folder:
        :return: DocumentPropertyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_set_property_with_http_info(name, property_name, **kwargs)
        else:
            (data) = self.put_set_property_with_http_info(name, property_name, **kwargs)
            return data

    def put_set_property_with_http_info(self, name, property_name, **kwargs):
        """
        Add/update document property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_set_property_with_http_info(name, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: (required)
        :param str property_name: (required)
        :param DocumentProperty _property:
        :param str storage:
        :param str folder:
        :return: DocumentPropertyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'property_name', '_property', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_set_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_set_property`")
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params) or (params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `put_set_property`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'property_name' in params:
            path_params['propertyName'] = params['property_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if '_property' in params:
            body_params = params['_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/documentproperties/{propertyName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DocumentPropertyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_update_field(self, name, field_name, **kwargs):
        """
        Update field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_update_field(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The name of a field to be updated. (required)
        :param Field field: with the field data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_update_field_with_http_info(name, field_name, **kwargs)
        else:
            (data) = self.put_update_field_with_http_info(name, field_name, **kwargs)
            return data

    def put_update_field_with_http_info(self, name, field_name, **kwargs):
        """
        Update field.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_update_field_with_http_info(name, field_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str field_name: The name of a field to be updated. (required)
        :param Field field: with the field data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'field_name', 'field', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_update_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_update_field`")
        # verify the required parameter 'field_name' is set
        if ('field_name' not in params) or (params['field_name'] is None):
            raise ValueError("Missing the required parameter `field_name` when calling `put_update_field`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']
        if 'field_name' in params:
            path_params['fieldName'] = params['field_name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field' in params:
            body_params = params['field']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/fields/{fieldName}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FieldResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_update_fields(self, name, **kwargs):
        """
        Update fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_update_fields(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param Fields fields: with the fields data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_update_fields_with_http_info(name, **kwargs)
        else:
            (data) = self.put_update_fields_with_http_info(name, **kwargs)
            return data

    def put_update_fields_with_http_info(self, name, **kwargs):
        """
        Update fields.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_update_fields_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param Fields fields: with the fields data.
        :param str storage: The document storage.
        :param str folder: The document folder.
        :return: FieldsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'fields', 'storage', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_update_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_update_fields`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'fields' in params:
            body_params = params['fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/fields', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FieldsResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_xfa_pdf_in_request_to_acro_form(self, out_path, **kwargs):
        """
        Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xfa_pdf_in_request_to_acro_form(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_xfa_pdf_in_request_to_acro_form_with_http_info(out_path, **kwargs)
        else:
            (data) = self.put_xfa_pdf_in_request_to_acro_form_with_http_info(out_path, **kwargs)
            return data

    def put_xfa_pdf_in_request_to_acro_form_with_http_info(self, out_path, **kwargs):
        """
        Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xfa_pdf_in_request_to_acro_form_with_http_info(out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param file file: A file to be converted.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['out_path', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_xfa_pdf_in_request_to_acro_form" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_xfa_pdf_in_request_to_acro_form`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/convert/xfatoacroform', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_xfa_pdf_in_storage_to_acro_form(self, name, out_path, **kwargs):
        """
        Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xfa_pdf_in_storage_to_acro_form(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_xfa_pdf_in_storage_to_acro_form_with_http_info(name, out_path, **kwargs)
        else:
            (data) = self.put_xfa_pdf_in_storage_to_acro_form_with_http_info(name, out_path, **kwargs)
            return data

    def put_xfa_pdf_in_storage_to_acro_form_with_http_info(self, name, out_path, **kwargs):
        """
        Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_xfa_pdf_in_storage_to_acro_form_with_http_info(name, out_path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The document name. (required)
        :param str out_path: Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
        :param str folder: The document folder.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'out_path', 'folder']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_xfa_pdf_in_storage_to_acro_form" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_xfa_pdf_in_storage_to_acro_form`")
        # verify the required parameter 'out_path' is set
        if ('out_path' not in params) or (params['out_path'] is None):
            raise ValueError("Missing the required parameter `out_path` when calling `put_xfa_pdf_in_storage_to_acro_form`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))
        if 'folder' in params:
            query_params.append(('folder', params['folder']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/pdf/{name}/convert/xfatoacroform', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
